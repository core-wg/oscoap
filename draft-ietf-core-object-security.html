<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" 
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">

<html lang="en" xmlns="http://www.w3.org/1999/xhtml" xml:lang="en">
<head profile="http://www.w3.org/2006/03/hcard http://dublincore.org/documents/2008/08/04/dc-html/">
  <meta http-equiv="Content-Type" content="text/html; charset=us-ascii" />

  <title>Object Security for Constrained RESTful Environments (OSCORE)</title>

  
<style type="text/css">/*<![CDATA[*/

body {
  font: 16px "Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  color: #333;
  font-size-adjust: 0.5;
  line-height: 24px;
  margin: 75px auto;
  max-width: 624px;
  padding: 0 5px;
}

.title, .filename, h1, h2, h3, h4, h5 {
  font: 16px "Roboto Condensed","Helvetica Neue","Open Sans",Helvetica,Calibri,sans-serif;
  font-size-adjust: 0.5;
  font-weight: bold;
  color: #333;
  line-height: 100%;
  margin: 1.2em 0 0.3em;
}
.title, #rfc\.title h1 { font-size: 32px; }
h1, section h1, h2, section h2, section h3, nav h2 { font-size: 20px; }
h3, section h4, h4, section h5 { font-size: 16px; }
h1 a[href], h2 a[href], h3 a[href], h4 a[href] {
  color: #333;
}

table {
  margin-left: 0em;
  border-collapse: collapse;
}
th {
  text-align: left;
  border-bottom: 2px solid #ddd;
}
td {
  border-top: 1px solid #ddd;
  vertical-align: top;
}
tr:nth-child(2n+1) > td,
tr:nth-child(2n+1) > th {
  background-color: #f9f9f9;
}
td.reference {
  max-width: 200px;
  border-top: none;
  padding-right: 1em;
}
.right {
  text-align: right;
}


table.header, table#rfc\.headerblock {
  width: 100%;
}
table.header td, table#rfc\.headerblock td {
  border: none;
  background-color: transparent;
  color: black;
  padding: 0;
}
.filename {
  display: block;
  color: rgb(119, 119, 119);
  font-size: 20px;
  font-weight: normal;
  line-height: 100%;
  margin: 10px 0 32px;
}
#rfc\.abstract+p, #rfc\.abstract+p code, #rfc\.abstract+p samp, #rfc\.abstract+p tt {
  font-size: 20px;
  line-height: 28px;
}

samp, tt, code, pre, span.tt {
  font-size: 13.5px;
  font-family: Consolas, monospace;
  font-size-adjust: none;
}
pre {
  background-color: #eee;
  border: 1px solid #ddd;
  overflow-x: auto;
  padding: 5px;
  margin: 5px;
}
.figure, caption {
  font-style: italic;
  margin: 0 1.5em;
  text-align: left;
}

address {
  margin: 16px 2px;
  line-height: 20px;
}
.vcard {
  font-style: normal;
}
.vcardline {
  display: block;
}
.vcardline .fn, address b {
  font-weight: normal;
}
.vcardline .hidden {
  display: none;
}

dl {
  margin-left: 1em;
}
dl.dl-horizontal: {
  margin-left: 0;
}
dl > dt {
  float: left;
  margin-right: 1em;
}
dl.nohang > dt {
  float: none;
}
dl > dd {
  margin-bottom: .5em;
}
dl.compact > dd {
  margin-bottom: 0em;
}
dl > dd > dl {
  margin-top: 0.5em;
  margin-bottom: 0em;
}
ul.empty {
  list-style-type: none;
}
ul.empty li {
  margin-top: .5em;
}

hr {
  border: 0;
  border-top: 1px solid #eee;
}
hr.noprint {
  display: none;
}

a {
  text-decoration: none;
}
a[href] {
  color: #2a6496;
}
a[href]:hover {
  background-color: #eee;
}

p, ol, ul, li {
  padding: 0;
}
p {
  margin: 0.5em 0;
}
ol, ul {
  margin: 0.2em 0 0.2em 2em;
}
li {
  margin: 0.2em 0;
}
address {
  font-style: normal;
}

ul.toc ul {
  margin: 0 0 0 2em;
}
ul.toc li {
  list-style: none;
  margin: 0;
}

@media screen and (min-width: 924px) {
  body {
    padding-right: 350px;
  }
  body>ul.toc, body>#rfc\.toc {
    position: fixed;
    bottom: 0;
    right: 0;
    right: calc(50vw - 500px);
    width: 300px;
    z-index: 1;
    overflow: auto;
    overscroll-behavior: contain;
  }
  body>#rfc\.toc {
    top: 55px;
  }
  body>ul.toc {
    top: 100px;
  }

  ul.toc {
    margin: 0 0 0 4px;
    font-size: 12px;
    line-height: 20px;
  }
  ul.toc ul {
    margin-left: 1.2em;
  }
}

.github-fork-ribbon-wrapper {
  display: none;
}
@media screen and (min-width: 800px) {
  /* "Fork me on GitHub" CSS ribbon based on
   * https://github.com/simonwhitaker/github-fork-ribbon-css
   */
  .github-fork-ribbon {
    position: absolute;
    padding: 2px 0;
    background-color: #a00;
    background-image: linear-gradient(to bottom, rgba(0, 0, 0, 0), rgba(0, 0, 0, 0.15));
    box-shadow: 0 2px 3px 0 rgba(0, 0, 0, 0.5);
    font: 700 12px "Helvetica Neue", Helvetica, Arial, sans-serif;

    pointer-events: auto;

    top: 38px;
    right: -45px;

    transform: rotate(45deg);
  }

  .github-fork-ribbon a[href],
  .github-fork-ribbon a[href]:hover {
    color: #fff;
    background-color: transparent;
    text-decoration: none;
    text-shadow: 0 -1px rgba(0, 0, 0, 0.5);
    text-align: center;

    width: 190px;
    line-height: 18px;

    display: inline-block;
    padding: 2px 0;

    border: 1.5px dotted #fff;
    border-color: rgba(255, 255, 255, 0.6);
  }

  .github-fork-ribbon-wrapper {
    display: block;
    width: 130px;
    height: 130px;
    position: absolute;
    overflow: hidden;
    top: 0; right: 0;
    z-index: 2;
    pointer-events: none;
  }
}
@media screen and (min-width: 1000px) {
  .github-fork-ribbon-wrapper {
    position: fixed;
  }
  /*]]>*/</style>
  <meta name="viewport" content="initial-scale=1.0">


  <link href="#rfc.toc" rel="Contents">
<link href="#rfc.section.1" rel="Chapter" title="1 Introduction">
<link href="#rfc.section.1.1" rel="Chapter" title="1.1 Terminology">
<link href="#rfc.section.2" rel="Chapter" title="2 The OSCORE Option">
<link href="#rfc.section.3" rel="Chapter" title="3 The Security Context">
<link href="#rfc.section.3.1" rel="Chapter" title="3.1 Security Context Definition">
<link href="#rfc.section.3.2" rel="Chapter" title="3.2 Establishment of Security Context Parameters">
<link href="#rfc.section.3.3" rel="Chapter" title="3.3 Requirements on the Security Context Parameters">
<link href="#rfc.section.4" rel="Chapter" title="4 Protected Message Fields">
<link href="#rfc.section.4.1" rel="Chapter" title="4.1 CoAP Options">
<link href="#rfc.section.4.2" rel="Chapter" title="4.2 CoAP Header Fields and Payload">
<link href="#rfc.section.4.3" rel="Chapter" title="4.3 Signaling Messages">
<link href="#rfc.section.5" rel="Chapter" title="5 The COSE Object">
<link href="#rfc.section.5.1" rel="Chapter" title="5.1 ID Context and &#8216;kid context&#8217;">
<link href="#rfc.section.5.2" rel="Chapter" title="5.2 AEAD Nonce">
<link href="#rfc.section.5.3" rel="Chapter" title="5.3 Plaintext">
<link href="#rfc.section.5.4" rel="Chapter" title="5.4 Additional Authenticated Data">
<link href="#rfc.section.6" rel="Chapter" title="6 OSCORE Header Compression">
<link href="#rfc.section.6.1" rel="Chapter" title="6.1 Encoding of the OSCORE Option Value">
<link href="#rfc.section.6.2" rel="Chapter" title="6.2 Encoding of the OSCORE Payload">
<link href="#rfc.section.6.3" rel="Chapter" title="6.3 Examples of Compressed COSE Objects">
<link href="#rfc.section.7" rel="Chapter" title="7 Message Binding, Sequence Numbers, Freshness, and Replay Protection">
<link href="#rfc.section.7.1" rel="Chapter" title="7.1 Message Binding">
<link href="#rfc.section.7.2" rel="Chapter" title="7.2 Sequence Numbers">
<link href="#rfc.section.7.3" rel="Chapter" title="7.3 Freshness">
<link href="#rfc.section.7.4" rel="Chapter" title="7.4 Replay Protection">
<link href="#rfc.section.7.5" rel="Chapter" title="7.5 Losing Part of the Context State">
<link href="#rfc.section.8" rel="Chapter" title="8 Processing">
<link href="#rfc.section.8.1" rel="Chapter" title="8.1 Protecting the Request">
<link href="#rfc.section.8.2" rel="Chapter" title="8.2 Verifying the Request">
<link href="#rfc.section.8.3" rel="Chapter" title="8.3 Protecting the Response">
<link href="#rfc.section.8.4" rel="Chapter" title="8.4 Verifying the Response">
<link href="#rfc.section.9" rel="Chapter" title="9 Web Linking">
<link href="#rfc.section.10" rel="Chapter" title="10 CoAP-to-CoAP Forwarding Proxy">
<link href="#rfc.section.11" rel="Chapter" title="11 HTTP Operations">
<link href="#rfc.section.11.1" rel="Chapter" title="11.1 The HTTP OSCORE Header Field">
<link href="#rfc.section.11.2" rel="Chapter" title="11.2 CoAP-to-HTTP Mapping">
<link href="#rfc.section.11.3" rel="Chapter" title="11.3 HTTP-to-CoAP Mapping">
<link href="#rfc.section.11.4" rel="Chapter" title="11.4 HTTP Endpoints">
<link href="#rfc.section.11.5" rel="Chapter" title="11.5 Example: HTTP Client and CoAP Server">
<link href="#rfc.section.11.6" rel="Chapter" title="11.6 Example: CoAP Client and HTTP Server">
<link href="#rfc.section.12" rel="Chapter" title="12 Security Considerations">
<link href="#rfc.section.12.1" rel="Chapter" title="12.1 End-to-end Protection">
<link href="#rfc.section.12.2" rel="Chapter" title="12.2 Security Context Establishment">
<link href="#rfc.section.12.3" rel="Chapter" title="12.3 Master Secret">
<link href="#rfc.section.12.4" rel="Chapter" title="12.4 Replay Protection">
<link href="#rfc.section.12.5" rel="Chapter" title="12.5 Client Aliveness">
<link href="#rfc.section.12.6" rel="Chapter" title="12.6 Cryptographic Considerations">
<link href="#rfc.section.12.7" rel="Chapter" title="12.7 Message Segmentation">
<link href="#rfc.section.12.8" rel="Chapter" title="12.8 Privacy Considerations">
<link href="#rfc.section.13" rel="Chapter" title="13 IANA Considerations">
<link href="#rfc.section.13.1" rel="Chapter" title="13.1 COSE Header Parameters Registry">
<link href="#rfc.section.13.2" rel="Chapter" title="13.2 CoAP Option Numbers Registry">
<link href="#rfc.section.13.3" rel="Chapter" title="13.3 CoAP Signaling Option Numbers Registry">
<link href="#rfc.section.13.4" rel="Chapter" title="13.4 Header Field Registrations">
<link href="#rfc.section.13.5" rel="Chapter" title="13.5 Media Type Registrations">
<link href="#rfc.section.13.6" rel="Chapter" title="13.6 CoAP Content-Formats Registry">
<link href="#rfc.section.13.7" rel="Chapter" title="13.7 OSCORE Flag Bits Registry">
<link href="#rfc.section.13.8" rel="Chapter" title="13.8 Expert Review Instructions">
<link href="#rfc.references" rel="Chapter" title="14 References">
<link href="#rfc.references.1" rel="Chapter" title="14.1 Normative References">
<link href="#rfc.references.2" rel="Chapter" title="14.2 Informative References">
<link href="#rfc.appendix.A" rel="Chapter" title="A Scenario Examples">
<link href="#rfc.appendix.A.1" rel="Chapter" title="A.1 Secure Access to Sensor">
<link href="#rfc.appendix.A.2" rel="Chapter" title="A.2 Secure Subscribe to Sensor">
<link href="#rfc.appendix.B" rel="Chapter" title="B Deployment Examples">
<link href="#rfc.appendix.B.1" rel="Chapter" title="B.1 Security Context Derived Once">
<link href="#rfc.appendix.B.2" rel="Chapter" title="B.2 Security Context Derived Multiple Times">
<link href="#rfc.appendix.C" rel="Chapter" title="C Test Vectors">
<link href="#rfc.appendix.C.1" rel="Chapter" title="C.1 Test Vector 1: Key Derivation with Master Salt">
<link href="#rfc.appendix.C.2" rel="Chapter" title="C.2 Test Vector 2: Key Derivation without Master Salt">
<link href="#rfc.appendix.C.3" rel="Chapter" title="C.3 Test Vector 3: Key Derivation with ID Context">
<link href="#rfc.appendix.C.4" rel="Chapter" title="C.4 Test Vector 4: OSCORE Request, Client">
<link href="#rfc.appendix.C.5" rel="Chapter" title="C.5 Test Vector 5: OSCORE Request, Client">
<link href="#rfc.appendix.C.6" rel="Chapter" title="C.6 Test Vector 6: OSCORE Request, Client">
<link href="#rfc.appendix.C.7" rel="Chapter" title="C.7 Test Vector 7: OSCORE Response, Server">
<link href="#rfc.appendix.C.8" rel="Chapter" title="C.8 Test Vector 8: OSCORE Response with Partial IV, Server">
<link href="#rfc.appendix.D" rel="Chapter" title="D Overview of Security Properties">
<link href="#rfc.appendix.D.1" rel="Chapter" title="D.1 Threat Model">
<link href="#rfc.appendix.D.2" rel="Chapter" title="D.2 Supporting Proxy Operations">
<link href="#rfc.appendix.D.3" rel="Chapter" title="D.3 Protected Message Fields">
<link href="#rfc.appendix.D.4" rel="Chapter" title="D.4 Uniqueness of (key, nonce)">
<link href="#rfc.appendix.D.5" rel="Chapter" title="D.5 Unprotected Message Fields">
<link href="#rfc.appendix.E" rel="Chapter" title="E CDDL Summary">
<link href="#rfc.acknowledgments" rel="Chapter">
<link href="#rfc.authors" rel="Chapter">


  <meta name="generator" content="xml2rfc version 2.22.3 - https://tools.ietf.org/tools/xml2rfc" />
  <link rel="schema.dct" href="http://purl.org/dc/terms/" />

  <meta name="dct.creator" content="Selander, G., Mattsson, J., Palombini, F., and L. Seitz" />
  <meta name="dct.identifier" content="urn:ietf:id:draft-ietf-core-object-security-latest" />
  <meta name="dct.issued" scheme="ISO8601" content="2019-06-24" />
  <meta name="dct.abstract" content="This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols.Although being an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates ." />
  <meta name="description" content="This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols.Although being an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates ." />

</head>

<body>

  <table class="header">
    <tbody>
    
    	<tr>
<td class="left">CoRE Working Group</td>
<td class="right">G. Selander</td>
</tr>
<tr>
<td class="left">Internet-Draft</td>
<td class="right">J. Mattsson</td>
</tr>
<tr>
<td class="left">Updates: 7252 (if approved)</td>
<td class="right">F. Palombini</td>
</tr>
<tr>
<td class="left">Intended status: Standards Track</td>
<td class="right">Ericsson AB</td>
</tr>
<tr>
<td class="left">Expires: December 26, 2019</td>
<td class="right">L. Seitz</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">RISE SICS</td>
</tr>
<tr>
<td class="left"></td>
<td class="right">June 24, 2019</td>
</tr>

    	
    </tbody>
  </table>

  <p class="title">Object Security for Constrained RESTful Environments (OSCORE)<br />
  <span class="filename">draft-ietf-core-object-security-latest</span></p>
  
  <h1 id="rfc.abstract"><a href="#rfc.abstract">Abstract</a></h1>
<p>This document defines Object Security for Constrained RESTful Environments (OSCORE), a method for application-layer protection of the Constrained Application Protocol (CoAP), using CBOR Object Signing and Encryption (COSE). OSCORE provides end-to-end protection between endpoints communicating using CoAP or CoAP-mappable HTTP. OSCORE is designed for constrained nodes and networks supporting a range of proxy operations, including translation between different transport protocols.</p>
<p>Although being an optional functionality of CoAP, OSCORE alters CoAP options processing and IANA registration. Therefore, this document updates <a href="#RFC7252" class="xref">[RFC7252]</a>.</p>
<h1 id="rfc.status"><a href="#rfc.status">Status of This Memo</a></h1>
<p>This Internet-Draft is submitted in full conformance with the provisions of BCP 78 and BCP 79.</p>
<p>Internet-Drafts are working documents of the Internet Engineering Task Force (IETF).  Note that other groups may also distribute working documents as Internet-Drafts.  The list of current Internet-Drafts is at https://datatracker.ietf.org/drafts/current/.</p>
<p>Internet-Drafts are draft documents valid for a maximum of six months and may be updated, replaced, or obsoleted by other documents at any time.  It is inappropriate to use Internet-Drafts as reference material or to cite them other than as "work in progress."</p>
<p>This Internet-Draft will expire on December 26, 2019.</p>
<h1 id="rfc.copyrightnotice"><a href="#rfc.copyrightnotice">Copyright Notice</a></h1>
<p>Copyright (c) 2019 IETF Trust and the persons identified as the document authors.  All rights reserved.</p>
<p>This document is subject to BCP 78 and the IETF Trust's Legal Provisions Relating to IETF Documents (https://trustee.ietf.org/license-info) in effect on the date of publication of this document.  Please review these documents carefully, as they describe your rights and restrictions with respect to this document.  Code Components extracted from this document must include Simplified BSD License text as described in Section 4.e of the Trust Legal Provisions and are provided without warranty as described in the Simplified BSD License.</p>

  
  <hr class="noprint" />
  <h1 class="np" id="rfc.toc"><a href="#rfc.toc">Table of Contents</a></h1>
  <ul class="toc">

  	<li>1.   <a href="#rfc.section.1">Introduction</a>
</li>
<ul><li>1.1.   <a href="#rfc.section.1.1">Terminology</a>
</li>
</ul><li>2.   <a href="#rfc.section.2">The OSCORE Option</a>
</li>
<li>3.   <a href="#rfc.section.3">The Security Context</a>
</li>
<ul><li>3.1.   <a href="#rfc.section.3.1">Security Context Definition</a>
</li>
<li>3.2.   <a href="#rfc.section.3.2">Establishment of Security Context Parameters</a>
</li>
<li>3.3.   <a href="#rfc.section.3.3">Requirements on the Security Context Parameters</a>
</li>
</ul><li>4.   <a href="#rfc.section.4">Protected Message Fields</a>
</li>
<ul><li>4.1.   <a href="#rfc.section.4.1">CoAP Options</a>
</li>
<li>4.2.   <a href="#rfc.section.4.2">CoAP Header Fields and Payload</a>
</li>
<li>4.3.   <a href="#rfc.section.4.3">Signaling Messages</a>
</li>
</ul><li>5.   <a href="#rfc.section.5">The COSE Object</a>
</li>
<ul><li>5.1.   <a href="#rfc.section.5.1">ID Context and &#8216;kid context&#8217;</a>
</li>
<li>5.2.   <a href="#rfc.section.5.2">AEAD Nonce</a>
</li>
<li>5.3.   <a href="#rfc.section.5.3">Plaintext</a>
</li>
<li>5.4.   <a href="#rfc.section.5.4">Additional Authenticated Data</a>
</li>
</ul><li>6.   <a href="#rfc.section.6">OSCORE Header Compression</a>
</li>
<ul><li>6.1.   <a href="#rfc.section.6.1">Encoding of the OSCORE Option Value</a>
</li>
<li>6.2.   <a href="#rfc.section.6.2">Encoding of the OSCORE Payload</a>
</li>
<li>6.3.   <a href="#rfc.section.6.3">Examples of Compressed COSE Objects</a>
</li>
</ul><li>7.   <a href="#rfc.section.7">Message Binding, Sequence Numbers, Freshness, and Replay Protection</a>
</li>
<ul><li>7.1.   <a href="#rfc.section.7.1">Message Binding</a>
</li>
<li>7.2.   <a href="#rfc.section.7.2">Sequence Numbers</a>
</li>
<li>7.3.   <a href="#rfc.section.7.3">Freshness</a>
</li>
<li>7.4.   <a href="#rfc.section.7.4">Replay Protection</a>
</li>
<li>7.5.   <a href="#rfc.section.7.5">Losing Part of the Context State</a>
</li>
</ul><li>8.   <a href="#rfc.section.8">Processing</a>
</li>
<ul><li>8.1.   <a href="#rfc.section.8.1">Protecting the Request</a>
</li>
<li>8.2.   <a href="#rfc.section.8.2">Verifying the Request</a>
</li>
<li>8.3.   <a href="#rfc.section.8.3">Protecting the Response</a>
</li>
<li>8.4.   <a href="#rfc.section.8.4">Verifying the Response</a>
</li>
</ul><li>9.   <a href="#rfc.section.9">Web Linking</a>
</li>
<li>10.   <a href="#rfc.section.10">CoAP-to-CoAP Forwarding Proxy</a>
</li>
<li>11.   <a href="#rfc.section.11">HTTP Operations</a>
</li>
<ul><li>11.1.   <a href="#rfc.section.11.1">The HTTP OSCORE Header Field</a>
</li>
<li>11.2.   <a href="#rfc.section.11.2">CoAP-to-HTTP Mapping</a>
</li>
<li>11.3.   <a href="#rfc.section.11.3">HTTP-to-CoAP Mapping</a>
</li>
<li>11.4.   <a href="#rfc.section.11.4">HTTP Endpoints</a>
</li>
<li>11.5.   <a href="#rfc.section.11.5">Example: HTTP Client and CoAP Server</a>
</li>
<li>11.6.   <a href="#rfc.section.11.6">Example: CoAP Client and HTTP Server</a>
</li>
</ul><li>12.   <a href="#rfc.section.12">Security Considerations</a>
</li>
<ul><li>12.1.   <a href="#rfc.section.12.1">End-to-end Protection</a>
</li>
<li>12.2.   <a href="#rfc.section.12.2">Security Context Establishment</a>
</li>
<li>12.3.   <a href="#rfc.section.12.3">Master Secret</a>
</li>
<li>12.4.   <a href="#rfc.section.12.4">Replay Protection</a>
</li>
<li>12.5.   <a href="#rfc.section.12.5">Client Aliveness</a>
</li>
<li>12.6.   <a href="#rfc.section.12.6">Cryptographic Considerations</a>
</li>
<li>12.7.   <a href="#rfc.section.12.7">Message Segmentation</a>
</li>
<li>12.8.   <a href="#rfc.section.12.8">Privacy Considerations</a>
</li>
</ul><li>13.   <a href="#rfc.section.13">IANA Considerations</a>
</li>
<ul><li>13.1.   <a href="#rfc.section.13.1">COSE Header Parameters Registry</a>
</li>
<li>13.2.   <a href="#rfc.section.13.2">CoAP Option Numbers Registry</a>
</li>
<li>13.3.   <a href="#rfc.section.13.3">CoAP Signaling Option Numbers Registry</a>
</li>
<li>13.4.   <a href="#rfc.section.13.4">Header Field Registrations</a>
</li>
<li>13.5.   <a href="#rfc.section.13.5">Media Type Registrations</a>
</li>
<li>13.6.   <a href="#rfc.section.13.6">CoAP Content-Formats Registry</a>
</li>
<li>13.7.   <a href="#rfc.section.13.7">OSCORE Flag Bits Registry</a>
</li>
<li>13.8.   <a href="#rfc.section.13.8">Expert Review Instructions</a>
</li>
</ul><li>14.   <a href="#rfc.references">References</a>
</li>
<ul><li>14.1.   <a href="#rfc.references.1">Normative References</a>
</li>
<li>14.2.   <a href="#rfc.references.2">Informative References</a>
</li>
</ul><li>Appendix A.   <a href="#rfc.appendix.A">Scenario Examples</a>
</li>
<ul><li>A.1.   <a href="#rfc.appendix.A.1">Secure Access to Sensor</a>
</li>
<li>A.2.   <a href="#rfc.appendix.A.2">Secure Subscribe to Sensor</a>
</li>
</ul><li>Appendix B.   <a href="#rfc.appendix.B">Deployment Examples</a>
</li>
<ul><li>B.1.   <a href="#rfc.appendix.B.1">Security Context Derived Once</a>
</li>
<li>B.2.   <a href="#rfc.appendix.B.2">Security Context Derived Multiple Times</a>
</li>
</ul><li>Appendix C.   <a href="#rfc.appendix.C">Test Vectors</a>
</li>
<ul><li>C.1.   <a href="#rfc.appendix.C.1">Test Vector 1: Key Derivation with Master Salt</a>
</li>
<li>C.2.   <a href="#rfc.appendix.C.2">Test Vector 2: Key Derivation without Master Salt</a>
</li>
<li>C.3.   <a href="#rfc.appendix.C.3">Test Vector 3: Key Derivation with ID Context</a>
</li>
<li>C.4.   <a href="#rfc.appendix.C.4">Test Vector 4: OSCORE Request, Client</a>
</li>
<li>C.5.   <a href="#rfc.appendix.C.5">Test Vector 5: OSCORE Request, Client</a>
</li>
<li>C.6.   <a href="#rfc.appendix.C.6">Test Vector 6: OSCORE Request, Client</a>
</li>
<li>C.7.   <a href="#rfc.appendix.C.7">Test Vector 7: OSCORE Response, Server</a>
</li>
<li>C.8.   <a href="#rfc.appendix.C.8">Test Vector 8: OSCORE Response with Partial IV, Server</a>
</li>
</ul><li>Appendix D.   <a href="#rfc.appendix.D">Overview of Security Properties</a>
</li>
<ul><li>D.1.   <a href="#rfc.appendix.D.1">Threat Model</a>
</li>
<li>D.2.   <a href="#rfc.appendix.D.2">Supporting Proxy Operations</a>
</li>
<li>D.3.   <a href="#rfc.appendix.D.3">Protected Message Fields</a>
</li>
<li>D.4.   <a href="#rfc.appendix.D.4">Uniqueness of (key, nonce)</a>
</li>
<li>D.5.   <a href="#rfc.appendix.D.5">Unprotected Message Fields</a>
</li>
</ul><li>Appendix E.   <a href="#rfc.appendix.E">CDDL Summary</a>
</li>
<li><a href="#rfc.acknowledgments">Acknowledgments</a>
</li>
<li><a href="#rfc.authors">Authors' Addresses</a>
</li>


  </ul>

  <h1 id="rfc.section.1">
<a href="#rfc.section.1">1.</a> <a href="#intro" id="intro">Introduction</a>
</h1>
<p id="rfc.section.1.p.1">The Constrained Application Protocol (CoAP) <a href="#RFC7252" class="xref">[RFC7252]</a> is a web transfer protocol, designed for constrained nodes and networks <a href="#RFC7228" class="xref">[RFC7228]</a>, and may be mapped from HTTP <a href="#RFC8075" class="xref">[RFC8075]</a>. CoAP specifies the use of proxies for scalability and efficiency and references DTLS <a href="#RFC6347" class="xref">[RFC6347]</a> for security. CoAP-to-CoAP, HTTP-to-CoAP, and CoAP-to-HTTP proxies require DTLS or TLS <a href="#RFC8446" class="xref">[RFC8446]</a> to be terminated at the proxy. The proxy therefore not only has access to the data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of, the message payload and metadata in transit between the endpoints. The proxy can also inject, delete, or reorder packets since they are no longer protected by (D)TLS.</p>
<p id="rfc.section.1.p.2">This document defines the Object Security for Constrained RESTful Environments (OSCORE) security protocol, protecting CoAP and CoAP-mappable HTTP requests and responses end-to-end across intermediary nodes such as CoAP forward proxies and cross-protocol translators including HTTP-to-CoAP proxies <a href="#RFC8075" class="xref">[RFC8075]</a>. In addition to the core CoAP features defined in <a href="#RFC7252" class="xref">[RFC7252]</a>, OSCORE supports the Observe <a href="#RFC7641" class="xref">[RFC7641]</a>, Block-wise <a href="#RFC7959" class="xref">[RFC7959]</a>, and No-Response <a href="#RFC7967" class="xref">[RFC7967]</a> options, as well as the PATCH and FETCH methods <a href="#RFC8132" class="xref">[RFC8132]</a>. An analysis of end-to-end security for CoAP messages through some types of intermediary nodes is performed in <a href="#I-D.hartke-core-e2e-security-reqs" class="xref">[I-D.hartke-core-e2e-security-reqs]</a>. OSCORE essentially protects the RESTful interactions; the request method, the requested resource, the message payload, etc. (see <a href="#protected-fields" class="xref">Section 4</a>). OSCORE protects neither the CoAP Messaging Layer nor the CoAP Token which may change between the endpoints, and those are therefore processed as defined in <a href="#RFC7252" class="xref">[RFC7252]</a>. Additionally, since the message formats for CoAP over unreliable transport <a href="#RFC7252" class="xref">[RFC7252]</a> and for CoAP over reliable transport <a href="#RFC8323" class="xref">[RFC8323]</a> differ only in terms of CoAP Messaging Layer, OSCORE can be applied to both unreliable and reliable transports (see <a href="#fig-stack" class="xref">Figure 1</a>).</p>
<p id="rfc.section.1.p.3">OSCORE works in very constrained nodes and networks, thanks to its small message size and the restricted code and memory requirements in addition to what is required by CoAP. Examples of the use of OSCORE are given in <a href="#examples" class="xref">Appendix A</a>. OSCORE may be used over any underlying layer, such as e.g. UDP or TCP, and with non-IP transports (e.g., <a href="#I-D.bormann-6lo-coap-802-15-ie" class="xref">[I-D.bormann-6lo-coap-802-15-ie]</a>). OSCORE may also be used in different ways with HTTP. OSCORE messages may be transported in HTTP, and OSCORE may also be used to protect CoAP-mappable HTTP messages, as described below.</p>
<div id="rfc.figure.1"></div>
<div id="fig-stack"></div>
<pre>
+-----------------------------------+
|            Application            |
+-----------------------------------+
+-----------------------------------+  \
|  Requests / Responses / Signaling |  |
|-----------------------------------|  |
|               OSCORE              |  | CoAP
|-----------------------------------|  |
| Messaging Layer / Message Framing |  |
+-----------------------------------+  /
+-----------------------------------+
|          UDP / TCP / ...          |
+-----------------------------------+  
</pre>
<p class="figure">Figure 1: Abstract Layering of CoAP with OSCORE</p>
<p id="rfc.section.1.p.4">OSCORE is designed to protect as much information as possible while still allowing CoAP proxy operations (<a href="#coap-coap-proxy" class="xref">Section 10</a>). It works with existing CoAP-to-CoAP forward proxies <a href="#RFC7252" class="xref">[RFC7252]</a>, but an OSCORE-aware proxy will be more efficient. HTTP-to-CoAP proxies <a href="#RFC8075" class="xref">[RFC8075]</a> and CoAP-to-HTTP proxies can also be used with OSCORE, as specified in <a href="#http-op" class="xref">Section 11</a>. OSCORE may be used together with TLS or DTLS over one or more hops in the end-to-end path, e.g. transported with HTTPS in one hop and with plain CoAP in another hop. The use of OSCORE does not affect the URI scheme and OSCORE can therefore be used with any URI scheme defined for CoAP or HTTP. The application decides the conditions for which OSCORE is required.</p>
<p id="rfc.section.1.p.5">OSCORE uses pre-shared keys which may have been established out-of-band or with a key establishment protocol (see <a href="#context-derivation" class="xref">Section 3.2</a>). The technical solution builds on CBOR Object Signing and Encryption (COSE) <a href="#RFC8152" class="xref">[RFC8152]</a>, providing end-to-end encryption, integrity, replay protection, and binding of response to request. A compressed version of COSE is used, as specified in <a href="#compression" class="xref">Section 6</a>. The use of OSCORE is signaled in CoAP with a new option (<a href="#option" class="xref">Section 2</a>), and in HTTP with a new header field (<a href="#header-field" class="xref">Section 11.1</a>) and content type (<a href="#oscore-media-type" class="xref">Section 13.5</a>). The solution transforms a CoAP/HTTP message into an &#8220;OSCORE message&#8221; before sending, and vice versa after receiving. The OSCORE message is a CoAP/HTTP message related to the original message in the following way: the original CoAP/HTTP message is translated to CoAP (if not already in CoAP) and protected in a COSE object. The encrypted message fields of this COSE object are transported in the CoAP payload/HTTP body of the OSCORE message, and the OSCORE option/header field is included in the message. A sketch of an exchange of OSCORE messages, in the case of the original message being CoAP, is provided in <a href="#fig-sketch" class="xref">Figure 2</a>. The  use of OSCORE with HTTP is detailed in <a href="#http-op" class="xref">Section 11</a>.</p>
<div id="rfc.figure.2"></div>
<div id="fig-sketch"></div>
<pre>
Client                                          Server
   |      OSCORE request - POST example.com:      |
   |        Header, Token,                        |
   |        Options: OSCORE, ...,                 |
   |        Payload: COSE ciphertext              |
   +---------------------------------------------&gt;|
   |                                              |
   |&lt;---------------------------------------------+
   |      OSCORE response - 2.04 (Changed):       |
   |        Header, Token,                        |
   |        Options: OSCORE, ...,                 |
   |        Payload: COSE ciphertext              |
   |                                              |
</pre>
<p class="figure">Figure 2: Sketch of CoAP with OSCORE</p>
<p id="rfc.section.1.p.6">An implementation supporting this specification MAY implement only the client part, MAY implement only the server part, or MAY implement only one of the proxy parts.</p>
<h1 id="rfc.section.1.1">
<a href="#rfc.section.1.1">1.1.</a> <a href="#terminology" id="terminology">Terminology</a>
</h1>
<p id="rfc.section.1.1.p.1">The key words &#8220;MUST&#8221;, &#8220;MUST NOT&#8221;, &#8220;REQUIRED&#8221;, &#8220;SHALL&#8221;, &#8220;SHALL NOT&#8221;, &#8220;SHOULD&#8221;, &#8220;SHOULD NOT&#8221;, &#8220;RECOMMENDED&#8221;, &#8220;NOT RECOMMENDED&#8221;, &#8220;MAY&#8221;, and &#8220;OPTIONAL&#8221; in this document are to be interpreted as described in BCP 14 <a href="#RFC2119" class="xref">[RFC2119]</a> <a href="#RFC8174" class="xref">[RFC8174]</a> when, and only when, they appear in all capitals, as shown here.</p>
<p id="rfc.section.1.1.p.2">Readers are expected to be familiar with the terms and concepts described in CoAP <a href="#RFC7252" class="xref">[RFC7252]</a>, Observe <a href="#RFC7641" class="xref">[RFC7641]</a>, Block-wise  <a href="#RFC7959" class="xref">[RFC7959]</a>, COSE <a href="#RFC8152" class="xref">[RFC8152]</a>, CBOR <a href="#RFC7049" class="xref">[RFC7049]</a>, CDDL <a href="#I-D.ietf-cbor-cddl" class="xref">[I-D.ietf-cbor-cddl]</a> as summarized in <a href="#cddl-sum" class="xref">Appendix E</a>, and constrained environments <a href="#RFC7228" class="xref">[RFC7228]</a>.</p>
<p id="rfc.section.1.1.p.3">The term &#8220;hop&#8221; is used to denote a particular leg in the end-to-end path. The concept &#8220;hop-by-hop&#8221; (as in &#8220;hop-by-hop encryption&#8221; or &#8220;hop-by-hop fragmentation&#8221;) opposed to &#8220;end-to-end&#8221;, is used in this document to indicate that the messages are processed accordingly in the intermediaries, rather than just forwarded to the next node.</p>
<p id="rfc.section.1.1.p.4">The term &#8220;stop processing&#8221; is used throughout the document to denote that the message is not passed up to the CoAP Request/Response Layer (see <a href="#fig-stack" class="xref">Figure 1</a>).</p>
<p id="rfc.section.1.1.p.5">The terms Common/Sender/Recipient Context, Master Secret/Salt, Sender ID/Key, Recipient ID/Key, ID Context, and Common IV are defined in <a href="#context-definition" class="xref">Section 3.1</a>.</p>
<h1 id="rfc.section.2">
<a href="#rfc.section.2">2.</a> <a href="#option" id="option">The OSCORE Option</a>
</h1>
<p id="rfc.section.2.p.1">The OSCORE option defined in this section (see <a href="#fig-option" class="xref">Figure 3</a>, which extends Table 4: Options of <a href="#RFC7252" class="xref">[RFC7252]</a>) indicates that the CoAP message is an OSCORE message and that it contains a compressed COSE object (see Sections <a href="#cose-object" class="xref">5</a> and <a href="#compression" class="xref">6</a>). The OSCORE option is critical, safe to forward, part of the cache key, and not repeatable.</p>
<div id="rfc.figure.3"></div>
<div id="fig-option"></div>
<pre>
+------+---+---+---+---+----------------+--------+--------+---------+
| No.  | C | U | N | R | Name           | Format | Length | Default |
+------+---+---+---+---+----------------+--------+--------+---------+
| TBD1 | x |   |   |   | OSCORE         |  (*)   | 0-255  | (none)  |
+------+---+---+---+---+----------------+--------+--------+---------+
    C = Critical,   U = Unsafe,   N = NoCacheKey,   R = Repeatable   
    (*) See below.
</pre>
<p class="figure">Figure 3: The OSCORE Option</p>
<p id="rfc.section.2.p.2">The OSCORE option includes the OSCORE flag bits (<a href="#compression" class="xref">Section 6</a>), the Sender Sequence Number, the Sender ID, and the ID Context when these fields are present (<a href="#context" class="xref">Section 3</a>). The detailed format and length is specified in <a href="#compression" class="xref">Section 6</a>. If the OSCORE flag bits are all zero (0x00) the Option value SHALL be empty (Option Length = 0). An endpoint receiving a CoAP message without payload, that also contains an OSCORE option SHALL treat it as malformed and reject it.</p>
<p id="rfc.section.2.p.3">A successful response to a request with the OSCORE option SHALL contain the OSCORE option. Whether error responses contain the OSCORE option depends on the error type (see <a href="#processing" class="xref">Section 8</a>).</p>
<p id="rfc.section.2.p.4">For CoAP proxy operations, see <a href="#coap-coap-proxy" class="xref">Section 10</a>.</p>
<h1 id="rfc.section.3">
<a href="#rfc.section.3">3.</a> <a href="#context" id="context">The Security Context</a>
</h1>
<p id="rfc.section.3.p.1">OSCORE requires that client and server establish a shared security context used to process the COSE objects. OSCORE uses COSE with an Authenticated Encryption with Additional Data (AEAD, <a href="#RFC5116" class="xref">[RFC5116]</a>) algorithm for protecting message data between a client and a server. In this section, we define the security context and how it is derived in client and server based on a shared secret and a key derivation function.</p>
<h1 id="rfc.section.3.1">
<a href="#rfc.section.3.1">3.1.</a> <a href="#context-definition" id="context-definition">Security Context Definition</a>
</h1>
<p id="rfc.section.3.1.p.1">The security context is the set of information elements necessary to carry out the cryptographic operations in OSCORE. For each endpoint, the security context is composed of a &#8220;Common Context&#8221;, a &#8220;Sender Context&#8221;, and a &#8220;Recipient Context&#8221;.</p>
<p id="rfc.section.3.1.p.2">The endpoints protect messages to send using the Sender Context and verify messages received using the Recipient Context, both contexts being derived from the Common Context and other data. Clients and servers need to be able to retrieve the correct security context to use.</p>
<p id="rfc.section.3.1.p.3">An endpoint uses its Sender ID (SID) to derive its Sender Context, and the other endpoint uses the same ID, now called Recipient ID (RID), to derive its Recipient Context. In communication between two endpoints, the Sender Context of one endpoint matches the Recipient Context of the other endpoint, and vice versa. Thus, the two security contexts identified by the same IDs in the two endpoints are not the same, but they are partly mirrored. Retrieval and use of the security context are shown in <a href="#fig-context" class="xref">Figure 4</a>.</p>
<div id="rfc.figure.4"></div>
<div id="fig-context"></div>
<pre>
          .-----------------------------------------------.
          |                Common Context                 |
          +---------------------.---.---------------------+        
          |    Sender Context   | = |  Recipient Context  |
          +---------------------+   +---------------------+ 
          |  Recipient Context  | = |    Sender Context   |
          '---------------------'   '---------------------'
                   Client                   Server
                      |                       |
Retrieve context for  | OSCORE request:       |
 target resource      |   Token = Token1,     |
Protect request with  |   kid = SID, ...      |
  Sender Context      +----------------------&gt;| Retrieve context with
                      |                       |  RID = kid
                      |                       | Verify request with
                      |                       |  Recipient Context
                      | OSCORE response:      | Protect response with
                      |   Token = Token1, ... |  Sender Context
Retrieve context with |&lt;----------------------+
 Token = Token1       |                       |
Verify request with   |                       |
 Recipient Context    |                       |
</pre>
<p class="figure">Figure 4: Retrieval and Use of the Security Context</p>
<p id="rfc.section.3.1.p.4">The Common Context contains the following parameters:</p>
<p></p>

<ul>
<li>AEAD Algorithm. The COSE AEAD algorithm to use for encryption.</li>
<li>HKDF Algorithm. An HMAC-based key derivation function HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> used to derive Sender Key, Recipient Key, and Common IV.</li>
<li>Master Secret. Variable length, random byte string (see <a href="#master-secret" class="xref">Section 12.3</a>) used to derive AEAD keys and Common IV.</li>
<li>Master Salt. Optional variable length byte string containing the salt used to derive AEAD keys and Common IV.</li>
<li>ID Context. Optional variable length byte string providing additional information to identify the Common Context and to derive AEAD keys and Common IV. The use of ID Context is described in <a href="#context-hint" class="xref">Section 5.1</a>.</li>
<li>Common IV. Byte string derived from Master Secret, Master Salt, and ID Context. Used to generate the AEAD Nonce (see <a href="#nonce" class="xref">Section 5.2</a>). Same length as the nonce of the AEAD Algorithm.</li>
</ul>
<p id="rfc.section.3.1.p.6">The Sender Context contains the following parameters:</p>
<p></p>

<ul>
<li>Sender ID. Byte string used to identify the Sender Context, to derive AEAD keys and Common IV, and to assure unique AEAD nonces. Maximum length is determined by the AEAD Algorithm.</li>
<li>Sender Key. Byte string containing the symmetric AEAD key to protect messages to send. Derived from Common Context and Sender ID. Length is determined by the AEAD Algorithm.</li>
<li>Sender Sequence Number. Non-negative integer used by the sender to enumerate requests and certain responses, e.g. Observe notifications. Used as &#8216;Partial IV&#8217; <a href="#RFC8152" class="xref">[RFC8152]</a> to generate unique AEAD nonces. Maximum value is determined by the AEAD Algorithm. Initialization is described in <a href="#initial-replay" class="xref">Section 3.2.2</a>.</li>
</ul>
<p id="rfc.section.3.1.p.8">The Recipient Context contains the following parameters:</p>
<p></p>

<ul>
<li>Recipient ID. Byte string used to identify the Recipient Context, to derive AEAD keys and Common IV, and to assure unique AEAD nonces. Maximum length is determined by the AEAD Algorithm.</li>
<li>Recipient Key. Byte string containing the symmetric AEAD key to verify messages received. Derived from Common Context and Recipient ID. Length is determined by the AEAD Algorithm.</li>
<li>Replay Window (Server only). The replay window to verify requests received. Replay protection is described in <a href="#replay-protection" class="xref">Section 7.4</a> and <a href="#initial-replay" class="xref">Section 3.2.2</a>.</li>
</ul>
<p id="rfc.section.3.1.p.10">All parameters except Sender Sequence Number and Replay Window are immutable once the security context is established. An endpoint may free up memory by not storing the Common IV, Sender Key, and Recipient Key, deriving them when needed. Alternatively, an endpoint may free up memory by not storing the Master Secret and Master Salt after the other parameters have been derived.</p>
<p id="rfc.section.3.1.p.11">Endpoints MAY operate as both client and server and use the same security context for those roles. Independent of being client or server, the endpoint protects messages to send using its Sender Context, and verifies messages received using its Recipient Context. The endpoints MUST NOT change the Sender/Recipient ID when changing roles. In other words, changing the roles does not change the set of AEAD keys to be used.</p>
<h1 id="rfc.section.3.2">
<a href="#rfc.section.3.2">3.2.</a> <a href="#context-derivation" id="context-derivation">Establishment of Security Context Parameters</a>
</h1>
<p id="rfc.section.3.2.p.1">Each endpoint derives the parameters in the security context from a small set of input parameters. The following input parameters SHALL be pre-established:</p>
<p></p>

<ul>
<li>Master Secret</li>
<li>Sender ID</li>
<li>Recipient ID</li>
</ul>
<p id="rfc.section.3.2.p.3">The following input parameters MAY be pre-established. In case any of these parameters is not pre-established, the default value indicated below is used:</p>
<p></p>

<ul>
<li>AEAD Algorithm  <ul><li>Default is AES-CCM-16-64-128 (COSE algorithm encoding: 10)</li></ul>
</li>
<li>Master Salt  <ul><li>Default is the empty byte string</li></ul>
</li>
<li>HKDF Algorithm  <ul><li>Default is HKDF SHA-256</li></ul>
</li>
<li>Replay Window  <ul><li>Default is DTLS-type replay protection with a window size of 32 <a href="#RFC6347" class="xref">[RFC6347]</a>
</li></ul>
</li>
</ul>
<p id="rfc.section.3.2.p.5">All input parameters need to be known to and agreed on by both endpoints, but the replay window may be different in the two endpoints. The way the input parameters are pre-established, is application specific. Considerations of security context establishment are given in <a href="#sec-context-establish" class="xref">Section 12.2</a> and examples of deploying OSCORE in <a href="#deployment-examples" class="xref">Appendix B</a>.</p>
<h1 id="rfc.section.3.2.1">
<a href="#rfc.section.3.2.1">3.2.1.</a> <a href="#derivation-of-sender-key-recipient-key-and-common-iv" id="derivation-of-sender-key-recipient-key-and-common-iv">Derivation of Sender Key, Recipient Key, and Common IV</a>
</h1>
<p id="rfc.section.3.2.1.p.1">The HKDF MUST be one of the HMAC-based HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> algorithms defined for COSE <a href="#RFC8152" class="xref">[RFC8152]</a>. HKDF SHA-256 is mandatory to implement. The security context parameters Sender Key, Recipient Key, and Common IV SHALL be derived from the input parameters using the HKDF, which consists of the composition of the HKDF-Extract and HKDF-Expand steps <a href="#RFC5869" class="xref">[RFC5869]</a>:</p>
<pre>
   output parameter = HKDF(salt, IKM, info, L) 
</pre>
<p id="rfc.section.3.2.1.p.2">where:</p>
<p></p>

<ul>
<li>salt is the Master Salt as defined above</li>
<li>IKM is the Master Secret as defined above</li>
<li>info is the serialization of a CBOR array consisting of (the notation follows <a href="#cddl-sum" class="xref">Appendix E</a>):</li>
</ul>
<pre>
   info = [
     id : bstr,
     id_context : bstr / nil,
     alg_aead : int / tstr,
     type : tstr,
     L : uint,
   ]
</pre>
<p id="rfc.section.3.2.1.p.4">where:</p>
<p></p>

<ul>
<li>id is the Sender ID or Recipient ID when deriving Sender Key and Recipient Key, respectively, and the empty byte string when deriving the Common IV.</li>
<li>id_context is the ID Context, or nil if ID Context is not provided.</li>
<li>alg_aead is the AEAD Algorithm, encoded as defined in <a href="#RFC8152" class="xref">[RFC8152]</a>.</li>
<li>type is &#8220;Key&#8221; or &#8220;IV&#8221;. The label is an ASCII string, and does not include a trailing NUL byte.</li>
<li>L is the size of the key/nonce for the AEAD algorithm used, in bytes.</li>
</ul>
<p id="rfc.section.3.2.1.p.6">For example, if the algorithm AES-CCM-16-64-128 (see Section 10.2 in <a href="#RFC8152" class="xref">[RFC8152]</a>) is used, the integer value for alg_aead is 10, the value for L is 16 for keys and 13 for the Common IV. Assuming use of the default algorithms HKDF SHA-256 and AES-CCM-16-64-128, the extract phase of HKDF produces a pseudorandom key (PRK) as follows:</p>
<pre>
   PRK = HMAC-SHA-256(Master Salt, Master Secret)
</pre>
<p id="rfc.section.3.2.1.p.7">and as L is smaller than the hash function output size, the expand phase of HKDF consists of a single HMAC invocation, and the Sender Key, Recipient Key, and Common IV are therefore the first 16 or 13 bytes of</p>
<pre>
   output parameter = HMAC-SHA-256(PRK, info || 0x01)
</pre>
<p id="rfc.section.3.2.1.p.8">where different info are used for each derived parameter and where || denotes byte string concatenation.</p>
<p id="rfc.section.3.2.1.p.9">Note that <a href="#RFC5869" class="xref">[RFC5869]</a> specifies that if the salt is not provided, it is set to a string of zeros. For implementation purposes, not providing the salt is the same as setting the salt to the empty byte string. OSCORE sets the salt default value to empty byte string, which is converted to a string of zeroes (see Section 2.2 of <a href="#RFC5869" class="xref">[RFC5869]</a>).</p>
<h1 id="rfc.section.3.2.2">
<a href="#rfc.section.3.2.2">3.2.2.</a> <a href="#initial-replay" id="initial-replay">Initial Sequence Numbers and Replay Window</a>
</h1>
<p id="rfc.section.3.2.2.p.1">The Sender Sequence Number is initialized to 0.</p>
<p id="rfc.section.3.2.2.p.2">The supported types of replay protection and replay window length is application specific and depends on how OSCORE is transported, see <a href="#replay-protection" class="xref">Section 7.4</a>. The default is DTLS-type replay protection with a window size of 32 initiated as described in Section 4.1.2.6 of <a href="#RFC6347" class="xref">[RFC6347]</a>.</p>
<h1 id="rfc.section.3.3">
<a href="#rfc.section.3.3">3.3.</a> <a href="#req-params" id="req-params">Requirements on the Security Context Parameters</a>
</h1>
<p id="rfc.section.3.3.p.1">To ensure unique Sender Keys, the quartet (Master Secret, Master Salt, ID Context, Sender ID) MUST be unique, i.e. the pair (ID Context, Sender ID) SHALL be unique in the set of all security contexts using the same Master Secret and Master Salt. This means that Sender ID SHALL be unique in the set of all security contexts using the same Master Secret, Master Salt, and ID Context; such a requirement guarantees unique (key, nonce) pairs for the AEAD.</p>
<p id="rfc.section.3.3.p.2">Different methods can be used to assign Sender IDs: a protocol that allows the parties to negotiate locally unique identifiers, a trusted third party (e.g., <a href="#I-D.ietf-ace-oauth-authz" class="xref">[I-D.ietf-ace-oauth-authz]</a>), or the identifiers can be assigned out-of-band. The Sender IDs can be very short (note that the empty string is a legitimate value). The maximum length of Sender ID in bytes equals the length of AEAD nonce minus 6, see <a href="#nonce" class="xref">Section 5.2</a>. For AES-CCM-16-64-128 the maximum length of Sender ID is 7 bytes.</p>
<p id="rfc.section.3.3.p.3">To simplify retrieval of the right Recipient Context, the Recipient ID SHOULD be unique in the sets of all Recipient Contexts used by an endpoint. If an endpoint has the same Recipient ID with different Recipient Contexts, i.e. the Recipient Contexts are derived from different Common Contexts, then the endpoint may need to try multiple times before verifying the right security context associated to the Recipient ID.</p>
<p id="rfc.section.3.3.p.4">The ID Context is used to distinguish between security contexts. The methods used for assigning Sender ID can also be used for assigning the ID Context. Additionally, the ID Context can be used to introduce randomness into new Sender and Recipient Contexts (see <a href="#master-secret-multiple" class="xref">Appendix B.2</a>). ID Context can be arbitrarily long.</p>
<h1 id="rfc.section.4">
<a href="#rfc.section.4">4.</a> <a href="#protected-fields" id="protected-fields">Protected Message Fields</a>
</h1>
<p id="rfc.section.4.p.1">OSCORE transforms a CoAP message (which may have been generated from an HTTP message) into an OSCORE message, and vice versa. OSCORE protects as much of the original message as possible while still allowing certain proxy operations (see Sections <a href="#coap-coap-proxy" class="xref">10</a> and <a href="#http-op" class="xref">11</a>). This section defines how OSCORE protects the message fields and transfers them end-to-end between client and server (in any direction).</p>
<p id="rfc.section.4.p.2">The remainder of this section and later sections focus on the behavior in terms of CoAP messages. If HTTP is used for a particular hop in the end-to-end path, then this section applies to the conceptual CoAP message that is mappable to/from the original HTTP message as discussed in <a href="#http-op" class="xref">Section 11</a>.  That is, an HTTP message is conceptually transformed to a CoAP message and then to an OSCORE message, and similarly in the reverse direction.  An actual implementation might translate directly from HTTP to OSCORE without the intervening CoAP representation.</p>
<p id="rfc.section.4.p.3">Protection of Signaling messages (Section 5 of <a href="#RFC8323" class="xref">[RFC8323]</a>) is specified in <a href="#coap-signaling" class="xref">Section 4.3</a>. The other parts of this section target Request/Response messages.</p>
<p id="rfc.section.4.p.4">Message fields of the CoAP message may be protected end-to-end between CoAP client and CoAP server in different ways:</p>
<p></p>

<ul>
<li>Class E: encrypted and integrity protected,</li>
<li>Class I: integrity protected only, or</li>
<li>Class U: unprotected.</li>
</ul>
<p id="rfc.section.4.p.6">The sending endpoint SHALL transfer Class E message fields in the ciphertext of the COSE object in the OSCORE message. The sending endpoint SHALL include Class I message fields in the Additional Authenticated Data (AAD) of the AEAD algorithm, allowing the receiving endpoint to detect if the value has changed in transfer. Class U message fields SHALL NOT be protected in transfer. Class I and Class U message field values are transferred in the header or options part of the OSCORE message, which is visible to proxies.</p>
<p id="rfc.section.4.p.7">Message fields not visible to proxies, i.e., transported in the ciphertext of the COSE object, are called &#8220;Inner&#8221; (Class E). Message fields transferred in the header or options part of the OSCORE message, which is visible to proxies, are called &#8220;Outer&#8221; (Class I or U). There are currently no Class I options defined.</p>
<p id="rfc.section.4.p.8">An OSCORE message may contain both an Inner and an Outer instance of a certain CoAP message field. Inner message fields are intended for the receiving endpoint, whereas Outer message fields are used to enable proxy operations.</p>
<h1 id="rfc.section.4.1">
<a href="#rfc.section.4.1">4.1.</a> <a href="#coap-options" id="coap-options">CoAP Options</a>
</h1>
<p id="rfc.section.4.1.p.1">A summary of how options are protected is shown in <a href="#fig-option-protection" class="xref">Figure 5</a>. Note that some options may have both Inner and Outer message fields which are protected accordingly. Certain options require special processing as is described in <a href="#special-options" class="xref">Section 4.1.3</a>.</p>
<p id="rfc.section.4.1.p.2">Options that are unknown or for which OSCORE processing is not defined SHALL be processed as class E (and no special processing). Specifications of new CoAP options SHOULD define how they are processed with OSCORE. A new COAP option SHOULD be of class E unless it requires proxy processing. If a new CoAP option is of class U, the potential issues with the option being unprotected SHOULD be documented (see <a href="#unprot-fields" class="xref">Appendix D.5</a>).</p>
<h1 id="rfc.section.4.1.1">
<a href="#rfc.section.4.1.1">4.1.1.</a> <a href="#inner-options" id="inner-options">Inner Options</a>
</h1>
<p id="rfc.section.4.1.1.p.1">Inner option message fields (class E) are used to communicate directly with the other endpoint.</p>
<p id="rfc.section.4.1.1.p.2">The sending endpoint SHALL write the Inner option message fields present in the original CoAP message into the plaintext of the COSE object (<a href="#plaintext" class="xref">Section 5.3</a>), and then remove the Inner option message fields from the OSCORE message.</p>
<p id="rfc.section.4.1.1.p.3">The processing of Inner option message fields by the receiving endpoint is specified in Sections <a href="#ver-req" class="xref">8.2</a> and <a href="#ver-res" class="xref">8.4</a>.</p>
<div id="rfc.figure.5"></div>
<div id="fig-option-protection"></div>
<pre>
  +------+-----------------+---+---+
  | No.  | Name            | E | U |
  +------+-----------------+---+---+
  |   1  | If-Match        | x |   |
  |   3  | Uri-Host        |   | x |
  |   4  | ETag            | x |   |
  |   5  | If-None-Match   | x |   |
  |   6  | Observe         | x | x |
  |   7  | Uri-Port        |   | x |
  |   8  | Location-Path   | x |   |
  | TBD1 | OSCORE          |   | x |
  |  11  | Uri-Path        | x |   |
  |  12  | Content-Format  | x |   |
  |  14  | Max-Age         | x | x |
  |  15  | Uri-Query       | x |   |
  |  17  | Accept          | x |   |
  |  20  | Location-Query  | x |   |
  |  23  | Block2          | x | x |
  |  27  | Block1          | x | x |
  |  28  | Size2           | x | x |
  |  35  | Proxy-Uri       |   | x |
  |  39  | Proxy-Scheme    |   | x |
  |  60  | Size1           | x | x |
  | 258  | No-Response     | x | x |
  +------+-----------------+---+---+

E = Encrypt and Integrity Protect (Inner)
U = Unprotected (Outer)
</pre>
<p class="figure">Figure 5: Protection of CoAP Options</p>
<h1 id="rfc.section.4.1.2">
<a href="#rfc.section.4.1.2">4.1.2.</a> <a href="#outer-options" id="outer-options">Outer Options</a>
</h1>
<p id="rfc.section.4.1.2.p.1">Outer option message fields (Class U or I) are used to support proxy operations, see <a href="#supp-proxy-op" class="xref">Appendix D.2</a>.</p>
<p id="rfc.section.4.1.2.p.2">The sending endpoint SHALL include the Outer option message field present in the original message in the options part of the OSCORE message. All Outer option message fields, including the OSCORE option, SHALL be encoded as described in Section 3.1 of <a href="#RFC7252" class="xref">[RFC7252]</a>, where the delta is the difference to the previously included instance of Outer option message field.</p>
<p id="rfc.section.4.1.2.p.3">The processing of Outer options by the receiving endpoint is specified in Sections <a href="#ver-req" class="xref">8.2</a> and <a href="#ver-res" class="xref">8.4</a>.</p>
<p id="rfc.section.4.1.2.p.4">A procedure for integrity-protection-only of Class I option message fields is specified in <a href="#AAD" class="xref">Section 5.4</a>. Specifications that introduce repeatable Class I options MUST specify that proxies MUST NOT change the order of the instances of such an option in the CoAP message.</p>
<p id="rfc.section.4.1.2.p.5">Note: There are currently no Class I option message fields defined.</p>
<h1 id="rfc.section.4.1.3">
<a href="#rfc.section.4.1.3">4.1.3.</a> <a href="#special-options" id="special-options">Special Options</a>
</h1>
<p id="rfc.section.4.1.3.p.1">Some options require special processing as specified in this section.</p>
<h1 id="rfc.section.4.1.3.1">
<a href="#rfc.section.4.1.3.1">4.1.3.1.</a> <a href="#max-age" id="max-age">Max-Age</a>
</h1>
<p id="rfc.section.4.1.3.1.p.1">An Inner Max-Age message field is used to indicate the maximum time a response may be cached by the client (as defined in <a href="#RFC7252" class="xref">[RFC7252]</a>), end-to-end from the server to the client, taking into account that the option is not accessible to proxies. The Inner Max-Age SHALL be processed by OSCORE as a normal Inner option, specified in <a href="#inner-options" class="xref">Section 4.1.1</a>.</p>
<p id="rfc.section.4.1.3.1.p.2">An Outer Max-Age message field is used to avoid unnecessary caching of error responses  caused by OSCORE processing at OSCORE-unaware intermediary nodes. A server MAY set a Class U Max-Age message field with value zero to such error responses, described in Sections <a href="#replay-protection" class="xref">7.4</a>, <a href="#ver-req" class="xref">8.2</a>, and <a href="#ver-res" class="xref">8.4</a>, since these error responses are cacheable, but subsequent OSCORE requests would never create a hit in the intermediary caching it. Setting the Outer Max-Age to zero relieves the intermediary from uselessly caching responses. Successful OSCORE responses do not need to include an Outer Max-Age option since the responses appear to the OSCORE-unaware intermediary as 2.04 (Changed) responses, which are non-cacheable (see <a href="#coap-header" class="xref">Section 4.2</a>).</p>
<p id="rfc.section.4.1.3.1.p.3">The Outer Max-Age message field is processed according to <a href="#outer-options" class="xref">Section 4.1.2</a>.</p>
<h1 id="rfc.section.4.1.3.2">
<a href="#rfc.section.4.1.3.2">4.1.3.2.</a> <a href="#uri-host" id="uri-host">Uri-Host and Uri-Port</a>
</h1>
<p id="rfc.section.4.1.3.2.p.1">When the Uri-Host and Uri-Port are set to their default values (see Section 5.10.1 <a href="#RFC7252" class="xref">[RFC7252]</a>), they are omitted from the message (Section 5.4.4 of <a href="#RFC7252" class="xref">[RFC7252]</a>), which is favorable both for overhead and privacy.</p>
<p id="rfc.section.4.1.3.2.p.2">In order to support forward proxy operations, Proxy-Scheme, Uri-Host, and Uri-Port need to be Class U.  For the use of Proxy-Uri, see <a href="#proxy-uri" class="xref">Section 4.1.3.3</a>.</p>
<p id="rfc.section.4.1.3.2.p.3">Manipulation of unprotected message fields (including Uri-Host, Uri-Port, destination IP/port or request scheme) MUST NOT lead to an OSCORE message becoming verified by an unintended server. Different servers SHALL have different security contexts.</p>
<h1 id="rfc.section.4.1.3.3">
<a href="#rfc.section.4.1.3.3">4.1.3.3.</a> <a href="#proxy-uri" id="proxy-uri">Proxy-Uri</a>
</h1>
<p id="rfc.section.4.1.3.3.p.1">When Proxy-Uri is present, the client SHALL first decompose the Proxy-Uri value of the original CoAP message into the Proxy-Scheme, Uri-Host, Uri-Port, Uri-Path, and Uri-Query options according to Section 6.4 of <a href="#RFC7252" class="xref">[RFC7252]</a>.</p>
<p id="rfc.section.4.1.3.3.p.2">Uri-Path and Uri-Query are class E options and SHALL be protected and processed as Inner options (<a href="#inner-options" class="xref">Section 4.1.1</a>).</p>
<p id="rfc.section.4.1.3.3.p.3">The Proxy-Uri option of the OSCORE message SHALL be set to the composition of Proxy-Scheme, Uri-Host, and Uri-Port options as specified in Section 6.5 of <a href="#RFC7252" class="xref">[RFC7252]</a>, and processed as an Outer option of Class U (<a href="#outer-options" class="xref">Section 4.1.2</a>).</p>
<p id="rfc.section.4.1.3.3.p.4">Note that replacing the Proxy-Uri value with the Proxy-Scheme and Uri-* options works by design for all CoAP URIs (see Section 6 of <a href="#RFC7252" class="xref">[RFC7252]</a>). OSCORE-aware HTTP servers should not use the userinfo component of the HTTP URI (as defined in Section 3.2.1 of <a href="#RFC3986" class="xref">[RFC3986]</a>), so that this type of replacement is possible in the presence of CoAP-to-HTTP proxies (see <a href="#coap2http" class="xref">Section 11.2</a>). In future specifications of cross-protocol proxying behavior using different URI structures, it is expected that the authors will create Uri-* options that allow decomposing the Proxy-Uri, and specifying the OSCORE processing.</p>
<p id="rfc.section.4.1.3.3.p.5">An example of how Proxy-Uri is processed is given here. Assume that the original CoAP message contains:</p>
<p></p>

<ul><li>Proxy-Uri = &#8220;coap://example.com/resource?q=1&#8221;</li></ul>
<p id="rfc.section.4.1.3.3.p.7">During OSCORE processing, Proxy-Uri is split into:</p>
<p></p>

<ul>
<li>Proxy-Scheme = &#8220;coap&#8221;</li>
<li>Uri-Host = &#8220;example.com&#8221;</li>
<li>Uri-Port = &#8220;5683&#8221;</li>
<li>Uri-Path = &#8220;resource&#8221;</li>
<li>Uri-Query = &#8220;q=1&#8221;</li>
</ul>
<p id="rfc.section.4.1.3.3.p.9">Uri-Path and Uri-Query follow the processing defined in <a href="#inner-options" class="xref">Section 4.1.1</a>, and are thus encrypted and transported in the COSE object:</p>
<p></p>

<ul>
<li>Uri-Path = &#8220;resource&#8221;</li>
<li>Uri-Query = &#8220;q=1&#8221;</li>
</ul>
<p id="rfc.section.4.1.3.3.p.11">The remaining options are composed into the Proxy-Uri included in the options part of the OSCORE message, which has value:</p>
<p></p>

<ul><li>Proxy-Uri = &#8220;coap://example.com&#8221;</li></ul>
<p id="rfc.section.4.1.3.3.p.13">See Sections 6.1 and 12.6 of <a href="#RFC7252" class="xref">[RFC7252]</a> for more details.</p>
<h1 id="rfc.section.4.1.3.4">
<a href="#rfc.section.4.1.3.4">4.1.3.4.</a> <a href="#block-options" id="block-options">The Block Options</a>
</h1>
<p id="rfc.section.4.1.3.4.p.1">Block-wise <a href="#RFC7959" class="xref">[RFC7959]</a> is an optional feature. An implementation MAY support <a href="#RFC7252" class="xref">[RFC7252]</a> and the OSCORE option without supporting block-wise transfers. The Block options (Block1, Block2, Size1, Size2), when Inner message fields, provide secure message segmentation such that each segment can be verified. The Block options, when Outer message fields, enables hop-by-hop fragmentation of the OSCORE message. Inner and Outer block processing may have different performance properties depending on the underlying transport. The end-to-end integrity of the message can be verified both in case of Inner and Outer Block-wise transfers provided all blocks are received.</p>
<h1 id="rfc.section.4.1.3.4.1">
<a href="#rfc.section.4.1.3.4.1">4.1.3.4.1.</a> <a href="#inner-block-options" id="inner-block-options">Inner Block Options</a>
</h1>
<p id="rfc.section.4.1.3.4.1.p.1">The sending CoAP endpoint MAY fragment a CoAP message as defined in <a href="#RFC7959" class="xref">[RFC7959]</a> before the message is processed by OSCORE. In this case the Block options SHALL be processed by OSCORE as normal Inner options (<a href="#inner-options" class="xref">Section 4.1.1</a>). The receiving CoAP endpoint SHALL process the OSCORE message before processing Block-wise as defined in <a href="#RFC7959" class="xref">[RFC7959]</a>.</p>
<h1 id="rfc.section.4.1.3.4.2">
<a href="#rfc.section.4.1.3.4.2">4.1.3.4.2.</a> <a href="#outer-block-options" id="outer-block-options">Outer Block Options</a>
</h1>
<p id="rfc.section.4.1.3.4.2.p.1">Proxies MAY fragment an OSCORE message using <a href="#RFC7959" class="xref">[RFC7959]</a>, by introducing Block option message fields that are Outer (<a href="#outer-options" class="xref">Section 4.1.2</a>). Note that the Outer Block options are neither encrypted nor integrity protected. As a consequence, a proxy can maliciously inject block fragments indefinitely, since the receiving endpoint needs to receive the last block (see <a href="#RFC7959" class="xref">[RFC7959]</a>) to be able to compose the OSCORE message and verify its integrity. Therefore, applications supporting OSCORE and <a href="#RFC7959" class="xref">[RFC7959]</a> MUST specify a security policy defining a maximum unfragmented message size (MAX_UNFRAGMENTED_SIZE) considering the maximum size of message which can be handled by the endpoints. Messages exceeding this size SHOULD be fragmented by the sending endpoint using Inner Block options (<a href="#inner-block-options" class="xref">Section 4.1.3.4.1</a>).</p>
<p id="rfc.section.4.1.3.4.2.p.2">An endpoint receiving an OSCORE message with an Outer Block option SHALL first process this option according to <a href="#RFC7959" class="xref">[RFC7959]</a>, until all blocks of the OSCORE message have been received, or the cumulated message size of the blocks exceeds MAX_UNFRAGMENTED_SIZE.  In the former case, the processing of the OSCORE message continues as defined in this document. In the latter case the message SHALL be discarded.</p>
<p id="rfc.section.4.1.3.4.2.p.3">Because of encryption of Uri-Path and Uri-Query, messages to the same server may, from the point of view of a proxy, look like they also target the same resource. A proxy SHOULD mitigate a potential mix-up of blocks from concurrent requests to the same server, for example using the Request-Tag processing specified in Section 3.3.2 of <a href="#I-D.ietf-core-echo-request-tag" class="xref">[I-D.ietf-core-echo-request-tag]</a>.</p>
<h1 id="rfc.section.4.1.3.5">
<a href="#rfc.section.4.1.3.5">4.1.3.5.</a> <a href="#observe" id="observe">Observe</a>
</h1>
<p id="rfc.section.4.1.3.5.p.1">Observe <a href="#RFC7641" class="xref">[RFC7641]</a> is an optional feature. An implementation MAY support <a href="#RFC7252" class="xref">[RFC7252]</a> and the OSCORE option without supporting <a href="#RFC7641" class="xref">[RFC7641]</a>, in which case the Observe related processing can be omitted.</p>
<p id="rfc.section.4.1.3.5.p.2">The support for Observe <a href="#RFC7641" class="xref">[RFC7641]</a> with OSCORE targets the requirements on forwarding of Section 2.2.1 of <a href="#I-D.hartke-core-e2e-security-reqs" class="xref">[I-D.hartke-core-e2e-security-reqs]</a>, i.e. that observations go through intermediary nodes, as illustrated in Figure 8 of <a href="#RFC7641" class="xref">[RFC7641]</a>.</p>
<p id="rfc.section.4.1.3.5.p.3">Inner Observe SHALL be used to protect the value of the Observe option between the endpoints. Outer Observe SHALL be used to support forwarding by intermediary nodes.</p>
<p id="rfc.section.4.1.3.5.p.4">The server SHALL include a new Partial IV (see <a href="#cose-object" class="xref">Section 5</a>) in responses (with or without the Observe option) to Observe registrations, except for the first response where Partial IV MAY be omitted.</p>
<p id="rfc.section.4.1.3.5.p.5">For cancellations, Section 3.6 of <a href="#RFC7641" class="xref">[RFC7641]</a> specifies that all options MUST be identical to those in the registration request except for Observe and the set of ETag Options. For OSCORE messages, this matching is to be done to the options in the decrypted message.</p>
<p><a href="#RFC7252" class="xref">[RFC7252]</a> does not specify how the server should act upon receiving the same Token in different requests. When using OSCORE, the server SHOULD NOT remove an active observation just because it receives a request with the same Token.</p>
<p id="rfc.section.4.1.3.5.p.7">Since POST with Observe is not defined, for messages with Observe, the Outer Code MUST be set to 0.05 (FETCH) for requests and to 2.05 (Content) for responses (see <a href="#coap-header" class="xref">Section 4.2</a>).</p>
<h1 id="rfc.section.4.1.3.5.1">
<a href="#rfc.section.4.1.3.5.1">4.1.3.5.1.</a> <a href="#observe-registration" id="observe-registration">Registrations and Cancellations</a>
</h1>
<p id="rfc.section.4.1.3.5.1.p.1">The Inner and Outer Observe in the request MUST contain the Observe value of the original CoAP request; 0 (registration) or 1 (cancellation).</p>
<p id="rfc.section.4.1.3.5.1.p.2">Every time a client issues a new Observe request, a new Partial IV MUST be used (see <a href="#cose-object" class="xref">Section 5</a>), and so the payload and OSCORE option are changed. The server uses the Partial IV of the new request as the &#8216;request_piv&#8217; of all associated notifications (see <a href="#AAD" class="xref">Section 5.4</a>).</p>
<p id="rfc.section.4.1.3.5.1.p.3">Intermediaries are not assumed to have access to the OSCORE security context used by the endpoints, and thus cannot make requests or transform responses with the OSCORE option which verify at the receiving endpoint as coming from the other endpoint. This has the following consequences and limitations for Observe operations.</p>
<p></p>

<ul>
<li>An intermediary node removing the Outer Observe 0 does not change the registration request to a request without Observe (see Section 2 of <a href="#RFC7641" class="xref">[RFC7641]</a>). Instead other means for cancellation may be used as described in Section 3.6 of <a href="#RFC7641" class="xref">[RFC7641]</a>.</li>
<li>An intermediary node is not able to transform a normal response into an OSCORE protected Observe notification (see figure 7 of <a href="#RFC7641" class="xref">[RFC7641]</a>) which verifies as coming from the server.</li>
<li>An intermediary node is not able to initiate an OSCORE protected Observe registration (Observe with value 0) which verifies as coming from the client. An OSCORE-aware intermediary SHALL NOT initiate registrations of observations (see <a href="#coap-coap-proxy" class="xref">Section 10</a>). If an OSCORE-unaware proxy re-sends an old registration message from a client this will trigger the replay protection mechanism in the server. To prevent this from resulting in the OSCORE-unaware proxy to cancel of the registration, a server MAY respond to a replayed registration request with a replay of a cached notification. Alternatively, the server MAY send a new notification.</li>
<li>An intermediary node is not able to initiate an OSCORE protected Observe cancellation (Observe with value 1) which verifies as coming from the client. An application MAY decide to allow intermediaries to cancel Observe registrations, e.g. to send Observe with value 1 (see Section 3.6 of <a href="#RFC7641" class="xref">[RFC7641]</a>), but that can also be done with other methods, e.g. reusing the Token in a different request or sending a RST message. This is out of scope for this specification.</li>
</ul>
<h1 id="rfc.section.4.1.3.5.2">
<a href="#rfc.section.4.1.3.5.2">4.1.3.5.2.</a> <a href="#notifications" id="notifications">Notifications</a>
</h1>
<p id="rfc.section.4.1.3.5.2.p.1">If the server accepts an Observe registration, a Partial IV MUST be included in all notifications (both successful and error), except for the first one where Partial IV MAY be omitted. To protect against replay, the client SHALL maintain a Notification Number for each Observation it registers. The Notification Number is a non-negative integer containing the largest Partial IV of the received notifications for the associated Observe registration. Further details of replay protection of notifications are specified in <a href="#replay-notifications" class="xref">Section 7.4.1</a>.</p>
<p id="rfc.section.4.1.3.5.2.p.2">For notifications, the Inner Observe value MUST be empty (see Section 3.2 of <a href="#RFC7252" class="xref">[RFC7252]</a>). The Outer Observe in a notification is needed for intermediary nodes to allow multiple responses to one request, and may be set to the value of Observe in the original CoAP message. The client performs ordering of notifications and replay protection by comparing their Partial IVs and SHALL ignore the outer Observe value.</p>
<p id="rfc.section.4.1.3.5.2.p.3">If the client receives a response to an Observe request without an Inner Observe option, then it verifies the response as a non-Observe response, as specified in <a href="#ver-res" class="xref">Section 8.4</a>. If the client receives a response to a non-Observe request with an Inner Observe option, then it stops processing the message, as specified in <a href="#ver-res" class="xref">Section 8.4</a>.</p>
<p id="rfc.section.4.1.3.5.2.p.4">A client MUST consider the notification with the highest Partial IV as the freshest, regardless of the order of arrival. In order to support existing Observe implementations the OSCORE client implementation MAY set the Observe value to the three least significant bytes of the Partial IV. Implementations need to make sure that the notification without Partial IV is considered the oldest.</p>
<h1 id="rfc.section.4.1.3.6">
<a href="#rfc.section.4.1.3.6">4.1.3.6.</a> <a href="#no-resp" id="no-resp">No-Response</a>
</h1>
<p id="rfc.section.4.1.3.6.p.1">No-Response <a href="#RFC7967" class="xref">[RFC7967]</a> is an optional feature used by the client to communicate its disinterest in certain classes of responses to a particular request. An implementation MAY support <a href="#RFC7252" class="xref">[RFC7252]</a> and the OSCORE option without supporting <a href="#RFC7967" class="xref">[RFC7967]</a>.</p>
<p id="rfc.section.4.1.3.6.p.2">If used, No-Response MUST be Inner. The Inner No-Response SHALL be processed by OSCORE as specified in <a href="#inner-options" class="xref">Section 4.1.1</a>. The Outer option SHOULD NOT be present. The server SHALL ignore the Outer No-Response option. The client MAY set the Outer No-Response value to 26 (&#8216;suppress all known codes&#8217;) if the Inner value is set to 26. The client MUST be prepared to receive and discard 5.04 (Gateway Timeout) error messages from intermediaries potentially resulting from destination time out due to no response.</p>
<h1 id="rfc.section.4.1.3.7">
<a href="#rfc.section.4.1.3.7">4.1.3.7.</a> <a href="#oscore" id="oscore">OSCORE</a>
</h1>
<p id="rfc.section.4.1.3.7.p.1">The OSCORE option is only defined to be present in OSCORE messages, as an indication that OSCORE processing have been performed. The content in the OSCORE option is neither encrypted nor integrity protected as a whole but some part of the content of this option is protected (see <a href="#AAD" class="xref">Section 5.4</a>). Nested use of OSCORE is not supported: If OSCORE processing detects an OSCORE option in the original CoAP message, then processing SHALL be stopped.</p>
<div id="rfc.figure.6"></div>
<div id="fig-fields-protection"></div>
<pre>
      +------------------+---+---+
      | Field            | E | U |
      +------------------+---+---+
      | Version (UDP)    |   | x |
      | Type (UDP)       |   | x |
      | Length (TCP)     |   | x |
      | Token Length     |   | x |
      | Code             | x |   |
      | Message ID (UDP) |   | x |
      | Token            |   | x |
      | Payload          | x |   |
      +------------------+---+---+

E = Encrypt and Integrity Protect (Inner)
U = Unprotected (Outer)
</pre>
<p class="figure">Figure 6: Protection of CoAP Header Fields and Payload</p>
<h1 id="rfc.section.4.2">
<a href="#rfc.section.4.2">4.2.</a> <a href="#coap-header" id="coap-header">CoAP Header Fields and Payload</a>
</h1>
<p id="rfc.section.4.2.p.1">A summary of how the CoAP header fields and payload are protected is shown in <a href="#fig-fields-protection" class="xref">Figure 6</a>, including fields specific to CoAP over UDP and CoAP over TCP (marked accordingly in the table).</p>
<p id="rfc.section.4.2.p.2">Most CoAP Header fields (i.e. the message fields in the fixed 4-byte header) are required to be read and/or changed by CoAP proxies and thus cannot in general be protected end-to-end between the endpoints. As mentioned in <a href="#intro" class="xref">Section 1</a>, OSCORE protects the CoAP Request/Response Layer only, and not the Messaging Layer (Section 2 of <a href="#RFC7252" class="xref">[RFC7252]</a>), so fields such as Type and Message ID are not protected with OSCORE.</p>
<p id="rfc.section.4.2.p.3">The CoAP Header field Code is protected by OSCORE. Code SHALL be encrypted and integrity protected (Class E) to prevent an intermediary from eavesdropping on or manipulating the Code (e.g., changing from GET to DELETE).</p>
<p id="rfc.section.4.2.p.4">The sending endpoint SHALL write the Code of the original CoAP message into the plaintext of the COSE object (see <a href="#plaintext" class="xref">Section 5.3</a>). After that, the sending endpoint writes an Outer Code to the OSCORE message. With one exception (see <a href="#observe" class="xref">Section 4.1.3.5</a>) the Outer Code SHALL be set to 0.02 (POST) for requests and to 2.04 (Changed) for responses. The receiving endpoint SHALL discard the Outer Code in the OSCORE message and write the Code of the COSE object plaintext (<a href="#plaintext" class="xref">Section 5.3</a>) into the decrypted CoAP message.</p>
<p id="rfc.section.4.2.p.5">The other currently defined CoAP Header fields are Unprotected (Class U). The sending endpoint SHALL write all other header fields of the original message into the header of the OSCORE message. The receiving endpoint SHALL write the header fields from the received OSCORE message into the header of the decrypted CoAP message.</p>
<p id="rfc.section.4.2.p.6">The CoAP Payload, if present in the original CoAP message, SHALL be encrypted and integrity protected and is thus an Inner message field. The sending endpoint writes the payload of the original CoAP message into the plaintext (<a href="#plaintext" class="xref">Section 5.3</a>) input to the COSE object. The receiving endpoint verifies and decrypts the COSE object, and recreates the payload of the original CoAP message.</p>
<h1 id="rfc.section.4.3">
<a href="#rfc.section.4.3">4.3.</a> <a href="#coap-signaling" id="coap-signaling">Signaling Messages</a>
</h1>
<p id="rfc.section.4.3.p.1">Signaling messages (CoAP Code 7.00-7.31) were introduced to exchange information related to an underlying transport connection in the specific case of CoAP over reliable transports <a href="#RFC8323" class="xref">[RFC8323]</a>.</p>
<p id="rfc.section.4.3.p.2">OSCORE MAY be used to protect Signaling if the endpoints for OSCORE coincide with the endpoints for the signaling message. If OSCORE is used to protect Signaling then:</p>
<p></p>

<ul>
<li>To comply with <a href="#RFC8323" class="xref">[RFC8323]</a>, an initial empty CSM message SHALL be sent. The subsequent signaling message SHALL be protected.</li>
<li>Signaling messages SHALL be protected as CoAP Request messages, except in the case the Signaling message is a response to a previous Signaling message, in which case it SHALL be protected as a CoAP Response message.  For example, 7.02 (Ping) is protected as a CoAP Request and 7.03 (Pong) as a CoAP response.</li>
<li>The Outer Code for Signaling messages SHALL be set to 0.02 (POST), unless it is a response to a previous Signaling message, in which case it SHALL be set to 2.04 (Changed).</li>
<li>All Signaling options, except the OSCORE option, SHALL be Inner (Class E).</li>
</ul>
<p id="rfc.section.4.3.p.4">NOTE: Option numbers for Signaling messages are specific to the CoAP Code (see Section 5.2 of <a href="#RFC8323" class="xref">[RFC8323]</a>).</p>
<p id="rfc.section.4.3.p.5">If OSCORE is not used to protect Signaling, Signaling messages SHALL be unaltered by OSCORE.</p>
<h1 id="rfc.section.5">
<a href="#rfc.section.5">5.</a> <a href="#cose-object" id="cose-object">The COSE Object</a>
</h1>
<p id="rfc.section.5.p.1">This section defines how to use COSE <a href="#RFC8152" class="xref">[RFC8152]</a> to wrap and protect data in the original message. OSCORE uses the untagged COSE_Encrypt0 structure with an Authenticated Encryption with Additional Data (AEAD) algorithm. The AEAD key lengths, AEAD nonce length, and maximum Sender Sequence Number are algorithm dependent.</p>
<p id="rfc.section.5.p.2">The AEAD algorithm AES-CCM-16-64-128 defined in Section 10.2 of <a href="#RFC8152" class="xref">[RFC8152]</a> is mandatory to implement. For AES-CCM-16-64-128 the length of Sender Key and Recipient Key is 128 bits, the length of AEAD nonce and Common IV is 13 bytes. The maximum Sender Sequence Number is specified in <a href="#sec-considerations" class="xref">Section 12</a>.</p>
<p id="rfc.section.5.p.3">As specified in <a href="#RFC5116" class="xref">[RFC5116]</a>, plaintext denotes the data that is to be encrypted and integrity protected, and Additional Authenticated Data (AAD) denotes the data that is to be integrity protected only.</p>
<p id="rfc.section.5.p.4">The COSE Object SHALL be a COSE_Encrypt0 object with fields defined as follows</p>
<p></p>

<ul>
<li>The &#8216;protected&#8217; field is empty.</li>
<li>The &#8216;unprotected&#8217; field includes:  <ul>
<li>The &#8216;Partial IV&#8217; parameter. The value is set to the Sender Sequence Number. All leading bytes of value zero SHALL be removed when encoding the Partial IV, except in the case of Partial IV of value 0 which is encoded to the byte string 0x00. This parameter SHALL be present in requests. The Partial IV SHALL be present in responses to Observe registrations (see <a href="#observe-registration" class="xref">Section 4.1.3.5.1</a>), otherwise the Partial IV will not typically be present in responses (for one exception, see <a href="#reboot-replay" class="xref">Appendix B.1.2</a>).</li>
<li>The &#8216;kid&#8217; parameter. The value is set to the Sender ID. This parameter SHALL be present in requests and will not typically be present in responses. An example where the Sender ID is included in a response is the extension of OSCORE to group communication <a href="#I-D.ietf-core-oscore-groupcomm" class="xref">[I-D.ietf-core-oscore-groupcomm]</a>.</li>
<li>Optionally, a &#8216;kid context&#8217; parameter (see <a href="#context-hint" class="xref">Section 5.1</a>). This parameter MAY be present in requests, and if so, MUST contain an ID Context (see <a href="#context-definition" class="xref">Section 3.1</a>). This parameter SHOULD NOT be present in responses: an example of how &#8216;kid context&#8217; can be used in responses is given in <a href="#master-secret-multiple" class="xref">Appendix B.2</a>. If &#8216;kid context&#8217; is present in the request, then the server SHALL use a security context with that ID Context when verifying the request.</li>
</ul>
</li>
<li>The &#8216;ciphertext&#8217; field is computed from the secret key (Sender Key or Recipient Key), AEAD nonce (see <a href="#nonce" class="xref">Section 5.2</a>), plaintext (see <a href="#plaintext" class="xref">Section 5.3</a>), and the Additional Authenticated Data (AAD) (see <a href="#AAD" class="xref">Section 5.4</a>) following Section 5.2 of <a href="#RFC8152" class="xref">[RFC8152]</a>.</li>
</ul>
<p id="rfc.section.5.p.6">The encryption process is described in Section 5.3 of <a href="#RFC8152" class="xref">[RFC8152]</a>.</p>
<h1 id="rfc.section.5.1">
<a href="#rfc.section.5.1">5.1.</a> <a href="#context-hint" id="context-hint">ID Context and &#8216;kid context&#8217;</a>
</h1>
<p id="rfc.section.5.1.p.1">For certain use cases, e.g. deployments where the same Sender ID is used with multiple contexts, it is possible (and sometimes necessary, see <a href="#req-params" class="xref">Section 3.3</a>) for the client to use an ID Context to distinguish the security contexts (see <a href="#context-definition" class="xref">Section 3.1</a>). For example:</p>
<p></p>

<ul>
<li>If the client has a unique identifier in some namespace then that identifier can be used as ID Context.</li>
<li>The ID Context may be used to add randomness into new Sender and Recipient Contexts, see <a href="#master-secret-multiple" class="xref">Appendix B.2</a>.</li>
<li>In case of group communication <a href="#I-D.ietf-core-oscore-groupcomm" class="xref">[I-D.ietf-core-oscore-groupcomm]</a>, a group identifier is used as ID Context to enable different security contexts for a server belonging to multiple groups.</li>
</ul>
<p id="rfc.section.5.1.p.3">The Sender ID and ID Context are used to establish the necessary input parameters and in the derivation of the security context (see <a href="#context-derivation" class="xref">Section 3.2</a>).</p>
<p id="rfc.section.5.1.p.4">Whereas the &#8216;kid&#8217; parameter is used to transport the Sender ID, the new COSE header parameter &#8216;kid context&#8217; is used to transport the ID Context in requests, see <a href="#tab-1" class="xref">Figure 7</a>.</p>
<div id="rfc.figure.7"></div>
<div id="tab-1"></div>
<pre>
+----------+--------+------------+----------------+-----------------+
|   name   |  label | value type | value registry |   description   |
+----------+--------+------------+----------------+-----------------+
|   kid    |  TBD2  | bstr       |                | Identifies the  |
| context  |        |            |                | context for kid |
+----------+--------+------------+----------------+-----------------+
</pre>
<p class="figure">Figure 7: Common Header Parameter 'kid context' for the COSE object</p>
<p id="rfc.section.5.1.p.5">If ID Context is non-empty and the client sends a request without &#8216;kid context&#8217; which results in an error indicating that the server could not find the security context, then the client could include the ID Context in the &#8216;kid context&#8217; when making another request. Note that since the error is unprotected it may have been spoofed and the real response blocked by an on-path attacker.</p>
<h1 id="rfc.section.5.2">
<a href="#rfc.section.5.2">5.2.</a> <a href="#nonce" id="nonce">AEAD Nonce</a>
</h1>
<p id="rfc.section.5.2.p.1">The high level design of the AEAD nonce follows Section 4.4 of <a href="#I-D.mcgrew-iv-gen" class="xref">[I-D.mcgrew-iv-gen]</a>, here follows the detailed construction (see Figure 8):</p>
<p></p>

<ol>
<li>left-pad the Partial IV (PIV) with zeroes to exactly 5 bytes,</li>
<li>left-pad the Sender ID of the endpoint that generated the Partial IV (ID_PIV) with zeroes to exactly nonce length minus 6 bytes,</li>
<li>concatenate the size of the ID_PIV (a single byte S) with the padded ID_PIV and the padded PIV,</li>
<li>and then XOR with the Common IV.</li>
</ol>
<p id="rfc.section.5.2.p.3">Note that in this specification only AEAD algorithms that use nonces equal or greater than 7 bytes are supported. The nonce construction with S, ID_PIV, and PIV together with endpoint unique IDs and encryption keys makes it easy to verify that the nonces used with a specific key will be unique, see <a href="#kn-uniqueness" class="xref">Appendix D.4</a>.</p>
<p id="rfc.section.5.2.p.4">If the Partial IV is not present in a response, the nonce from the request is used. For responses that are not notifications (i.e. when there is a single response to a request), the request and the response should typically use the same nonce to reduce message overhead. Both alternatives provide all the required security properties, see <a href="#replay-protection" class="xref">Section 7.4</a> and <a href="#kn-uniqueness" class="xref">Appendix D.4</a>. The only non-Observe scenario where a Partial IV must be included in a response is when the server is unable to perform replay protection, see <a href="#reboot-replay" class="xref">Appendix B.1.2</a>. For processing instructions see <a href="#processing" class="xref">Section 8</a>.</p>
<div id="rfc.figure.8"></div>
<div id="fig-nonce"></div>
<pre>
     &lt;- nonce length minus 6 B -&gt; &lt;-- 5 bytes --&gt;
+---+-------------------+--------+---------+-----+
| S |      padding      | ID_PIV | padding | PIV |----+ 
+---+-------------------+--------+---------+-----+    | 
                                                      |
 &lt;---------------- nonce length ----------------&gt;     |               
+------------------------------------------------+    | 
|                   Common IV                    |-&gt;(XOR)
+------------------------------------------------+    | 
                                                      | 
 &lt;---------------- nonce length ----------------&gt;     |               
+------------------------------------------------+    | 
|                     Nonce                      |&lt;---+ 
+------------------------------------------------+     
</pre>
<p class="figure">Figure 8: AEAD Nonce Formation</p>
<h1 id="rfc.section.5.3">
<a href="#rfc.section.5.3">5.3.</a> <a href="#plaintext" id="plaintext">Plaintext</a>
</h1>
<p id="rfc.section.5.3.p.1">The plaintext is formatted as a CoAP message without Header (see <a href="#fig-plaintext" class="xref">Figure 9</a>) consisting of:</p>
<p></p>

<ul>
<li>the Code of the original CoAP message as defined in Section 3 of <a href="#RFC7252" class="xref">[RFC7252]</a>; and</li>
<li>all Inner option message fields (see <a href="#inner-options" class="xref">Section 4.1.1</a>) present in the original CoAP message (see <a href="#coap-options" class="xref">Section 4.1</a>). The options are encoded as described in Section 3.1 of <a href="#RFC7252" class="xref">[RFC7252]</a>, where the delta is the difference to the previously included instance of Class E option; and</li>
<li>the Payload of original CoAP message, if present, and in that case prefixed by the one-byte Payload Marker (0xff).</li>
</ul>
<p id="rfc.section.5.3.p.3">NOTE: The plaintext contains all CoAP data that needs to be encrypted end-to-end between the endpoints.</p>
<div id="rfc.figure.9"></div>
<div id="fig-plaintext"></div>
<pre>
 0                   1                   2                   3   
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|     Code      |    Class E options (if any) ...                
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...                        
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 (only if there 
   is payload)
</pre>
<p class="figure">Figure 9: Plaintext</p>
<h1 id="rfc.section.5.4">
<a href="#rfc.section.5.4">5.4.</a> <a href="#AAD" id="AAD">Additional Authenticated Data</a>
</h1>
<p id="rfc.section.5.4.p.1">The external_aad SHALL be a CBOR array wrapped in a bstr object as defined below:</p>
<pre>
external_aad = bstr .cbor aad_array

aad_array = [
  oscore_version : uint,
  algorithms : [ alg_aead : int / tstr ],
  request_kid : bstr,
  request_piv : bstr,
  options : bstr,
]
</pre>
<p id="rfc.section.5.4.p.2">where:</p>
<p></p>

<ul>
<li>oscore_version: contains the OSCORE version number. Implementations of this specification MUST set this field to 1. Other values are reserved for future versions.</li>
<li>algorithms: contains (for extensibility) an array of algorithms, according to this specification only containing alg_aead.</li>
<li>alg_aead: contains the AEAD Algorithm from the security context used for the exchange (see <a href="#context-definition" class="xref">Section 3.1</a>).</li>
<li>request_kid: contains the value of the &#8216;kid&#8217; in the COSE object of the request (see <a href="#cose-object" class="xref">Section 5</a>).</li>
<li>request_piv: contains the value of the &#8216;Partial IV&#8217; in the COSE object of the request (see <a href="#cose-object" class="xref">Section 5</a>).</li>
<li>options: contains the Class I options (see <a href="#outer-options" class="xref">Section 4.1.2</a>)&#160;present in the original CoAP message encoded as described in Section 3.1 of <a href="#RFC7252" class="xref">[RFC7252]</a>, where the delta is the difference to the previously included instance of class I option.</li>
</ul>
<p id="rfc.section.5.4.p.4">The oscore_version and algorithms parameters are established out-of-band and are thus never transported in OSCORE, but the external_aad allows to verify that they are the same in both endpoints.</p>
<p id="rfc.section.5.4.p.5">NOTE: The format of the external_aad is for simplicity the same for requests and responses, although some parameters, e.g. request_kid, need not be integrity protected in all requests.</p>
<p id="rfc.section.5.4.p.6">The Additional Authenticated Data (AAD) is composed from the external_aad as described in Section 5.3 of <a href="#RFC8152" class="xref">[RFC8152]</a>:</p>
<pre>
   AAD = Enc_structure = [ "Encrypt0", h'', external_aad ]
</pre>
<p id="rfc.section.5.4.p.7">The following is an example of AAD constructed using AEAD Algorithm = AES-CCM-16-64-128 (10), request_kid = 0x00, request_piv = 0x25 and no Class I options:</p>
<p></p>

<ul>
<li>oscore_version: 0x01 (1 byte)</li>
<li>algorithms: 0x810a (2 bytes)</li>
<li>request_kid: 0x00 (1 byte)</li>
<li>request_piv: 0x25 (1 byte)</li>
<li>options: 0x (0 bytes)</li>
<li>aad_array: 0x8501810a4100412540 (9 bytes)</li>
<li>external_aad: 0x498501810a4100412540 (10 bytes)</li>
<li>AAD: 0x8368456e63727970743040498501810a4100412540 (21 bytes)</li>
</ul>
<p id="rfc.section.5.4.p.9">Note that the AAD consists of a fixed string of 11 bytes concatenated with the external_aad.</p>
<h1 id="rfc.section.6">
<a href="#rfc.section.6">6.</a> <a href="#compression" id="compression">OSCORE Header Compression</a>
</h1>
<p id="rfc.section.6.p.1">The Concise Binary Object Representation (CBOR) <a href="#RFC7049" class="xref">[RFC7049]</a> combines very small message sizes with extensibility. The CBOR Object Signing and Encryption (COSE) <a href="#RFC8152" class="xref">[RFC8152]</a> uses CBOR to create compact encoding of signed and encrypted data. COSE is however constructed to support a large number of different stateless use cases, and is not fully optimized for use as a stateful security protocol, leading to a larger than necessary message expansion. In this section, we define a stateless header compression mechanism, simply removing redundant information from the COSE objects, which significantly reduces the per-packet overhead. The result of applying this mechanism to a COSE object is called the &#8220;compressed COSE object&#8221;.</p>
<p id="rfc.section.6.p.2">The COSE_Encrypt0 object used in OSCORE is transported in the OSCORE option and in the Payload. The Payload contains the Ciphertext of the COSE object. The headers of the COSE object are compactly encoded as described in the next section.</p>
<h1 id="rfc.section.6.1">
<a href="#rfc.section.6.1">6.1.</a> <a href="#obj-sec-value" id="obj-sec-value">Encoding of the OSCORE Option Value</a>
</h1>
<p id="rfc.section.6.1.p.1">The value of the OSCORE option SHALL contain the OSCORE flag bits, the Partial IV parameter, the &#8216;kid context&#8217; parameter (length and value), and the &#8216;kid&#8217; parameter as follows:</p>
<div id="rfc.figure.10"></div>
<div id="fig-option-value"></div>
<pre>
 0 1 2 3 4 5 6 7 &lt;------------- n bytes --------------&gt;
+-+-+-+-+-+-+-+-+--------------------------------------
|0 0 0|h|k|  n  |       Partial IV (if any) ...    
+-+-+-+-+-+-+-+-+--------------------------------------

 &lt;- 1 byte -&gt; &lt;----- s bytes ------&gt;                    
+------------+----------------------+------------------+
| s (if any) | kid context (if any) | kid (if any) ... |
+------------+----------------------+------------------+
</pre>
<p class="figure">Figure 10: The OSCORE Option Value</p>
<p></p>

<ul><li>The first byte, containing the OSCORE flag bits, encodes the following set of bits and the length of the Partial IV parameter:  <ul>
<li>The three least significant bits encode the Partial IV length n. If n = 0 then the Partial IV is not present in the compressed COSE object. The values n = 6 and n = 7 are reserved.</li>
<li>The fourth least significant bit is the &#8216;kid&#8217; flag, k: it is set to 1 if the kid is present in the compressed COSE object.</li>
<li>The fifth least significant bit is the &#8216;kid context&#8217; flag, h: it is set to 1 if the compressed COSE object contains a &#8216;kid context (see <a href="#context-hint" class="xref">Section 5.1</a>).</li>
<li>The sixth to eighth least significant bits are reserved for future use. These bits SHALL be set to zero when not in use. According to this specification, if any of these bits are set to 1 the message is considered to be malformed and decompression fails as specified in item 2 of <a href="#ver-req" class="xref">Section 8.2</a>.</li>
</ul>
</li></ul>
<p id="rfc.section.6.1.p.3">The flag bits are registered in the OSCORE Flag Bits registry specified in <a href="#oscore-flag-bits" class="xref">Section 13.7</a>.</p>
<p></p>

<ul>
<li>The following n bytes encode the value of the Partial IV, if the Partial IV is present (n &gt; 0).</li>
<li>The following 1 byte encode the length of the &#8216;kid context&#8217; (<a href="#context-hint" class="xref">Section 5.1</a>) s, if the &#8216;kid context&#8217; flag is set (h = 1).</li>
<li>The following s bytes encode the &#8216;kid context&#8217;, if the &#8216;kid context&#8217; flag is set (h = 1).</li>
<li>The remaining bytes encode the value of the &#8216;kid&#8217;, if the &#8216;kid&#8217; is present (k = 1).</li>
</ul>
<p id="rfc.section.6.1.p.5">Note that the &#8216;kid&#8217; MUST be the last field of the OSCORE option value, even in case reserved bits are used and additional fields are added to it.</p>
<p id="rfc.section.6.1.p.6">The length of the OSCORE option thus depends on the presence and length of Partial IV, &#8216;kid context&#8217;, &#8216;kid&#8217;, as specified in this section, and on the presence and length of the other parameters, as defined in the separate documents.</p>
<h1 id="rfc.section.6.2">
<a href="#rfc.section.6.2">6.2.</a> <a href="#oscore-payl" id="oscore-payl">Encoding of the OSCORE Payload</a>
</h1>
<p id="rfc.section.6.2.p.1">The payload of the OSCORE message SHALL encode the ciphertext of the COSE object.</p>
<h1 id="rfc.section.6.3">
<a href="#rfc.section.6.3">6.3.</a> <a href="#examples-of-compressed-cose-objects" id="examples-of-compressed-cose-objects">Examples of Compressed COSE Objects</a>
</h1>
<p id="rfc.section.6.3.p.1">This section covers a list of OSCORE Header Compression examples for requests and responses. The examples assume the COSE_Encrypt0 object is set (which means the CoAP message and cryptographic material is known). Note that the full CoAP unprotected message, as well as the full security context, is not reported in the examples, but only the input necessary to the compression mechanism, i.e. the COSE_Encrypt0 object. The output is the compressed COSE object as defined in <a href="#compression" class="xref">Section 6</a>, divided into two parts, since the object is transported in two CoAP fields: OSCORE option and payload.</p>
<p></p>

<dl>
<dt>1.   </dt>
<dd>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = 0x25, and Partial IV = 0x05</dd>
</dl>
<pre>
    Before compression (24 bytes):

      [
        h'',
        { 4:h'25', 6:h'05' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
</pre>
<pre>
    After compression (17 bytes):

      Flag byte: 0b00001001 = 0x09 (1 byte)

      Option Value: 0x090525 (3 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
</pre>
<p></p>

<dl>
<dt>2.   </dt>
<dd>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, and Partial IV = 0x00</dd>
</dl>
<pre>
    Before compression (23 bytes):

      [
        h'',
        { 4:h'', 6:h'00' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
</pre>
<pre>
    After compression (16 bytes):

      Flag byte: 0b00001001 = 0x09 (1 byte)

      Option Value: 0x0900 (2 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
</pre>
<p></p>

<dl>
<dt>3.   </dt>
<dd>Request with ciphertext = 0xaea0155667924dff8a24e4cb35b9, kid = empty string, Partial IV = 0x05, and kid context = 0x44616c656b</dd>
</dl>
<pre>
    Before compression (30 bytes):

      [
        h'',
        { 4:h'', 6:h'05', 8:h'44616c656b' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
</pre>
<pre>
    After compression (22  bytes):

      Flag byte: 0b00011001 = 0x19 (1 byte)

      Option Value: 0x19050544616c656b (8 bytes)

      Payload: 0xae a0155667924dff8a24e4cb35b9 (14 bytes)
</pre>
<p></p>

<dl>
<dt>4.   </dt>
<dd>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and no Partial IV</dd>
</dl>
<pre>
    Before compression (18 bytes):

      [
        h'',
        {},
        h'aea0155667924dff8a24e4cb35b9',
      ]
</pre>
<pre>
    After compression (14 bytes):

      Flag byte: 0b00000000 = 0x00 (1 byte)

      Option Value: 0x (0 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
</pre>
<p></p>

<dl>
<dt>5.   </dt>
<dd>Response with ciphertext = 0xaea0155667924dff8a24e4cb35b9 and Partial IV = 0x07</dd>
</dl>
<pre>
    Before compression (21 bytes):

      [
        h'',
        { 6:h'07' },
        h'aea0155667924dff8a24e4cb35b9',
      ]
</pre>
<pre>
    After compression (16 bytes):

      Flag byte: 0b00000001 = 0x01 (1 byte)

      Option Value: 0x0107 (2 bytes)

      Payload: 0xaea0155667924dff8a24e4cb35b9 (14 bytes)
</pre>
<h1 id="rfc.section.7">
<a href="#rfc.section.7">7.</a> <a href="#sequence-numbers" id="sequence-numbers">Message Binding, Sequence Numbers, Freshness, and Replay Protection</a>
</h1>
<h1 id="rfc.section.7.1">
<a href="#rfc.section.7.1">7.1.</a> <a href="#message-binding" id="message-binding">Message Binding</a>
</h1>
<p id="rfc.section.7.1.p.1">In order to prevent response delay and mismatch attacks <a href="#I-D.mattsson-core-coap-actuators" class="xref">[I-D.mattsson-core-coap-actuators]</a> from on-path attackers and compromised intermediaries, OSCORE binds responses to the requests by including the &#8216;kid&#8217; and Partial IV of the request in the AAD of the response. The server therefore needs to store the &#8216;kid&#8217; and Partial IV of the request until all responses have been sent.</p>
<h1 id="rfc.section.7.2">
<a href="#rfc.section.7.2">7.2.</a> <a href="#nonce-uniqueness" id="nonce-uniqueness">Sequence Numbers</a>
</h1>
<p id="rfc.section.7.2.p.1">An AEAD nonce MUST NOT be used more than once per AEAD key. The uniqueness of (key, nonce) pairs is shown in <a href="#kn-uniqueness" class="xref">Appendix D.4</a>, and in particular depends on a correct usage of Partial IVs (which encode the Sender Sequence Numbers, see <a href="#cose-object" class="xref">Section 5</a>). If messages are processed concurrently, the operation of reading and increasing the Sender Sequence Number MUST be atomic.</p>
<h1 id="rfc.section.7.2.1">
<a href="#rfc.section.7.2.1">7.2.1.</a> <a href="#max-seq" id="max-seq">Maximum Sequence Number</a>
</h1>
<p id="rfc.section.7.2.1.p.1">The maximum Sender Sequence Number is algorithm dependent (see <a href="#sec-considerations" class="xref">Section 12</a>), and SHALL be less than 2^40. If the Sender Sequence Number exceeds the maximum, the endpoint MUST NOT process any more messages with the given Sender Context. If necessary, the endpoint SHOULD acquire a new security context before this happens. The latter is out of scope of this document.</p>
<h1 id="rfc.section.7.3">
<a href="#rfc.section.7.3">7.3.</a> <a href="#freshness" id="freshness">Freshness</a>
</h1>
<p id="rfc.section.7.3.p.1">For requests, OSCORE provides only the guarantee that the request is not older than the security context. For applications having stronger demands on request freshness (e.g., control of actuators), OSCORE needs to be augmented with mechanisms providing freshness, for example as specified in <a href="#I-D.ietf-core-echo-request-tag" class="xref">[I-D.ietf-core-echo-request-tag]</a>.</p>
<p id="rfc.section.7.3.p.2">Assuming an honest server (see <a href="#overview-sec-properties" class="xref">Appendix D</a>), the message binding guarantees that a response is not older than its request. For responses that are not notifications (i.e. when there is a single response to a request), this gives absolute freshness. For notifications, the absolute freshness gets weaker with time, and it is RECOMMENDED that the client regularly re-register the observation. Note that the message binding does not guarantee that misbehaving server created the response before receiving the request, i.e. it does not verify server aliveness.</p>
<p id="rfc.section.7.3.p.3">For requests and notifications, OSCORE also provides relative freshness in the sense that the received Partial IV allows a recipient to determine the relative order of requests or responses.</p>
<h1 id="rfc.section.7.4">
<a href="#rfc.section.7.4">7.4.</a> <a href="#replay-protection" id="replay-protection">Replay Protection</a>
</h1>
<p id="rfc.section.7.4.p.1">In order to protect from replay of requests, the server&#8217;s Recipient Context includes a Replay Window. A server SHALL verify that a Partial IV = Sender Sequence Number received in the COSE object has not been received before. If this verification fails, the server SHALL stop processing the message, and MAY optionally respond with a 4.01 (Unauthorized) error message. Also, the server MAY set an Outer Max-Age option with value zero, to inform any intermediary that the response is not to be cached. The diagnostic payload MAY contain the &#8220;Replay detected&#8221; string. The size and type of the Replay Window depends on the use case and the protocol with which the OSCORE message is transported. In case of reliable and ordered transport from endpoint to endpoint, e.g. TCP, the server MAY just store the last received Partial IV and require that newly received Partial IVs equals the last received Partial IV + 1. However, in case of mixed reliable and unreliable transports and where messages may be lost, such a replay mechanism may be too restrictive and the default replay window be more suitable (see <a href="#initial-replay" class="xref">Section 3.2.2</a>).</p>
<p id="rfc.section.7.4.p.2">Responses (with or without Partial IV) are protected against replay as they are bound to the request and the fact that only a single response is accepted. Note that the Partial IV is not used for replay protection in this case.</p>
<p id="rfc.section.7.4.p.3">The operation of validating the Partial IV and updating the replay protection MUST be atomic.</p>
<h1 id="rfc.section.7.4.1">
<a href="#rfc.section.7.4.1">7.4.1.</a> <a href="#replay-notifications" id="replay-notifications">Replay Protection of Notifications</a>
</h1>
<p id="rfc.section.7.4.1.p.1">The following applies additionally when Observe is supported.</p>
<p id="rfc.section.7.4.1.p.2">The Notification Number is initialized to the Partial IV of the first successfully verified notification in response to the registration request. A client MUST only accept at most one Observe notifications without Partial IV, and treat it as the oldest notification received. A client receiving a notification containing a Partial IV SHALL compare the Partial IV with the Notification Number associated to that Observe registration. The client MUST stop processing notifications with a Partial IV which has been previously received. Applications MAY decide that a client only processes notifications which have greater Partial IV than the Notification Number.</p>
<p id="rfc.section.7.4.1.p.3">If the verification of the response succeeds, and the received Partial IV was greater than the Notification Number then the client SHALL overwrite the corresponding Notification Number with the received Partial IV.</p>
<h1 id="rfc.section.7.5">
<a href="#rfc.section.7.5">7.5.</a> <a href="#context-state" id="context-state">Losing Part of the Context State</a>
</h1>
<p id="rfc.section.7.5.p.1">To prevent reuse of an AEAD nonce with the same AEAD key, or from accepting replayed messages, an endpoint needs to handle the situation of losing rapidly changing parts of the context, such as the Sender Sequence Number, and Replay Window. These are typically stored in RAM and therefore lost in the case of e.g. an unplanned reboot. There are different alternatives to recover, for example:</p>
<p></p>

<ol>
<li>The endpoints can reuse an existing Security Context after updating the mutable parts of the security context (Sender Sequence Number, and Replay Window). This requires that the mutable parts of the security context are available throughout the lifetime of the device, or that the device can establish safe security context after loss of mutable security context data. Examples is given based on careful use of non-volatile memory, see <a href="#seq-numb" class="xref">Appendix B.1.1</a>, and additionally the use of the Echo option, see <a href="#reboot-replay" class="xref">Appendix B.1.2</a>. If an endpoint makes use of a partial security context stored in non-volatile memory, it MUST NOT reuse a previous Sender Sequence Number and MUST NOT accept previously received messages.</li>
<li>The endpoints can reuse an existing shared Master Secret and derive new Sender and Recipient Contexts, see <a href="#master-secret-multiple" class="xref">Appendix B.2</a> for an example. This typically requires a good source of randomness.</li>
<li>The endpoints can use a trusted-third party assisted key establishment protocol such as <a href="#I-D.ietf-ace-oscore-profile" class="xref">[I-D.ietf-ace-oscore-profile]</a>. This requires the execution of three-party protocol and may require a good source of randomness.</li>
<li>The endpoints can run a key exchange protocol providing forward secrecy resulting in a fresh Master Secret, from which an entirely new Security Context is derived. This requires a good source of randomness, and additionally, the transmission and processing of the protocol may have a non-negligible cost, e.g. in terms of power consumption.</li>
</ol>
<p id="rfc.section.7.5.p.3">The endpoints need to be configured with information about which method is used. The choice of method may depend on capabilities of the devices deployed and the solution architecture. Using a key exchange protocol is necessary for deployments that require forward secrecy.</p>
<h1 id="rfc.section.8">
<a href="#rfc.section.8">8.</a> <a href="#processing" id="processing">Processing</a>
</h1>
<p id="rfc.section.8.p.1">This section describes the OSCORE message processing. Additional processing for Observe or Block-wise are described in subsections.</p>
<p id="rfc.section.8.p.2">Note that, analogously to <a href="#RFC7252" class="xref">[RFC7252]</a> where the Token and source/destination pair are used to match a response with a request, both endpoints MUST keep the association (Token, {Security Context, Partial IV of the request}), in order to be able to find the Security Context and compute the AAD to protect or verify the response. The association MAY be forgotten after it has been used to successfully protect or verify the response, with the exception of Observe processing, where the association MUST be kept as long as the Observation is active.</p>
<p id="rfc.section.8.p.3">The processing of the Sender Sequence Number follows the procedure described in Section 3 of <a href="#I-D.mcgrew-iv-gen" class="xref">[I-D.mcgrew-iv-gen]</a>.</p>
<h1 id="rfc.section.8.1">
<a href="#rfc.section.8.1">8.1.</a> <a href="#prot-req" id="prot-req">Protecting the Request</a>
</h1>
<p id="rfc.section.8.1.p.1">Given a CoAP request, the client SHALL perform the following steps to create an OSCORE request:</p>
<p></p>

<ol>
<li>Retrieve the Sender Context associated with the target resource.</li>
<li>Compose the Additional Authenticated Data and the plaintext, as described in Sections <a href="#plaintext" class="xref">5.3</a> and <a href="#AAD" class="xref">5.4</a>.</li>
<li>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV as described in <a href="#nonce" class="xref">Section 5.2</a>.</li>
<li>Encrypt the COSE object using the Sender Key. Compress the COSE Object as specified in <a href="#compression" class="xref">Section 6</a>.</li>
<li>Format the OSCORE message according to <a href="#protected-fields" class="xref">Section 4</a>. The OSCORE option is added (see <a href="#outer-options" class="xref">Section 4.1.2</a>).</li>
</ol>
<h1 id="rfc.section.8.2">
<a href="#rfc.section.8.2">8.2.</a> <a href="#ver-req" id="ver-req">Verifying the Request</a>
</h1>
<p id="rfc.section.8.2.p.1">A server receiving a request containing the OSCORE option SHALL perform the following steps:</p>
<p></p>

<ol>
<li>Discard Code and all class E options (marked in <a href="#fig-option-protection" class="xref">Figure 5</a> with &#8216;x&#8217; in column E) present in the received message. For example, an If-Match Outer option is discarded, but an Uri-Host Outer option is not discarded.</li>
<li>Decompress the COSE Object (<a href="#compression" class="xref">Section 6</a>) and retrieve the Recipient Context associated with the Recipient ID in the &#8216;kid&#8217; parameter, additionally using the &#8216;kid context&#8217;, if present. If either the decompression or the COSE message fails to decode, or the server fails to retrieve a Recipient Context with Recipient ID corresponding to the &#8216;kid&#8217; parameter received, then the server SHALL stop processing the request.  <ul>
<li>If either the decompression or the COSE message fails to decode, the server MAY respond with a 4.02 (Bad Option) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string &#8220;Failed to decode COSE&#8221;.</li>
<li>If the server fails to retrieve a Recipient Context with Recipient ID corresponding to the &#8216;kid&#8217; parameter received, the server MAY respond with a 4.01 (Unauthorized) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the string &#8220;Security context not found&#8221;.</li>
</ul>
</li>
<li>Verify that the &#8216;Partial IV&#8217; has not been received before using the Replay Window, as described in <a href="#replay-protection" class="xref">Section 7.4</a>.</li>
<li>Compose the Additional Authenticated Data, as described in <a href="#AAD" class="xref">Section 5.4</a>.</li>
<li>Compute the AEAD nonce from the Recipient ID, Common IV, and the &#8216;Partial IV&#8217; parameter, received in the COSE Object.</li>
<li>Decrypt the COSE object using the Recipient Key, as per <a href="#RFC8152" class="xref">[RFC8152]</a> Section 5.3. (The decrypt operation includes the verification of the integrity.)  <ul>
<li>If decryption fails, the server MUST stop processing the request and MAY respond with a 4.00 (Bad Request) error message. The server MAY set an Outer Max-Age option with value zero. The diagnostic payload MAY contain the &#8220;Decryption failed&#8221; string.</li>
<li>If decryption succeeds, update the Replay Window, as described in <a href="#sequence-numbers" class="xref">Section 7</a>.</li>
</ul>
</li>
<li>Add decrypted Code, options, and payload to the decrypted request. The OSCORE option is removed.</li>
<li>The decrypted CoAP request is processed according to <a href="#RFC7252" class="xref">[RFC7252]</a>.</li>
</ol>
<h1 id="rfc.section.8.2.1">
<a href="#rfc.section.8.2.1">8.2.1.</a> <a href="#supporting-block-wise" id="supporting-block-wise">Supporting Block-wise</a>
</h1>
<p id="rfc.section.8.2.1.p.1">If Block-wise is supported, insert the following step before any other:</p>
<p id="rfc.section.8.2.1.p.2">A.  If Block-wise is present in the request, then process the Outer Block options according to <a href="#RFC7959" class="xref">[RFC7959]</a>, until all blocks of the request have been received (see <a href="#block-options" class="xref">Section 4.1.3.4</a>).</p>
<h1 id="rfc.section.8.3">
<a href="#rfc.section.8.3">8.3.</a> <a href="#prot-res" id="prot-res">Protecting the Response</a>
</h1>
<p id="rfc.section.8.3.p.1">If a CoAP response is generated in response to an OSCORE request, the server SHALL perform the following steps to create an OSCORE response. Note that CoAP error responses derived from CoAP processing (step 8 in <a href="#ver-req" class="xref">Section 8.2</a>) are protected, as well as successful CoAP responses, while the OSCORE errors (steps 2, 3, and 6 in <a href="#ver-req" class="xref">Section 8.2</a>) do not follow the processing below, but are sent as simple CoAP responses, without OSCORE processing.</p>
<p></p>

<ol>
<li>Retrieve the Sender Context in the Security Context associated with the Token.</li>
<li>Compose the Additional Authenticated Data and the plaintext, as described in Sections <a href="#plaintext" class="xref">5.3</a> and <a href="#AAD" class="xref">5.4</a>.</li>
<li>Compute the AEAD nonce as described in <a href="#nonce" class="xref">Section 5.2</a>:  <ul>
<li>Either use the AEAD nonce from the request, or</li>
<li>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</li>
</ul>
</li>
<li>Encrypt the COSE object using the Sender Key. Compress the COSE Object as specified in <a href="#compression" class="xref">Section 6</a>. If the AEAD nonce was constructed from a new Partial IV, this Partial IV MUST be included in the message. If the AEAD nonce from the request was used, the Partial IV MUST NOT be included in the message.</li>
<li>Format the OSCORE message according to <a href="#protected-fields" class="xref">Section 4</a>. The OSCORE option is added (see <a href="#outer-options" class="xref">Section 4.1.2</a>).</li>
</ol>
<h1 id="rfc.section.8.3.1">
<a href="#rfc.section.8.3.1">8.3.1.</a> <a href="#observe-prot-res" id="observe-prot-res">Supporting Observe</a>
</h1>
<p id="rfc.section.8.3.1.p.1">If Observe is supported, insert the following step between step 2 and 3 of <a href="#prot-res" class="xref">Section 8.3</a>:</p>
<p id="rfc.section.8.3.1.p.2">A. If the response is an observe notification:</p>
<p></p>

<ul>
<li>If the response is the first notification: <ul><li>compute the AEAD nonce as described in <a href="#nonce" class="xref">Section 5.2</a>: <ul>
<li>Either use the AEAD nonce from the request, or</li>
<li>Encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV.</li>
</ul>
<p> Then go to 4.</p>
</li></ul>
</li>
<li>If the response is not the first notification: <ul><li>encode the Partial IV (Sender Sequence Number in network byte order) and increment the Sender Sequence Number by one. Compute the AEAD nonce from the Sender ID, Common IV, and Partial IV, then go to 4.</li></ul>
</li>
</ul>
<h1 id="rfc.section.8.4">
<a href="#rfc.section.8.4">8.4.</a> <a href="#ver-res" id="ver-res">Verifying the Response</a>
</h1>
<p id="rfc.section.8.4.p.1">A client receiving a response containing the OSCORE option SHALL perform the following steps:</p>
<p></p>

<ol>
<li>Discard Code and all class E options (marked in <a href="#fig-option-protection" class="xref">Figure 5</a> with &#8216;x&#8217; in column E) present in the received message. For example, ETag Outer option is discarded, as well as Max-Age Outer option.</li>
<li>Retrieve the Recipient Context in the Security Context associated with the Token. Decompress the COSE Object (<a href="#compression" class="xref">Section 6</a>). If either the decompression or the COSE message fails to decode, then go to 8.</li>
<li>Compose the Additional Authenticated Data, as described in <a href="#AAD" class="xref">Section 5.4</a>.</li>
<li>Compute the AEAD nonce  <ul>
<li>If the Partial IV is not present in the response, the AEAD nonce from the request is used.</li>
<li>If the Partial IV is present in the response, compute the AEAD nonce from the Recipient ID, Common IV, and the &#8216;Partial IV&#8217; parameter, received in the COSE Object.</li>
</ul>
</li>
<li>Decrypt the COSE object using the Recipient Key, as per <a href="#RFC8152" class="xref">[RFC8152]</a> Section 5.3. (The decrypt operation includes the verification of the integrity.) If decryption fails, then go to 8.</li>
<li>Add decrypted Code, options and payload to the decrypted request. The OSCORE option is removed.</li>
<li>The decrypted CoAP response is processed according to <a href="#RFC7252" class="xref">[RFC7252]</a>.</li>
<li>In case any of the previous erroneous conditions apply: the client SHALL stop processing the response.</li>
</ol>
<h1 id="rfc.section.8.4.1">
<a href="#rfc.section.8.4.1">8.4.1.</a> <a href="#supporting-block-wise-1" id="supporting-block-wise-1">Supporting Block-wise</a>
</h1>
<p id="rfc.section.8.4.1.p.1">If Block-wise is supported, insert the following step before any other:</p>
<p id="rfc.section.8.4.1.p.2">A.  If Block-wise is present in the request, then process the Outer Block options according to <a href="#RFC7959" class="xref">[RFC7959]</a>, until all blocks of the request have been received (see <a href="#block-options" class="xref">Section 4.1.3.4</a>).</p>
<h1 id="rfc.section.8.4.2">
<a href="#rfc.section.8.4.2">8.4.2.</a> <a href="#observe-ver-res" id="observe-ver-res">Supporting Observe</a>
</h1>
<p id="rfc.section.8.4.2.p.1">If Observe is supported:</p>
<p id="rfc.section.8.4.2.p.2">Insert the following step between step 5 and step 6:</p>
<p id="rfc.section.8.4.2.p.3">A. If the request was an Observe registration, then:</p>
<p></p>

<ul>
<li>If the Partial IV is not present in the response, and Inner Observe is present, and the AEAD nonce from the request was already used once, then go to 8.</li>
<li>If the Partial IV is present in the response and Inner Observe is present, then follow the processing described in <a href="#notifications" class="xref">Section 4.1.3.5.2</a> and <a href="#replay-notifications" class="xref">Section 7.4.1</a>, then:  <ul>
<li>initialize the Notification Number (if first successfully verified notification), or</li>
<li>overwrite the Notification Number (if the received Partial IV was greater than the Notification Number).</li>
</ul>
</li>
</ul>
<p id="rfc.section.8.4.2.p.5">Replace step 8 of <a href="#ver-res" class="xref">Section 8.4</a> with:</p>
<p id="rfc.section.8.4.2.p.6">B. In case any of the previous erroneous conditions apply: the client SHALL stop processing the response. An error condition occurring while processing a response to an observation request does not cancel the observation. A client MUST NOT react to failure by re-registering the observation immediately.</p>
<h1 id="rfc.section.9">
<a href="#rfc.section.9">9.</a> <a href="#web-linking" id="web-linking">Web Linking</a>
</h1>
<p id="rfc.section.9.p.1">The use of OSCORE MAY be indicated by a target attribute &#8220;osc&#8221; in a web link <a href="#RFC8288" class="xref">[RFC8288]</a> to a resource, e.g. using a link-format document <a href="#RFC6690" class="xref">[RFC6690]</a> if the resource is accessible over CoAP.</p>
<p id="rfc.section.9.p.2">The &#8220;osc&#8221; attribute is a hint indicating that the destination of that link is only accessible using OSCORE, and unprotected access to it is not supported. Note that this is simply a hint, it does not include any security context material or any other information required to run OSCORE.</p>
<p id="rfc.section.9.p.3">A value MUST NOT be given for the &#8220;osc&#8221; attribute; any present value MUST be ignored by parsers. The &#8220;osc&#8221; attribute MUST NOT appear more than once in a given link-value; occurrences after the first MUST be ignored by parsers.</p>
<p id="rfc.section.9.p.4">The example in <a href="#fig-web-link" class="xref">Figure 11</a> shows a use of the &#8220;osc&#8221; attribute: the client does resource discovery on a server, and gets back a list of resources, one of which includes the &#8220;osc&#8221; attribute indicating that the resource is protected with OSCORE. The link-format notation (see Section 5 of <a href="#RFC6690" class="xref">[RFC6690]</a>) is used.</p>
<div id="rfc.figure.11"></div>
<div id="fig-web-link"></div>
<pre>
REQ: GET /.well-known/core

RES: 2.05 Content
   &lt;/sensors/temp&gt;;osc,
   &lt;/sensors/light&gt;;if="sensor"
</pre>
<p class="figure">Figure 11: The web link</p>
<h1 id="rfc.section.10">
<a href="#rfc.section.10">10.</a> <a href="#coap-coap-proxy" id="coap-coap-proxy">CoAP-to-CoAP Forwarding Proxy</a>
</h1>
<p id="rfc.section.10.p.1">CoAP is designed for proxy operations (see Section 5.7 of <a href="#RFC7252" class="xref">[RFC7252]</a>).</p>
<p id="rfc.section.10.p.2">OSCORE is designed to work with OSCORE-unaware CoAP proxies. Security requirements for forwarding are listed in Section 2.2.1 of <a href="#I-D.hartke-core-e2e-security-reqs" class="xref">[I-D.hartke-core-e2e-security-reqs]</a>. Proxy processing of the (Outer) Proxy-Uri option works as defined in <a href="#RFC7252" class="xref">[RFC7252]</a>. Proxy processing of the (Outer) Block options works as defined in <a href="#RFC7959" class="xref">[RFC7959]</a>.</p>
<p id="rfc.section.10.p.3">However, not all CoAP proxy operations are useful:</p>
<p></p>

<ul>
<li>Since a CoAP response is only applicable to the original CoAP request, caching is in general not useful. In support of existing proxies, OSCORE uses the outer Max-Age option, see <a href="#max-age" class="xref">Section 4.1.3.1</a>.</li>
<li>Proxy processing of the (Outer) Observe option as defined in <a href="#RFC7641" class="xref">[RFC7641]</a> is specified in <a href="#observe" class="xref">Section 4.1.3.5</a>.</li>
</ul>
<p id="rfc.section.10.p.5">Optionally, a CoAP proxy MAY detect OSCORE and act accordingly. An OSCORE-aware CoAP proxy:</p>
<p></p>

<ul>
<li>SHALL bypass caching for the request if the OSCORE option is present</li>
<li>SHOULD avoid caching responses to requests with an OSCORE option</li>
</ul>
<p id="rfc.section.10.p.7">In the case of Observe (see <a href="#observe" class="xref">Section 4.1.3.5</a>) the OSCORE-aware CoAP proxy:</p>
<p></p>

<ul>
<li>SHALL NOT initiate an Observe registration</li>
<li>MAY verify the order of notifications using Partial IV rather than the Observe option</li>
</ul>
<h1 id="rfc.section.11">
<a href="#rfc.section.11">11.</a> <a href="#http-op" id="http-op">HTTP Operations</a>
</h1>
<p id="rfc.section.11.p.1">The CoAP request/response model may be mapped to HTTP and vice versa as described in Section 10 of <a href="#RFC7252" class="xref">[RFC7252]</a>. The HTTP-CoAP mapping is further detailed in <a href="#RFC8075" class="xref">[RFC8075]</a>. This section defines the components needed to map and transport OSCORE messages over HTTP hops. By mapping between HTTP and CoAP and by using cross-protocol proxies OSCORE may be used end-to-end between e.g. an HTTP client and a CoAP server. Examples are provided at the end of the section.</p>
<h1 id="rfc.section.11.1">
<a href="#rfc.section.11.1">11.1.</a> <a href="#header-field" id="header-field">The HTTP OSCORE Header Field</a>
</h1>
<p id="rfc.section.11.1.p.1">The HTTP OSCORE Header Field (see <a href="#iana-http" class="xref">Section 13.4</a>) is used for carrying the content of the CoAP OSCORE option when transporting OSCORE messages over HTTP hops.</p>
<p id="rfc.section.11.1.p.2">The HTTP OSCORE header field is only used in POST requests and 200 (OK) responses. When used, the HTTP header field Content-Type is set to &#8216;application/oscore&#8217; (see <a href="#oscore-media-type" class="xref">Section 13.5</a>) indicating that the HTTP body of this message contains the OSCORE payload (see <a href="#oscore-payl" class="xref">Section 6.2</a>). No additional semantics is provided by other message fields.</p>
<p id="rfc.section.11.1.p.3">Using the Augmented Backus-Naur Form (ABNF) notation of <a href="#RFC5234" class="xref">[RFC5234]</a>, including the following core ABNF syntax rules defined by that specification: ALPHA (letters) and DIGIT (decimal digits), the HTTP OSCORE header field value is as follows.</p>
<pre>
base64url-char = ALPHA / DIGIT / "-" / "_"

OSCORE = 2*base64url-char
</pre>
<p id="rfc.section.11.1.p.4">The HTTP OSCORE header field is not appropriate to list in the Connection header field (see Section 6.1 of <a href="#RFC7230" class="xref">[RFC7230]</a>) since it is not hop-by-hop. OSCORE messages are generally not useful when served from cache (i.e., they will generally be marked Cache-Control: no-cache) and so interaction with Vary is not relevant (Section 7.1.4 of <a href="#RFC7231" class="xref">[RFC7231]</a>). Since the HTTP OSCORE header field is critical for message processing, moving it from headers to trailers renders the message unusable in case trailers are ignored (see Section 4.1 of <a href="#RFC7230" class="xref">[RFC7230]</a>).</p>
<p id="rfc.section.11.1.p.5">Intermediaries are in general not allowed to insert, delete, or modify the OSCORE header. Changes to the HTTP OSCORE header field will in general violate the integrity of the OSCORE message resulting in an error. For the same reason the HTTP OSCORE header field is in general not preserved across redirects.</p>
<p id="rfc.section.11.1.p.6">Since redirects are not defined in the mappings between HTTP and CoAP <a href="#RFC8075" class="xref">[RFC8075]</a><a href="#RFC7252" class="xref">[RFC7252]</a>, a number of conditions need to be fulfilled for redirects to work. For CoAP client to HTTP server, such conditions include:</p>
<p></p>

<ul>
<li>the CoAP-to-HTTP proxy follows the redirect, instead of the CoAP client as in the HTTP case</li>
<li>the CoAP-to-HTTP proxy copies the HTTP OSCORE header field and body to the new request</li>
<li>the target of the redirect has the necessary OSCORE security context required to decrypt and verify the message</li>
</ul>
<p id="rfc.section.11.1.p.8">Since OSCORE requires HTTP body to be preserved across redirects, the HTTP server is RECOMMENDED to reply with 307 or 308 instead of 301 or 302.</p>
<p id="rfc.section.11.1.p.9">For the case of HTTP client to CoAP server, although redirect is not defined for CoAP servers <a href="#RFC7252" class="xref">[RFC7252]</a>, an HTTP client receiving a redirect should generate a new OSCORE request for the server it was redirected to.</p>
<h1 id="rfc.section.11.2">
<a href="#rfc.section.11.2">11.2.</a> <a href="#coap2http" id="coap2http">CoAP-to-HTTP Mapping</a>
</h1>
<p id="rfc.section.11.2.p.1">Section 10.1 of <a href="#RFC7252" class="xref">[RFC7252]</a> describes the fundamentals of the CoAP-to-HTTP cross-protocol mapping process. The additional rules for OSCORE messages are:</p>
<p></p>

<ul>
<li>The HTTP OSCORE header field value is set to  <ul>
<li>AA if the CoAP OSCORE option is empty, otherwise</li>
<li>the value of the CoAP OSCORE option (<a href="#obj-sec-value" class="xref">Section 6.1</a>) in base64url (Section 5 of <a href="#RFC4648" class="xref">[RFC4648]</a>) encoding without padding. Implementation notes for this encoding are given in Appendix C of <a href="#RFC7515" class="xref">[RFC7515]</a>.</li>
</ul>
</li>
<li>The HTTP Content-Type is set to &#8216;application/oscore&#8217; (see <a href="#oscore-media-type" class="xref">Section 13.5</a>), independent of CoAP Content-Format.</li>
</ul>
<h1 id="rfc.section.11.3">
<a href="#rfc.section.11.3">11.3.</a> <a href="#http2coap" id="http2coap">HTTP-to-CoAP Mapping</a>
</h1>
<p id="rfc.section.11.3.p.1">Section 10.2 of <a href="#RFC7252" class="xref">[RFC7252]</a> and <a href="#RFC8075" class="xref">[RFC8075]</a> specify the behavior of an HTTP-to-CoAP proxy.  The additional rules for HTTP messages with the OSCORE header field are:</p>
<p></p>

<ul>
<li>The CoAP OSCORE option is set as follows:  <ul>
<li>empty if the value of the HTTP OSCORE header field is a single zero byte (0x00) represented by AA, otherwise</li>
<li>the value of the HTTP OSCORE header field decoded from base64url (Section 5 of <a href="#RFC4648" class="xref">[RFC4648]</a>) without padding. Implementation notes for this encoding are given in Appendix C of <a href="#RFC7515" class="xref">[RFC7515]</a>.</li>
</ul>
</li>
<li>The CoAP Content-Format option is omitted, the content format for OSCORE (<a href="#content-format" class="xref">Section 13.6</a>) MUST NOT be used.</li>
</ul>
<h1 id="rfc.section.11.4">
<a href="#rfc.section.11.4">11.4.</a> <a href="#http-endpoints" id="http-endpoints">HTTP Endpoints</a>
</h1>
<p id="rfc.section.11.4.p.1">Restricted to subsets of HTTP and CoAP supporting a bijective mapping, OSCORE can be originated or terminated in HTTP endpoints.</p>
<p id="rfc.section.11.4.p.2">The sending HTTP endpoint uses <a href="#RFC8075" class="xref">[RFC8075]</a> to translate the HTTP message into a CoAP message. The CoAP message is then processed with OSCORE as defined in this document. The OSCORE message is then mapped to HTTP as described in <a href="#coap2http" class="xref">Section 11.2</a> and sent in compliance with the rules in <a href="#header-field" class="xref">Section 11.1</a>.</p>
<p id="rfc.section.11.4.p.3">The receiving HTTP endpoint maps the HTTP message to a CoAP message using <a href="#RFC8075" class="xref">[RFC8075]</a> and <a href="#http2coap" class="xref">Section 11.3</a>. The resulting OSCORE message is processed as defined in this document. If successful, the plaintext CoAP message is translated to HTTP for normal processing in the endpoint.</p>
<h1 id="rfc.section.11.5">
<a href="#rfc.section.11.5">11.5.</a> <a href="#example-http-client-and-coap-server" id="example-http-client-and-coap-server">Example: HTTP Client and CoAP Server</a>
</h1>
<p id="rfc.section.11.5.p.1">This section is giving an example of how a request and a response between an HTTP client and a CoAP server could look like. The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps.</p>
<p id="rfc.section.11.5.p.2">Mapping and notation here is based on &#8220;Simple Form&#8221; (Section 5.4.1 of <a href="#RFC8075" class="xref">[RFC8075]</a>).</p>
<pre>
[HTTP request -- Before client object security processing]

  GET http://proxy.url/hc/?target_uri=coap://server.url/orders 
   HTTP/1.1
</pre>
<pre>
[HTTP request -- HTTP Client to Proxy]

  POST http://proxy.url/hc/?target_uri=coap://server.url/ HTTP/1.1
  Content-Type: application/oscore
  OSCORE: CSU
  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
</pre>
<pre>
[CoAP request -- Proxy to CoAP Server]

  POST coap://server.url/
  OSCORE: 09 25
  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
</pre>
<pre>
[CoAP request -- After server object security processing]

  GET coap://server.url/orders 
</pre>
<pre>
[CoAP response -- Before server object security processing]

  2.05 Content
  Content-Format: 0
  Payload: Exterminate! Exterminate!
</pre>
<pre>
[CoAP response -- CoAP Server to Proxy]

  2.04 Changed
  OSCORE: [empty]
  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
</pre>
<pre>
[HTTP response -- Proxy to HTTP Client]

  HTTP/1.1 200 OK
  Content-Type: application/oscore
  OSCORE: AA 
  Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
</pre>
<pre>
[HTTP response -- After client object security processing]

  HTTP/1.1 200 OK
  Content-Type: text/plain
  Body: Exterminate! Exterminate!
</pre>
<p id="rfc.section.11.5.p.3">Note that the HTTP Status Code 200 in the next-to-last message is the mapping of CoAP Code 2.04 (Changed), whereas the HTTP Status Code 200 in the last message is the mapping of the CoAP Code 2.05 (Content), which was encrypted within the compressed COSE object carried in the Body of the HTTP response.</p>
<h1 id="rfc.section.11.6">
<a href="#rfc.section.11.6">11.6.</a> <a href="#example-coap-client-and-http-server" id="example-coap-client-and-http-server">Example: CoAP Client and HTTP Server</a>
</h1>
<p id="rfc.section.11.6.p.1">This section is giving an example of how a request and a response between a CoAP client and an HTTP server could look like.  The example is not a test vector but intended as an illustration of how the message fields are translated in the different steps</p>
<pre>
[CoAP request -- Before client object security processing]

  GET coap://proxy.url/
  Proxy-Uri=http://server.url/orders
</pre>
<pre>
[CoAP request -- CoAP Client to Proxy]

  POST coap://proxy.url/
  Proxy-Uri=http://server.url/
  OSCORE: 09 25
  Payload: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
</pre>
<pre>
[HTTP request -- Proxy to HTTP Server]

  POST http://server.url/ HTTP/1.1
  Content-Type: application/oscore
  OSCORE: CSU
  Body: 09 07 01 13 61 f7 0f d2 97 b1 [binary]
</pre>
<pre>
[HTTP request -- After server object security processing]

  GET http://server.url/orders HTTP/1.1
</pre>
<pre>
[HTTP response -- Before server object security processing]

  HTTP/1.1 200 OK
  Content-Type: text/plain
  Body: Exterminate! Exterminate!
</pre>
<pre>
[HTTP response -- HTTP Server to Proxy]

  HTTP/1.1 200 OK
  Content-Type: application/oscore
  OSCORE: AA
  Body: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
</pre>
<pre>
[CoAP response -- Proxy to CoAP Client]

  2.04 Changed
  OSCORE: [empty]
  Payload: 00 31 d1 fc f6 70 fb 0c 1d d5 ... [binary]
</pre>
<pre>
[CoAP response -- After client object security processing]

  2.05 Content
  Content-Format: 0
  Payload: Exterminate! Exterminate!
</pre>
<p id="rfc.section.11.6.p.2">Note that the HTTP Code 2.04 (Changed) in the next-to-last message is the mapping of HTTP Status Code 200, whereas the CoAP Code 2.05 (Content) in the last message is the value that was encrypted within the compressed COSE object carried in the Body of the HTTP response.</p>
<h1 id="rfc.section.12">
<a href="#rfc.section.12">12.</a> <a href="#sec-considerations" id="sec-considerations">Security Considerations</a>
</h1>
<p id="rfc.section.12.p.1">An overview of the security properties is given in <a href="#overview-sec-properties" class="xref">Appendix D</a>.</p>
<h1 id="rfc.section.12.1">
<a href="#rfc.section.12.1">12.1.</a> <a href="#end-to-end-protection" id="end-to-end-protection">End-to-end Protection</a>
</h1>
<p id="rfc.section.12.1.p.1">In scenarios with intermediary nodes such as proxies or gateways, transport layer security such as (D)TLS only protects data hop-by-hop. As a consequence, the intermediary nodes can read and modify any information. The trust model where all intermediary nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as &#8220;unlock door&#8221;, &#8220;start fire alarm&#8221;, &#8220;raise bridge&#8221;). Even in the rare cases where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.</p>
<p id="rfc.section.12.1.p.2">(D)TLS protects hop-by-hop the entire message. OSCORE protects end-to-end all information that is not required for proxy operations (see <a href="#protected-fields" class="xref">Section 4</a>). (D)TLS and OSCORE can be combined, thereby enabling end-to-end security of the message payload, in combination with hop-by-hop protection of the entire message, during transport between end-point and intermediary node. In particular when OSCORE is used with HTTP, the additional TLS protection of HTTP hops is RECOMMENDED, e.g. between an HTTP endpoint and a proxy translating between HTTP and CoAP.</p>
<p id="rfc.section.12.1.p.3">Applications need to consider that certain message fields and messages types are not protected end-to-end and may be spoofed or manipulated. The consequences of unprotected message fields are analyzed in <a href="#unprot-fields" class="xref">Appendix D.5</a>.</p>
<h1 id="rfc.section.12.2">
<a href="#rfc.section.12.2">12.2.</a> <a href="#sec-context-establish" id="sec-context-establish">Security Context Establishment</a>
</h1>
<p id="rfc.section.12.2.p.1">The use of COSE_Encrypt0 and AEAD to protect messages as specified in this document requires an established security context. The method to establish the security context described in <a href="#context-derivation" class="xref">Section 3.2</a> is based on a common Master Secret and unique Sender IDs. The necessary input parameters may be pre-established or obtained using a key establishment protocol augmented with establishment of Sender/Recipient ID, such as a key exchange protocol or the OSCORE profile of the ACE framework <a href="#I-D.ietf-ace-oscore-profile" class="xref">[I-D.ietf-ace-oscore-profile]</a>. Such a procedure must ensure that the requirements of the security context parameters for the intended use are complied with (see <a href="#req-params" class="xref">Section 3.3</a>) and also in error situations. While recipient IDs are allowed to coincide between different security contexts (see <a href="#req-params" class="xref">Section 3.3</a>), this may cause a server to process multiple verifications before finding the right security context or rejecting a message. Considerations for deploying OSCORE with a fixed Master Secret are given in <a href="#deployment-examples" class="xref">Appendix B</a>.</p>
<h1 id="rfc.section.12.3">
<a href="#rfc.section.12.3">12.3.</a> <a href="#master-secret" id="master-secret">Master Secret</a>
</h1>
<p id="rfc.section.12.3.p.1">OSCORE uses HKDF <a href="#RFC5869" class="xref">[RFC5869]</a> and the established input parameters to derive the security context. The required properties of the security context parameters are discussed in <a href="#req-params" class="xref">Section 3.3</a>, in this section we focus on the Master Secret. HKDF denotes in this specification the composition of the expand and extract functions as defined in <a href="#RFC5869" class="xref">[RFC5869]</a> and the Master Secret is used as Input Key Material (IKM).</p>
<p id="rfc.section.12.3.p.2">Informally, HKDF takes as source an IKM containing some good amount of randomness but not necessarily distributed uniformly (or for which an attacker has some partial knowledge) and derive from it one or more cryptographically strong secret keys <a href="#RFC5869" class="xref">[RFC5869]</a>.</p>
<p id="rfc.section.12.3.p.3">Therefore, the main requirement for the OSCORE Master Secret, in addition to being secret, is that it is has a good amount of randomness. The selected key establishment schemes must ensure that the necessary properties for the Master Secret are fulfilled. For pre-shared key deployments and key transport solutions such as <a href="#I-D.ietf-ace-oscore-profile" class="xref">[I-D.ietf-ace-oscore-profile]</a>, the Master Secret can be generated offline using a good random number generator. Randomness requirements for security are described in <a href="#RFC4086" class="xref">[RFC4086]</a>.</p>
<h1 id="rfc.section.12.4">
<a href="#rfc.section.12.4">12.4.</a> <a href="#replay-protection2" id="replay-protection2">Replay Protection</a>
</h1>
<p id="rfc.section.12.4.p.1">Replay attacks need to be considered in different parts of the implementation. Most AEAD algorithms require a unique nonce for each message, for which the sender sequence numbers in the COSE message field &#8216;Partial IV&#8217; is used. If the recipient accepts any sequence number larger than the one previously received, then the problem of sequence number synchronization is avoided. With reliable transport, it may be defined that only messages with sequence number which are equal to previous sequence number + 1 are accepted. An adversary may try to induce a device reboot for the purpose of replaying a message (see <a href="#context-state" class="xref">Section 7.5</a>).</p>
<p id="rfc.section.12.4.p.2">Note that sharing a security context between servers may open up for replay attacks, for example if the replay windows are not synchronized.</p>
<h1 id="rfc.section.12.5">
<a href="#rfc.section.12.5">12.5.</a> <a href="#client-aliveness" id="client-aliveness">Client Aliveness</a>
</h1>
<p id="rfc.section.12.5.p.1">A verified OSCORE request enables the server to verify the identity of the entity who generated the message. However, it does not verify that the client is currently involved in the communication, since the message may be a delayed delivery of a previously generated request which now reaches the server. To verify the aliveness of the client the server may use the Echo option in the response to a request from the client (see <a href="#I-D.ietf-core-echo-request-tag" class="xref">[I-D.ietf-core-echo-request-tag]</a>).</p>
<h1 id="rfc.section.12.6">
<a href="#rfc.section.12.6">12.6.</a> <a href="#cryptographic-considerations" id="cryptographic-considerations">Cryptographic Considerations</a>
</h1>
<p id="rfc.section.12.6.p.1">The maximum sender sequence number is dependent on the AEAD algorithm. The maximum sender sequence number is 2^40 - 1, or any algorithm specific lower limit, after which a new security context must be generated. The mechanism to build the AEAD nonce (<a href="#nonce" class="xref">Section 5.2</a>) assumes that the nonce is at least 56 bits, and the Partial IV is at most 40 bits. The mandatory-to-implement AEAD algorithm AES-CCM-16-64-128 is selected for compatibility with CCM*. AEAD algorithms that require unpredictable nonces are not supported.</p>
<p id="rfc.section.12.6.p.2">In order to prevent cryptanalysis when the same plaintext is repeatedly encrypted by many different users with distinct AEAD keys, the AEAD nonce is formed by mixing the sequence number with a secret per-context initialization vector (Common IV) derived along with the keys (see Section 3.1 of <a href="#RFC8152" class="xref">[RFC8152]</a>), and by using a Master Salt in the key derivation (see <a href="#MF00" class="xref">[MF00]</a> for an overview). The Master Secret, Sender Key, Recipient Key, and Common IV must be secret, the rest of the parameters may be public. The Master Secret must have a good amount of randomness (see <a href="#master-secret" class="xref">Section 12.3</a>).</p>
<p id="rfc.section.12.6.p.3">The ID Context, Sender ID, and Partial IV are always at least implicitly integrity protected, as manipulation leads to the wrong nonce or key being used and therefore results in decryption failure.</p>
<h1 id="rfc.section.12.7">
<a href="#rfc.section.12.7">12.7.</a> <a href="#message-segmentation" id="message-segmentation">Message Segmentation</a>
</h1>
<p id="rfc.section.12.7.p.1">The Inner Block options enable the sender to split large messages into OSCORE-protected blocks such that the receiving endpoint can verify blocks before having received the complete message. The Outer Block options allow for arbitrary proxy fragmentation operations that cannot be verified by the endpoints, but can by policy be restricted in size since the Inner Block options allow for secure fragmentation of very large messages. A maximum message size (above which the sending endpoint fragments the message and the receiving endpoint discards the message, if complying to the policy) may be obtained as part of normal resource discovery.</p>
<h1 id="rfc.section.12.8">
<a href="#rfc.section.12.8">12.8.</a> <a href="#priv-cons" id="priv-cons">Privacy Considerations</a>
</h1>
<p id="rfc.section.12.8.p.1">Privacy threats executed through intermediary nodes are considerably reduced by means of OSCORE. End-to-end integrity protection and encryption of the message payload and all options that are not used for proxy operations, provide mitigation against attacks on sensor and actuator communication, which may have a direct impact on the personal sphere.</p>
<p id="rfc.section.12.8.p.2">The unprotected options (<a href="#fig-option-protection" class="xref">Figure 5</a>) may reveal privacy sensitive information, see <a href="#unprot-fields" class="xref">Appendix D.5</a>. CoAP headers sent in plaintext allow, for example, matching of CON and ACK (CoAP Message Identifier), matching of request and responses (Token) and traffic analysis. OSCORE does not provide protection for HTTP header fields which are not both CoAP-mappable and class E. The HTTP message fields which are visible to on-path entity are only used for the purpose of transporting the OSCORE message, whereas the application layer message is encoded in CoAP and encrypted.</p>
<p id="rfc.section.12.8.p.3">COSE message fields, i.e. the OSCORE option, may reveal information about the communicating endpoints. E.g. &#8216;kid&#8217; and &#8216;kid context&#8217;, which are intended to help the server find the right context, may reveal information about the client. Tracking &#8216;kid&#8217; and &#8216;kid context&#8217; to one server may be used for correlating requests from one client.</p>
<p id="rfc.section.12.8.p.4">Unprotected error messages reveal information about the security state in the communication between the endpoints. Unprotected signaling messages reveal information about the reliable transport used on a leg of the path. Using the mechanisms described in <a href="#context-state" class="xref">Section 7.5</a> may reveal when a device goes through a reboot. This can be mitigated by the device storing the precise state of sender sequence number and replay window on a clean shutdown.</p>
<p id="rfc.section.12.8.p.5">The length of message fields can reveal information about the message. Applications may use a padding scheme to protect against traffic analysis.</p>
<h1 id="rfc.section.13">
<a href="#rfc.section.13">13.</a> <a href="#iana-considerations" id="iana-considerations">IANA Considerations</a>
</h1>
<p id="rfc.section.13.p.1">Note to RFC Editor: Please replace all occurrences of &#8220;[[this document]]&#8221; with the RFC number of this specification.</p>
<p id="rfc.section.13.p.2">Note to IANA: Please note all occurrences of &#8220;TBD1&#8221; in this specification should be assigned the same number.</p>
<h1 id="rfc.section.13.1">
<a href="#rfc.section.13.1">13.1.</a> <a href="#cose-header-parameters-registry" id="cose-header-parameters-registry">COSE Header Parameters Registry</a>
</h1>
<p id="rfc.section.13.1.p.1">The &#8216;kid context&#8217; parameter is added to the &#8220;COSE Header Parameters Registry&#8221;:</p>
<p></p>

<ul>
<li>Name: kid context</li>
<li>Label: TBD2</li>
<li>Value Type: bstr</li>
<li>Value Registry:</li>
<li>Description: Identifies the context for &#8216;kid&#8217;</li>
<li>Reference: <a href="#context-hint" class="xref">Section 5.1</a> of this document</li>
</ul>
<p id="rfc.section.13.1.p.3">Note to IANA: Label assignment in (Integer value between 1 and 255) is requested. (RFC Editor: Delete this note after IANA assignment)</p>
<h1 id="rfc.section.13.2">
<a href="#rfc.section.13.2">13.2.</a> <a href="#coap-option-numbers-registry" id="coap-option-numbers-registry">CoAP Option Numbers Registry</a>
</h1>
<p id="rfc.section.13.2.p.1">The OSCORE option is added to the CoAP Option Numbers registry:</p>
<pre>
+--------+-----------------+-------------------+
| Number | Name            | Reference         |
+--------+-----------------+-------------------+
|  TBD1  | OSCORE          | [[this document]] |
+--------+-----------------+-------------------+
</pre>
<p id="rfc.section.13.2.p.2">Note to IANA: Label assignment in (Integer value between 0 and 12) is requested. We also request Expert review if possible, to make sure a correct number for the option is selected (RFC Editor: Delete this note after IANA assignment)</p>
<p id="rfc.section.13.2.p.3">Furthermore, the following existing entries in the CoAP Option Numbers registry are updated with a reference to the document specifying OSCORE processing of that option:</p>
<pre>
+--------+-----------------+---------------------------------------+
| Number | Name            |          Reference                    |
+--------+-----------------+---------------------------------------+
|   1    | If-Match        | [RFC7252] [[this document]]           |
|   3    | Uri-Host        | [RFC7252] [[this document]]           | 
|   4    | ETag            | [RFC7252] [[this document]]           |
|   5    | If-None-Match   | [RFC7252] [[this document]]           |
|   6    | Observe         | [RFC7641] [[this document]]           |
|   7    | Uri-Port        | [RFC7252] [[this document]]           |
|   8    | Location-Path   | [RFC7252] [[this document]]           |
|  11    | Uri-Path        | [RFC7252] [[this document]]           |
|  12    | Content-Format  | [RFC7252] [[this document]]           |
|  14    | Max-Age         | [RFC7252] [[this document]]           |
|  15    | Uri-Query       | [RFC7252] [[this document]]           |
|  17    | Accept          | [RFC7252] [[this document]]           |
|  20    | Location-Query  | [RFC7252] [[this document]]           |
|  23    | Block2          | [RFC7959] [RFC8323] [[this document]] |
|  27    | Block1          | [RFC7959] [RFC8323] [[this document]] |
|  28    | Size2           | [RFC7959] [[this document]]           |
|  35    | Proxy-Uri       | [RFC7252] [[this document]]           |
|  39    | Proxy-Scheme    | [RFC7252] [[this document]]           |
|  60    | Size1           | [RFC7252] [[this document]]           |
| 258    | No-Response     | [RFC7967] [[this document]]           |
+--------+-----------------+---------------------------------------+
</pre>
<p id="rfc.section.13.2.p.4">Future additions to the CoAP Option Numbers registry need to provide a reference to the document where the OSCORE processing of that CoAP Option is defined.</p>
<h1 id="rfc.section.13.3">
<a href="#rfc.section.13.3">13.3.</a> <a href="#coap-signaling-option-numbers-registry" id="coap-signaling-option-numbers-registry">CoAP Signaling Option Numbers Registry</a>
</h1>
<p id="rfc.section.13.3.p.1">The OSCORE option is added to the CoAP Signaling Option Numbers registry:</p>
<pre>
+------------+--------+---------------------+-------------------+
| Applies to | Number | Name                | Reference         |
+------------+--------+---------------------+-------------------+
| 7.xx (all) |  TBD1  | OSCORE              | [[this document]] |
+------------+--------+---------------------+-------------------+
</pre>
<p id="rfc.section.13.3.p.2">Note to IANA: The value in the &#8220;Number&#8221; field is the same value that&#8217;s being assigned to the new Option Number. Please make sure TBD1 is not the same as any value in Numbers for any existing entry in the CoAP Signaling Option Numbers registry (at the time of writing this, that means make sure TBD1 is not 2 or 4)(RFC Editor: Delete this note after IANA assignment)</p>
<h1 id="rfc.section.13.4">
<a href="#rfc.section.13.4">13.4.</a> <a href="#iana-http" id="iana-http">Header Field Registrations</a>
</h1>
<p id="rfc.section.13.4.p.1">The HTTP OSCORE header field is added to the Message Headers registry:</p>
<pre>
+-------------------+----------+----------+---------------------+
| Header Field Name | Protocol | Status   | Reference           |
+-------------------+----------+----------+---------------------+
| OSCORE            | http     | standard | [[this document]],  |
|                   |          |          | Section 11.1        |
+-------------------+----------+----------+---------------------+
</pre>
<h1 id="rfc.section.13.5">
<a href="#rfc.section.13.5">13.5.</a> <a href="#oscore-media-type" id="oscore-media-type">Media Type Registrations</a>
</h1>
<p id="rfc.section.13.5.p.1">This section registers the &#8216;application/oscore&#8217; media type in the &#8220;Media Types&#8221; registry. These media types are used to indicate that the content is an OSCORE message. The OSCORE body cannot be understood without the OSCORE header field value and the security context.</p>
<pre>
  Type name: application

  Subtype name: oscore

  Required parameters: N/A

  Optional parameters: N/A

  Encoding considerations: binary

  Security considerations: See the Security Considerations section
  of [[This document]].

  Interoperability considerations: N/A

  Published specification: [[This document]]

  Applications that use this media type: IoT applications sending
  security content over HTTP(S) transports.

  Fragment identifier considerations: N/A

  Additional information:

  *  Deprecated alias names for this type: N/A

  *  Magic number(s): N/A

  *  File extension(s): N/A

  *  Macintosh file type code(s): N/A

  Person &amp; email address to contact for further information:
  iesg@ietf.org

  Intended usage: COMMON

  Restrictions on usage: N/A

  Author: G&#246;ran Selander, goran.selander@ericsson.com

  Change Controller: IESG

  Provisional registration?  No
</pre>
<h1 id="rfc.section.13.6">
<a href="#rfc.section.13.6">13.6.</a> <a href="#content-format" id="content-format">CoAP Content-Formats Registry</a>
</h1>
<p id="rfc.section.13.6.p.1">Note to IANA: ID assignment in the 10000-64999 range is requested. (RFC Editor: Delete this note after IANA assignment)</p>
<p id="rfc.section.13.6.p.2">This section registers the media type &#8216;application/oscore&#8217; media type in the &#8220;CoAP Content-Formats&#8221; registry. This Content-Format for the OSCORE payload is defined for potential future use cases and SHALL NOT be used in the OSCORE message. The OSCORE payload cannot be understood without the OSCORE option value and the security context.</p>
<pre>
+----------------------+----------+----------+-------------------+
| Media Type           | Encoding |   ID     |     Reference     |
+----------------------+----------+----------+-------------------+
| application/oscore   |          |   TBD3   | [[this document]] |
+----------------------+----------+----------+-------------------+
</pre>
<h1 id="rfc.section.13.7">
<a href="#rfc.section.13.7">13.7.</a> <a href="#oscore-flag-bits" id="oscore-flag-bits">OSCORE Flag Bits Registry</a>
</h1>
<p id="rfc.section.13.7.p.1">This document defines a sub-registry for the OSCORE flag bits within the &#8220;CoRE Parameters&#8221; registry. The name of the sub-registry is &#8220;OSCORE Flag Bits&#8221;. The registry should be created with the Expert Review policy. Guidelines for the experts are provided in <a href="#exp-instr" class="xref">Section 13.8</a>.</p>
<p id="rfc.section.13.7.p.2">The columns of the registry are:</p>
<p></p>

<ul>
<li>bit position: This indicates the position of the bit in the set of OSCORE flag bits, starting at 0 for the most significant bit. The bit position must be an integer or a range of integers, in the range 0 to 63.</li>
<li>name: The name is present to make it easier to refer to and discuss the registration entry. The value is not used in the protocol. Names are to be unique in the table.</li>
<li>description: This contains a brief description of the use of the bit.</li>
<li>specification: This contains a pointer to the specification defining the entry.</li>
</ul>
<p id="rfc.section.13.7.p.4">The initial contents of the registry can be found in the table below. The specification column for all rows in that table should be this document. The entries with Bit Position of 0 and 1 are to be marked as &#8216;Reserved&#8217;. The entry with Bit Position of 1 is going to be specified in a future document, and will be used to expand the space for the OSCORE flag bits in <a href="#obj-sec-value" class="xref">Section 6.1</a>, so that entries 8-63 of the registry are defined.</p>
<pre>
+--------------+-------------+---------------------+-------------------+
| Bit Position |     Name    |     Description     |   Specification   |
+--------------+-------------+---------------------+-------------------+
|       0      | Reserved    |                     |                   |
+--------------+-------------+---------------------+-------------------+
|       1      | Reserved    |                     |                   |
+--------------+-------------+---------------------+-------------------+
|       2      | Unassigned  |                     |                   |
+--------------+-------------+---------------------+-------------------+
|       3      | Kid Context | Set to 1 if 'kid    | [[this document]] |
|              | Flag        | context' is present |                   |
|              |             | in the compressed   |                   |
|              |             | COSE object         |                   |
+--------------+-------------+---------------------+-------------------+
|       4      | Kid Flag    | Set to 1 if kid is  | [[this document]] |
|              |             | present in the com- |                   |
|              |             | pressed COSE object |                   |
+--------------+-------------+---------------------+-------------------+
|     5-7      | Partial IV  | Encodes the Partial | [[this document]] |
|              | Length      | IV length; can have |                   |
|              |             | value 0 to 5        |                   |
+--------------+-------------+---------------------+-------------------+
|    8-63      | Unassigned  |                     |                   |
+--------------+-------------+---------------------+-------------------+
</pre>
<h1 id="rfc.section.13.8">
<a href="#rfc.section.13.8">13.8.</a> <a href="#exp-instr" id="exp-instr">Expert Review Instructions</a>
</h1>
<p id="rfc.section.13.8.p.1">The expert reviewers for the registry defined in this document are expected to ensure that the usage solves a valid use case that could not be solved better in a different way, that it is not going to duplicate one that is already registered, and that the registered point is likely to be used in deployments. They are furthermore expected to check the clarity of purpose and use of the requested code points. Experts should take into account the expected usage of entries when approving point assignment, and the length of the encoded value should be weighed against the number of code points left that encode to that size and the size of device it will be used on. Experts should block registration for entries 8-63 until these points are defined (i.e. until the mechanism for the OSCORE flag bits expansion via bit 1 is specified).</p>
<h1 id="rfc.references">
<a href="#rfc.references">14.</a> References</h1>
<h1 id="rfc.references.1">
<a href="#rfc.references.1">14.1.</a> Normative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="RFC2119">[RFC2119]</b></td>
<td class="top">
<a>Bradner, S.</a>, "<a href="https://tools.ietf.org/html/rfc2119">Key words for use in RFCs to Indicate Requirement Levels</a>", BCP 14, RFC 2119, DOI 10.17487/RFC2119, March 1997.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4086">[RFC4086]</b></td>
<td class="top">
<a>Eastlake 3rd, D.</a>, <a>Schiller, J.</a> and <a>S. Crocker</a>, "<a href="https://tools.ietf.org/html/rfc4086">Randomness Requirements for Security</a>", BCP 106, RFC 4086, DOI 10.17487/RFC4086, June 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC4648">[RFC4648]</b></td>
<td class="top">
<a>Josefsson, S.</a>, "<a href="https://tools.ietf.org/html/rfc4648">The Base16, Base32, and Base64 Data Encodings</a>", RFC 4648, DOI 10.17487/RFC4648, October 2006.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5234">[RFC5234]</b></td>
<td class="top">
<a>Crocker, D.</a> and <a>P. Overell</a>, "<a href="https://tools.ietf.org/html/rfc5234">Augmented BNF for Syntax Specifications: ABNF</a>", STD 68, RFC 5234, DOI 10.17487/RFC5234, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6347">[RFC6347]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>N. Modadugu</a>, "<a href="https://tools.ietf.org/html/rfc6347">Datagram Transport Layer Security Version 1.2</a>", RFC 6347, DOI 10.17487/RFC6347, January 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7049">[RFC7049]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>P. Hoffman</a>, "<a href="https://tools.ietf.org/html/rfc7049">Concise Binary Object Representation (CBOR)</a>", RFC 7049, DOI 10.17487/RFC7049, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7230">[RFC7230]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7230">Hypertext Transfer Protocol (HTTP/1.1): Message Syntax and Routing</a>", RFC 7230, DOI 10.17487/RFC7230, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7231">[RFC7231]</b></td>
<td class="top">
<a>Fielding, R.</a> and <a>J. Reschke</a>, "<a href="https://tools.ietf.org/html/rfc7231">Hypertext Transfer Protocol (HTTP/1.1): Semantics and Content</a>", RFC 7231, DOI 10.17487/RFC7231, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7252">[RFC7252]</b></td>
<td class="top">
<a>Shelby, Z.</a>, <a>Hartke, K.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/rfc7252">The Constrained Application Protocol (CoAP)</a>", RFC 7252, DOI 10.17487/RFC7252, June 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7641">[RFC7641]</b></td>
<td class="top">
<a>Hartke, K.</a>, "<a href="https://tools.ietf.org/html/rfc7641">Observing Resources in the Constrained Application Protocol (CoAP)</a>", RFC 7641, DOI 10.17487/RFC7641, September 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7959">[RFC7959]</b></td>
<td class="top">
<a>Bormann, C.</a> and <a>Z. Shelby</a>, "<a href="https://tools.ietf.org/html/rfc7959">Block-Wise Transfers in the Constrained Application Protocol (CoAP)</a>", RFC 7959, DOI 10.17487/RFC7959, August 2016.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8075">[RFC8075]</b></td>
<td class="top">
<a>Castellani, A.</a>, <a>Loreto, S.</a>, <a>Rahman, A.</a>, <a>Fossati, T.</a> and <a>E. Dijk</a>, "<a href="https://tools.ietf.org/html/rfc8075">Guidelines for Mapping Implementations: HTTP to the Constrained Application Protocol (CoAP)</a>", RFC 8075, DOI 10.17487/RFC8075, February 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8132">[RFC8132]</b></td>
<td class="top">
<a>van der Stok, P.</a>, <a>Bormann, C.</a> and <a>A. Sehgal</a>, "<a href="https://tools.ietf.org/html/rfc8132">PATCH and FETCH Methods for the Constrained Application Protocol (CoAP)</a>", RFC 8132, DOI 10.17487/RFC8132, April 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8152">[RFC8152]</b></td>
<td class="top">
<a>Schaad, J.</a>, "<a href="https://tools.ietf.org/html/rfc8152">CBOR Object Signing and Encryption (COSE)</a>", RFC 8152, DOI 10.17487/RFC8152, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8174">[RFC8174]</b></td>
<td class="top">
<a>Leiba, B.</a>, "<a href="https://tools.ietf.org/html/rfc8174">Ambiguity of Uppercase vs Lowercase in RFC 2119 Key Words</a>", BCP 14, RFC 8174, DOI 10.17487/RFC8174, May 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8288">[RFC8288]</b></td>
<td class="top">
<a>Nottingham, M.</a>, "<a href="https://tools.ietf.org/html/rfc8288">Web Linking</a>", RFC 8288, DOI 10.17487/RFC8288, October 2017.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8323">[RFC8323]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Lemay, S.</a>, <a>Tschofenig, H.</a>, <a>Hartke, K.</a>, <a>Silverajan, B.</a> and <a>B. Raymor</a>, "<a href="https://tools.ietf.org/html/rfc8323">CoAP (Constrained Application Protocol) over TCP, TLS, and WebSockets</a>", RFC 8323, DOI 10.17487/RFC8323, February 2018.</td>
</tr>
<tr>
<td class="reference"><b id="RFC8446">[RFC8446]</b></td>
<td class="top">
<a>Rescorla, E.</a>, "<a href="https://tools.ietf.org/html/rfc8446">The Transport Layer Security (TLS) Protocol Version 1.3</a>", RFC 8446, DOI 10.17487/RFC8446, August 2018.</td>
</tr>
</tbody></table>
<h1 id="rfc.references.2">
<a href="#rfc.references.2">14.2.</a> Informative References</h1>
<table><tbody>
<tr>
<td class="reference"><b id="I-D.bormann-6lo-coap-802-15-ie">[I-D.bormann-6lo-coap-802-15-ie]</b></td>
<td class="top">
<a>Bormann, C.</a>, "<a href="https://tools.ietf.org/html/draft-bormann-6lo-coap-802-15-ie-00">Constrained Application Protocol (CoAP) over IEEE 802.15.4 Information Element for IETF</a>", Internet-Draft draft-bormann-6lo-coap-802-15-ie-00, April 2016.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.hartke-core-e2e-security-reqs">[I-D.hartke-core-e2e-security-reqs]</b></td>
<td class="top">
<a>Selander, G.</a>, <a>Palombini, F.</a> and <a>K. Hartke</a>, "<a href="https://tools.ietf.org/html/draft-hartke-core-e2e-security-reqs-03">Requirements for CoAP End-To-End Security</a>", Internet-Draft draft-hartke-core-e2e-security-reqs-03, July 2017.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oauth-authz">[I-D.ietf-ace-oauth-authz]</b></td>
<td class="top">
<a>Seitz, L.</a>, <a>Selander, G.</a>, <a>Wahlstroem, E.</a>, <a>Erdtman, S.</a> and <a>H. Tschofenig</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oauth-authz-24">Authentication and Authorization for Constrained Environments (ACE) using the OAuth 2.0 Framework (ACE-OAuth)</a>", Internet-Draft draft-ietf-ace-oauth-authz-24, March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-ace-oscore-profile">[I-D.ietf-ace-oscore-profile]</b></td>
<td class="top">
<a>Palombini, F.</a>, <a>Seitz, L.</a>, <a>Selander, G.</a> and <a>M. Gunnarsson</a>, "<a href="https://tools.ietf.org/html/draft-ietf-ace-oscore-profile-07">OSCORE profile of the Authentication and Authorization for Constrained Environments Framework</a>", Internet-Draft draft-ietf-ace-oscore-profile-07, February 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-cbor-cddl">[I-D.ietf-cbor-cddl]</b></td>
<td class="top">
<a>Birkholz, H.</a>, <a>Vigano, C.</a> and <a>C. Bormann</a>, "<a href="https://tools.ietf.org/html/draft-ietf-cbor-cddl-08">Concise data definition language (CDDL): a notational convention to express CBOR and JSON data structures</a>", Internet-Draft draft-ietf-cbor-cddl-08, March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-echo-request-tag">[I-D.ietf-core-echo-request-tag]</b></td>
<td class="top">
<a>Amsuess, C.</a>, <a>Mattsson, J.</a> and <a>G. Selander</a>, "<a href="https://tools.ietf.org/html/draft-ietf-core-echo-request-tag-05">CoAP: Echo, Request-Tag, and Token Processing</a>", Internet-Draft draft-ietf-core-echo-request-tag-05, May 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.ietf-core-oscore-groupcomm">[I-D.ietf-core-oscore-groupcomm]</b></td>
<td class="top">
<a>Tiloca, M.</a>, <a>Selander, G.</a>, <a>Palombini, F.</a> and <a>J. Park</a>, "<a href="https://tools.ietf.org/html/draft-ietf-core-oscore-groupcomm-04">Group OSCORE - Secure Group Communication for CoAP</a>", Internet-Draft draft-ietf-core-oscore-groupcomm-04, March 2019.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.mattsson-core-coap-actuators">[I-D.mattsson-core-coap-actuators]</b></td>
<td class="top">
<a>Mattsson, J.</a>, <a>Fornehed, J.</a>, <a>Selander, G.</a>, <a>Palombini, F.</a> and <a>C. Amsuess</a>, "<a href="https://tools.ietf.org/html/draft-mattsson-core-coap-actuators-06">Controlling Actuators with CoAP</a>", Internet-Draft draft-mattsson-core-coap-actuators-06, September 2018.</td>
</tr>
<tr>
<td class="reference"><b id="I-D.mcgrew-iv-gen">[I-D.mcgrew-iv-gen]</b></td>
<td class="top">
<a>McGrew, D.</a>, "<a href="https://tools.ietf.org/html/draft-mcgrew-iv-gen-03">Generation of Deterministic Initialization Vectors (IVs) and Nonces</a>", Internet-Draft draft-mcgrew-iv-gen-03, October 2013.</td>
</tr>
<tr>
<td class="reference"><b id="MF00">[MF00]</b></td>
<td class="top">
<a>McGrew, D.</a> and <a>S. Fluhrer</a>, "<a>Attacks on Encryption of Redundant Plaintext and Implications on Internet Security</a>", the Proceedings of the Seventh Annual Workshop on Selected Areas in Cryptography (SAC 2000), Springer-Verlag. , 2000.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3552">[RFC3552]</b></td>
<td class="top">
<a>Rescorla, E.</a> and <a>B. Korver</a>, "<a href="https://tools.ietf.org/html/rfc3552">Guidelines for Writing RFC Text on Security Considerations</a>", BCP 72, RFC 3552, DOI 10.17487/RFC3552, July 2003.</td>
</tr>
<tr>
<td class="reference"><b id="RFC3986">[RFC3986]</b></td>
<td class="top">
<a>Berners-Lee, T.</a>, <a>Fielding, R.</a> and <a>L. Masinter</a>, "<a href="https://tools.ietf.org/html/rfc3986">Uniform Resource Identifier (URI): Generic Syntax</a>", STD 66, RFC 3986, DOI 10.17487/RFC3986, January 2005.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5116">[RFC5116]</b></td>
<td class="top">
<a>McGrew, D.</a>, "<a href="https://tools.ietf.org/html/rfc5116">An Interface and Algorithms for Authenticated Encryption</a>", RFC 5116, DOI 10.17487/RFC5116, January 2008.</td>
</tr>
<tr>
<td class="reference"><b id="RFC5869">[RFC5869]</b></td>
<td class="top">
<a>Krawczyk, H.</a> and <a>P. Eronen</a>, "<a href="https://tools.ietf.org/html/rfc5869">HMAC-based Extract-and-Expand Key Derivation Function (HKDF)</a>", RFC 5869, DOI 10.17487/RFC5869, May 2010.</td>
</tr>
<tr>
<td class="reference"><b id="RFC6690">[RFC6690]</b></td>
<td class="top">
<a>Shelby, Z.</a>, "<a href="https://tools.ietf.org/html/rfc6690">Constrained RESTful Environments (CoRE) Link Format</a>", RFC 6690, DOI 10.17487/RFC6690, August 2012.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7228">[RFC7228]</b></td>
<td class="top">
<a>Bormann, C.</a>, <a>Ersue, M.</a> and <a>A. Keranen</a>, "<a href="https://tools.ietf.org/html/rfc7228">Terminology for Constrained-Node Networks</a>", RFC 7228, DOI 10.17487/RFC7228, May 2014.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7515">[RFC7515]</b></td>
<td class="top">
<a>Jones, M.</a>, <a>Bradley, J.</a> and <a>N. Sakimura</a>, "<a href="https://tools.ietf.org/html/rfc7515">JSON Web Signature (JWS)</a>", RFC 7515, DOI 10.17487/RFC7515, May 2015.</td>
</tr>
<tr>
<td class="reference"><b id="RFC7967">[RFC7967]</b></td>
<td class="top">
<a>Bhattacharyya, A.</a>, <a>Bandyopadhyay, S.</a>, <a>Pal, A.</a> and <a>T. Bose</a>, "<a href="https://tools.ietf.org/html/rfc7967">Constrained Application Protocol (CoAP) Option for No Server Response</a>", RFC 7967, DOI 10.17487/RFC7967, August 2016.</td>
</tr>
</tbody></table>
<h1 id="rfc.appendix.A">
<a href="#rfc.appendix.A">Appendix A.</a> <a href="#examples" id="examples">Scenario Examples</a>
</h1>
<p id="rfc.section.A.p.1">This section gives examples of OSCORE, targeting scenarios in Section 2.2.1.1 of <a href="#I-D.hartke-core-e2e-security-reqs" class="xref">[I-D.hartke-core-e2e-security-reqs]</a>. The message exchanges are made, based on the assumption that there is a security context established between client and server. For simplicity, these examples only indicate the content of the messages without going into detail of the (compressed) COSE message format.</p>
<h1 id="rfc.appendix.A.1">
<a href="#rfc.appendix.A.1">A.1.</a> <a href="#secure-access-to-sensor" id="secure-access-to-sensor">Secure Access to Sensor</a>
</h1>
<p id="rfc.section.A.1.p.1">This example illustrates a client requesting the alarm status from a server.</p>
<div id="rfc.figure.12"></div>
<div id="fig-alarm"></div>
<pre>
Client  Proxy  Server
  |       |       |
  +------&gt;|       |            Code: 0.02 (POST)
  | POST  |       |           Token: 0x8c
  | &#160; &#160; &#160; | &#160; &#160; &#160; |          OSCORE: [kid:5f, Partial IV:42]
 &#160;| &#160; &#160; &#160; | &#160; &#160; &#160; | &#160; &#160; &#160;   Payload: {Code:0.01,
  |       |       |                   Uri-Path:"alarm_status"}
  |       |       |
  |       +------&gt;|            Code: 0.02 (POST)
  |       | POST  |           Token: 0x7b
  |       |       |          OSCORE: [kid:5f, Partial IV:42]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Uri-Path:"alarm_status"}
  |       |       |
  |       |&lt;------+            Code: 2.04 (Changed)
  |       |  2.04 |           Token: 0x7b
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05, "0"}
  |       |       |
  |&lt;------+       |            Code: 2.04 (Changed)
  |  2.04 |       |           Token: 0x8c
  |       |       |          OSCORE: -
  |       |       |         Payload: {Code:2.05, "0"}
  |       |       |
</pre>
<p class="figure">Figure 12: Secure Access to Sensor. Square brackets [ ... ] indicate content of compressed COSE object. Curly brackets { ... } indicate encrypted data.</p>
<p id="rfc.section.A.1.p.2">The request/response Codes are encrypted by OSCORE and only dummy Codes (POST/Changed) are visible in the header of the OSCORE message. The option Uri-Path (&#8220;alarm_status&#8221;) and payload (&#8220;0&#8221;) are encrypted.</p>
<p id="rfc.section.A.1.p.3">The COSE header of the request contains an identifier (5f), indicating which security context was used to protect the message and a Partial IV (42).</p>
<p id="rfc.section.A.1.p.4">The server verifies the request as specified in <a href="#ver-req" class="xref">Section 8.2</a>. The client verifies the response as specified in <a href="#ver-res" class="xref">Section 8.4</a>.</p>
<h1 id="rfc.appendix.A.2">
<a href="#rfc.appendix.A.2">A.2.</a> <a href="#secure-subscribe-to-sensor" id="secure-subscribe-to-sensor">Secure Subscribe to Sensor</a>
</h1>
<p id="rfc.section.A.2.p.1">This example illustrates a client requesting subscription to a blood sugar measurement resource (GET /glucose), first receiving the value 220 mg/dl and then a second value 180 mg/dl.</p>
<div id="rfc.figure.13"></div>
<div id="fig-blood-sugar"></div>
<pre>
Client  Proxy  Server
  |       |       |
  +------&gt;|       |            Code: 0.05 (FETCH)
  | FETCH |       |           Token: 0x83
  |       |       |         Observe: 0
  |       |       |          OSCORE: [kid:ca, Partial IV:15]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Uri-Path:"glucose"}
  |       |       |
  |       +------&gt;|            Code: 0.05 (FETCH)
  |       | FETCH |           Token: 0xbe
  |       |       |         Observe: 0
  |       |       |          OSCORE: [kid:ca, Partial IV:15]
  |       |       |         Payload: {Code:0.01,
  |       |       |                   Uri-Path:"glucose"}
  |       |       |
  |       |&lt;------+            Code: 2.05 (Content)
  |       |  2.05 |           Token: 0xbe
  |       |       |         Observe: 7
  |       |       |          OSCORE: [Partial IV:32]
  |       |       |         Payload: {Code:2.05,   
  |       |       |                   Content-Format:0, "220"}
  |       |       |
  |&lt;------+       |            Code: 2.05 (Content)
  |  2.05 |       |           Token: 0x83
  |       |       |         Observe: 7
  |       |       |          OSCORE: [Partial IV:32]
  |       |       |         Payload: {Code:2.05,   
  |       |       |                   Content-Format:0, "220"}
 ...     ...     ...
  |       |       |
  |       |&lt;------+            Code: 2.05 (Content)
  |       |  2.05 |           Token: 0xbe
  |       |       |         Observe: 8
  |       |       |          OSCORE: [Partial IV:36]
  |       |       |         Payload: {Code:2.05,
  |       |       |                   Content-Format:0, "180"}
  |       |       |
  |&lt;------+       |            Code: 2.05 (Content)
  |  2.05 |       |           Token: 0x83
  |       |       |         Observe: 8
  |       |       |          OSCORE: [Partial IV:36]
  |       |       |         Payload: {Code:2.05,
  |       |       |                   Content-Format:0, "180"}
  |       |       |
</pre>
<p class="figure">Figure 13: Secure Subscribe to Sensor. Square brackets [ ... ] indicate content of compressed COSE object header. Curly brackets { ... } indicate encrypted data.</p>
<p id="rfc.section.A.2.p.2">The dummy Codes (FETCH/Content) are used to allow forwarding of Observe messages. The options Content-Format (0) and the payload (&#8220;220&#8221; and &#8220;180&#8221;), are encrypted.</p>
<p id="rfc.section.A.2.p.3">The COSE header of the request contains an identifier (ca), indicating the security context used to protect the message and a Partial IV (15). The COSE headers of the responses contains Partial IVs (32 and 36).</p>
<p id="rfc.section.A.2.p.4">The server verifies that the Partial IV has not been received before. The client verifies that the responses are bound to the request and that the Partial IVs are greater than any Partial IV previously received in a response bound to the request.</p>
<h1 id="rfc.appendix.B">
<a href="#rfc.appendix.B">Appendix B.</a> <a href="#deployment-examples" id="deployment-examples">Deployment Examples</a>
</h1>
<p id="rfc.section.B.p.1">For many IoT deployments, a 128 bit uniformly random Master Key is sufficient for encrypting all data exchanged with the IoT device throughout its lifetime. Two examples are given in this section. In the first example, the security context is only derived once from the Master Secret. In the second example, security contexts are derived multiple times using random inputs.</p>
<h1 id="rfc.appendix.B.1">
<a href="#rfc.appendix.B.1">B.1.</a> <a href="#master-secret-once" id="master-secret-once">Security Context Derived Once</a>
</h1>
<p id="rfc.section.B.1.p.1">An application that only derives the security context once needs to handle the loss of mutable security context parameters, e.g. due to reboot.</p>
<h1 id="rfc.appendix.B.1.1">
<a href="#rfc.appendix.B.1.1">B.1.1.</a> <a href="#seq-numb" id="seq-numb">Sender Sequence Number</a>
</h1>
<p id="rfc.section.B.1.1.p.1">In order to handle loss of Sender Sequence Numbers, the device may implement procedures for writing to non-volatile memory during normal operations and updating the security context after reboot, provided that the procedures comply with the requirements on the security context parameters (<a href="#req-params" class="xref">Section 3.3</a>). This section gives an example of such a procedure.</p>
<p id="rfc.section.B.1.1.p.2">There are known issues related to writing to non-volatile memory. For example, flash drives may have a limited number of erase operations during its life time. Also, the time for a write operation to non-volatile memory to be completed may be unpredictable, e.g. due to caching, which could result in important security context data not being stored at the time when the device reboots.</p>
<p id="rfc.section.B.1.1.p.3">However, many devices have predictable limits for writing to non-volatile memory, are physically limited to only send a small amount of messages per minute, and may have no good source of randomness.</p>
<p id="rfc.section.B.1.1.p.4">To prevent reuse of Sender Sequence Numbers (SSN), an endpoint may perform the following procedure during normal operations:</p>
<p></p>

<ul><li>Before using a Sender Sequence Number that is evenly divisible by K, where K is a positive integer, store the Sender Sequence Number (SSN1) in non-volatile memory. After boot, the endpoint initiates the new Sender Sequence Number (SSN2) to the value stored in persistent memory plus K plus F: SSN2 = SSN1 + K + F, where F is a positive integer.  <ul>
<li>Writing to non-volatile memory can be costly; the value K gives a trade-off between frequency of storage operations and efficient use of Sender Sequence Numbers.</li>
<li>Writing to non-volatile memory may be subject to delays, or failure; F MUST be set so that the last Sender Sequence Number used before reboot is never larger than SSN2.</li>
</ul>
</li></ul>
<p id="rfc.section.B.1.1.p.6">If F cannot be set so SSN2 is always larger than the last Sender Sequence Number used before reboot, the method described in this section MUST NOT be used.</p>
<h1 id="rfc.appendix.B.1.2">
<a href="#rfc.appendix.B.1.2">B.1.2.</a> <a href="#reboot-replay" id="reboot-replay">Replay Window</a>
</h1>
<p id="rfc.section.B.1.2.p.1">In case of loss of security context on the server, to prevent accepting replay of previously received requests, the server may perform the following procedure after boot:</p>
<p></p>

<ul>
<li>The server updates its Sender Sequence Number as specified in <a href="#seq-numb" class="xref">Appendix B.1.1</a>, to be used as Partial IV in the response containing the Echo option (next bullet).</li>
<li>For each stored security context, the first time after boot the server receives an OSCORE request, the server responds with an OSCORE protected 4.01 (Unauthorized), containing only the Echo option <a href="#I-D.ietf-core-echo-request-tag" class="xref">[I-D.ietf-core-echo-request-tag]</a> and no diagnostic payload. The server MUST use its Partial IV when generating the AEAD nonce and MUST include the Partial IV in the response (see <a href="#cose-object" class="xref">Section 5</a>). If the server with use of the Echo option can verify a second OSCORE request as fresh, then the Partial IV of the second request is set as the lower limit of the replay window of that security context.</li>
</ul>
<h1 id="rfc.appendix.B.1.3">
<a href="#rfc.appendix.B.1.3">B.1.3.</a> <a href="#replay-notif" id="replay-notif">Notifications</a>
</h1>
<p id="rfc.section.B.1.3.p.1">To prevent accepting replay of previously received notifications, the client may perform the following procedure after boot:</p>
<p></p>

<ul><li>The client forgets about earlier registrations, removes all Notification Numbers and registers using Observe.</li></ul>
<h1 id="rfc.appendix.B.2">
<a href="#rfc.appendix.B.2">B.2.</a> <a href="#master-secret-multiple" id="master-secret-multiple">Security Context Derived Multiple Times</a>
</h1>
<p id="rfc.section.B.2.p.1">An application which does not require forward secrecy may allow multiple security contexts to be derived from one Master Secret. The requirements on the security context parameters MUST be fulfilled (<a href="#req-params" class="xref">Section 3.3</a>) even if the client or server is rebooted, recommissioned or in error cases.</p>
<p id="rfc.section.B.2.p.2">This section gives an example of a protocol which adds randomness to the ID Context parameter and uses that together with input parameters pre-established between client and server, in particular Master Secret, Master Salt, and Sender/Recipient ID (see <a href="#context-derivation" class="xref">Section 3.2</a>), to derive new security contexts. The random input is transported between client and server in the &#8216;kid context&#8217; parameter. This protocol MUST NOT be used unless both endpoints have good sources of randomness.</p>
<p id="rfc.section.B.2.p.3">During normal requests the ID Context of an established security context may be sent in the &#8216;kid context&#8217; which, together with &#8216;kid&#8217;, facilitates for the server to locate a security context. Alternatively, the &#8216;kid context&#8217; may be omitted since the ID Context is expected to be known to both client and server, see <a href="#context-hint" class="xref">Section 5.1</a>.</p>
<p id="rfc.section.B.2.p.4">The protocol described in this section may only be needed when the mutable part of security context is lost in the client or server, e.g. when the endpoint has rebooted. The protocol may additionally be used whenever the client and server need to derive a new security context. For example, if a device is provisioned with one fixed set of input parameters (including Master Secret, Sender and Recipient Identifiers) then a randomized ID Context ensures that the security context is different for each deployment.</p>
<p id="rfc.section.B.2.p.5">The protocol is described below with reference to <a href="#fig-B2" class="xref">Figure 14</a>. The client or the server may initiate the protocol, in the latter case step 1 is omitted.</p>
<div id="rfc.figure.14"></div>
<div id="fig-B2"></div>
<pre>
                      Client                Server
                        |                      |
1. Protect with         |      request #1      |
   ID Context = ID1     |---------------------&gt;| 2. Verify with
                        |  kid_context = ID1   |    ID Context = ID1
                        |                      | 
                        |      response #1     |    Protect with
3. Verify with          |&lt;---------------------|    ID Context = R2||ID1
   ID Context = R2||ID1 |   kid_context = R2   |
                        |                      |
   Protect with         |      request #2      |
   ID Context = R2||R3  |---------------------&gt;| 4. Verify with 
                        | kid_context = R2||R3 |    ID Context = R2||R3
                        |                      | 
                        |      response #2     |    Protect with
5. Verify with          |&lt;---------------------|    ID Context = R2||R3
   ID Context = R2||R3  |                      | 
</pre>
<p class="figure">Figure 14: Protocol for establishing a new security context.</p>
<p></p>

<ol>
<li>(Optional) If the client does not have a valid security context with the server, e.g. because of reboot or because this is the first time it contacts the server, then it generates a random string R1, and uses this as ID Context together with the input parameters shared with the server to derive a first security context. The client sends an OSCORE request to the server protected with the first security context, containing R1 wrapped in a CBOR bstr as &#8216;kid context&#8217;. The request may target a special resource used for updating security contexts.</li>
<li>The server receives an OSCORE request for which it does not have a valid security context, either because the client has generated a new security context ID1 = R1, or because the server has lost part of its security context, e.g. ID Context, Sender Sequence Number or replay window. If the server is able to verify the request (see <a href="#ver-req" class="xref">Section 8.2</a>)&#160;with the new derived first security context using the received ID1 (transported in &#8216;kid context&#8217;) as ID Context and the input parameters associated to the received &#8216;kid&#8217;, then the server generates a random string R2, and derives a second security context with ID Context = ID2 = R2 || ID1. The server sends a 4.01 (Unauthorized) response protected with the second security context, containing R2 wrapped in a CBOR bstr as &#8216;kid context&#8217;, and caches R2. R2 MUST NOT be reused as that may lead to reuse of key and nonce in reponse #1. Note that the server may receive several requests #1 associated with one security context, leading to multiple parallel protocol runs. Multiple instances of R2 may need to be cached until one of the protocol runs is completed, see <a href="#impl-cons" class="xref">Appendix B.2.1</a>.</li>
<li>The client receives a response with &#8216;kid context&#8217; containing a CBOR bstr wrapping R2 to an OSCORE request it made with ID Context = ID1. The client derives a second security context using ID Context = ID2 = R2 || ID1. If the client can verify the response (see <a href="#ver-res" class="xref">Section 8.4</a>) using the second security context, then the client makes a request protected with a third security context derived from ID Context = ID3 = R2 || R3, where R3 is a random byte string generated by the client. The request includes R2 || R3 wrapped in a CBOR bstr as &#8216;kid context&#8217;.</li>
<li>If the server receives a request with &#8216;kid context&#8217; containing a CBOR bstr wrapping ID3, where the first part of ID3 is identical to an R2 sent in a previous response #1 which it has not received before, then the server derives a third security context with ID Context = ID3. The server MUST NOT accept replayed request #2 messages. If the server can verify the request (see <a href="#ver-req" class="xref">Section 8.2</a>) with the third security context, then the server marks the third security context to be used with this client and removes all instances of R2 associated to this security context from the cache. This security context replaces the previous security context with the client, and the first and the second security contexts are deleted. The server responds using the same security context as in the request.</li>
<li>If the client receives a response to the request with the third security context and the response verifies (see <a href="#ver-res" class="xref">Section 8.4</a>), then the client marks the third security context to be used with this server. This security context replaces the previous security context with the server, and the first and second security contexts are deleted.</li>
</ol>
<p id="rfc.section.B.2.p.7">If verification fails in any step, the endpoint stops processing that message.</p>
<p id="rfc.section.B.2.p.8">The length of the nonces R1, R2, and R3 is application specific. The application needs to set the length of each nonce such the probability of its value being repeated is negligible; typically, at least 8 bytes long. Since R2 may be generated as the result of a replayed request #1, the probability for collision of R2s is impacted by the birthday paradox. For example, setting the length of R2 to 8 bytes results in an average collision after 2^32 response #1 messages, which should not be an issue for a constrained server handling on the order of one request per second.</p>
<p id="rfc.section.B.2.p.9">Request #2 can be an ordinary request. The server performs the action of the request and sends response #2 after having successfully completed the security context related operations in step 4. The client acts on response #2 after having successfully completed step 5.</p>
<p id="rfc.section.B.2.p.10">When sending request #2, the client is assured that the Sender Key (derived with the random value R3) has never been used before. When receiving response #2, the client is assured that the response (protected with a key derived from the random value R3 and the Master Secret) was created by the server in response to request #2.</p>
<p id="rfc.section.B.2.p.11">Similarly, when receiving request #2, the server is assured that the request (protected with a key derived from the random value R2 and the Master Secret) was created by the client in response to response #1. When sending response #2, the server is assured that the Sender Key (derived with the random value R2) has never been used before.</p>
<p id="rfc.section.B.2.p.12">Implementation and denial-of-service considerations are made in <a href="#impl-cons" class="xref">Appendix B.2.1</a> and <a href="#attack-cons" class="xref">Appendix B.2.2</a>.</p>
<h1 id="rfc.appendix.B.2.1">
<a href="#rfc.appendix.B.2.1">B.2.1.</a> <a href="#impl-cons" id="impl-cons">Implementation Considerations</a>
</h1>
<p id="rfc.section.B.2.1.p.1">This section add some implemention considerations to the protocol described in the previous section.</p>
<p id="rfc.section.B.2.1.p.2">The server may only have space for a few security contexts, or only be able to handle a few protocol runs in parallel.  The server may legitimately receive multiple request #1 messages using the same non-mutable security context, e.g. due to packet loss. Replays of old request #1 messages could be difficult for the server to distinguish from legitimate. The server needs to handle the case when the maximum number of cached R2s is reached. If the server receives a request #1 and is not capable of executing it then it may respond with an unprotected 5.03 (Service Unavailable). The server may clear up state from protocol runs which never complete, e.g. set a timer when caching R2, and remove R2 and the associated security contexts from the cache at timeout. Additionally, state information can be flushed at reboot.</p>
<p id="rfc.section.B.2.1.p.3">As an alternative to caching R2, the server could generate R2 in such a way that it can be sent (in response #1) and verified (at reception of request #2) as the value of R2 it had generated. Such a procedure MUST NOT lead to the server accepting replayed request #2 messages. One construction described in the following is based on using a secret random HMAC key K_HMAC per set of non-mutable security context parameters associated to a client. This construction allows the server to handle verification of R2 in response #2 at the cost of storing the K_HMAC keys and a slightly larger message overhead in response #1. Steps below refer to modifications to <a href="#master-secret-multiple" class="xref">Appendix B.2</a>:</p>
<p></p>

<ul>
<li>In step 2, R2 is generated in the following way. First, the server generates a random K_HMAC (unless it already has one associated with the security context), then it sets R2 = S2 || HMAC(K_HMAC, S2) where S2 is a random byte string, and the HMAC is truncated to 8 bytes. K_HMAC may have an expiration time, after which it is erased. Note that neither R2, S2 nor the derived first and second security contexts need to be cached.</li>
<li>In step 4, instead of verifying that R2 coincides with a cached value, the server looks up the associated K_HMAC and verifies the truncated HMAC, and the processing continues accordingly depending on verification success or failure.  K_HMAC is used until a run of the protocol is completed (after verification of request #2), or until it expires (whatever comes first), after which K_HMAC is erased. (The latter corresponds to removing the cached values of R2 in step 4 of <a href="#master-secret-multiple" class="xref">Appendix B.2</a>, and makes the server reject replays of request #2.)</li>
</ul>
<p id="rfc.section.B.2.1.p.5">The length of S2 is application specific and the probability for collision of S2s is impacted by the birthday paradox. For example, setting the length of S2 to 8 bytes results in an average collision after 2^32 response #1 messages, which should not be an issue for a constrained server handling on the order of one request per second.</p>
<p id="rfc.section.B.2.1.p.6">Two endpoints sharing a security context may accidently initiate two instances of the protocol at the same time, each in the role of client, e.g. after a power outage affecting both endpoints. Such a race condition could potentially lead to both protocols failing, and both endpoints repeatedly re-initiating the protocol without converging. Both endpoints can detect this situation and it can be handled in different ways. The requests could potentially be more spread out in time, for example by only initiating this protocol when the endpoint actually needs to make a request, potentially adding a random delay before requests immediately after reboot or if such parallel protocol runs are detected.</p>
<h1 id="rfc.appendix.B.2.2">
<a href="#rfc.appendix.B.2.2">B.2.2.</a> <a href="#attack-cons" id="attack-cons">Attack Considerations</a>
</h1>
<p id="rfc.section.B.2.2.p.1">An on-path attacker may inject a message causing the endpoint to process verification of the message. A message crafted without access to the Master Secret will fail to verify.</p>
<p id="rfc.section.B.2.2.p.2">Replaying an old request with a value of &#8216;kid_context&#8217; which the server does not recognize could trigger the protocol. This causes the server to generate the first and second security context and send a response. But if the client did not expect a response it will be discarded. This may still result in a denial-of-service attack against the server e.g. because of not being able to manage the state associated with many parallel protocol runs, and it may prevent legitimate client requests. Implementation alternatives with less data caching per request #1 message are favorable in this respect, see <a href="#impl-cons" class="xref">Appendix B.2.1</a>.</p>
<p id="rfc.section.B.2.2.p.3">Replaying response #1 in response to some request other than request #1 will fail to verify, since response #1 is associated to request #1, through the dependencies of ID Contexts and the Partial IV of request #1 included in the external_aad of response #1.</p>
<p id="rfc.section.B.2.2.p.4">If request #2 has already been well received, then the server has a valid security context, so a replay of request #2 is handled by the normal replay protection mechanism. Similarly if response #2 has already been received, a replay of response #2 to some other request from the client will fail by the normal verification of binding of response to request.</p>
<h1 id="rfc.appendix.C">
<a href="#rfc.appendix.C">Appendix C.</a> <a href="#test-vectors" id="test-vectors">Test Vectors</a>
</h1>
<p id="rfc.section.C.p.1">This appendix includes the test vectors for different examples of CoAP messages using OSCORE. Given a set of inputs, OSCORE defines how to set up the Security Context in both the client and the server.</p>
<p id="rfc.section.C.p.2">Note that in <a href="#tv4" class="xref">Appendix C.4</a> and all following test vectors the Token and the Message ID of the OSCORE-protected CoAP messages are set to the same value of the unprotected CoAP message, to help the reader with comparisons.</p>
<p id="rfc.section.C.p.3">[NOTE: the following examples use option number = 9 (TBD1 assigned by IANA). If that differs, the RFC editor is asked to update the test vectors with data provided by the authors. Please remove this paragraph before publication.]</p>
<h1 id="rfc.appendix.C.1">
<a href="#rfc.appendix.C.1">C.1.</a> <a href="#key-der-tv-ms" id="key-der-tv-ms">Test Vector 1: Key Derivation with Master Salt</a>
</h1>
<p id="rfc.section.C.1.p.1">In this test vector, a Master Salt of 8 bytes is used. The default values are used for AEAD Algorithm and HKDF.</p>
<h1 id="rfc.appendix.C.1.1">
<a href="#rfc.appendix.C.1.1">C.1.1.</a> <a href="#client" id="client">Client</a>
</h1>
<p id="rfc.section.C.1.1.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Master Salt: 0x9e7ca92223786340 (8 bytes)</li>
<li>Sender ID: 0x (0 byte)</li>
<li>Recipient ID: 0x01 (1 byte)</li>
</ul>
<p id="rfc.section.C.1.1.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x8540f60a634b657910 (9 bytes)</li>
<li>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</li>
<li>info (for Common IV): 0x8540f60a6249560d (8 bytes)</li>
</ul>
<p id="rfc.section.C.1.1.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</li>
<li>Recipient Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.1.1.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
<li>recipient nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.1.2">
<a href="#rfc.appendix.C.1.2">C.1.2.</a> <a href="#server" id="server">Server</a>
</h1>
<p id="rfc.section.C.1.2.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Master Salt: 0x9e7ca92223786340 (8 bytes)</li>
<li>Sender ID: 0x01 (1 byte)</li>
<li>Recipient ID: 0x (0 byte)</li>
</ul>
<p id="rfc.section.C.1.2.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</li>
<li>info (for Recipient Key): 0x8540f60a634b657910 (9 bytes)</li>
<li>info (for Common IV): 0x8540f60a6249560d (8 bytes)</li>
</ul>
<p id="rfc.section.C.1.2.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>Recipient Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</li>
<li>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.1.2.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</li>
<li>recipient nonce: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.2">
<a href="#rfc.appendix.C.2">C.2.</a> <a href="#key-der-tv" id="key-der-tv">Test Vector 2: Key Derivation without Master Salt</a>
</h1>
<p id="rfc.section.C.2.p.1">In this test vector, the default values are used for AEAD Algorithm, HKDF, and Master Salt.</p>
<h1 id="rfc.appendix.C.2.1">
<a href="#rfc.appendix.C.2.1">C.2.1.</a> <a href="#client-1" id="client-1">Client</a>
</h1>
<p id="rfc.section.C.2.1.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Sender ID: 0x00 (1 byte)</li>
<li>Recipient ID: 0x01 (1 byte)</li>
</ul>
<p id="rfc.section.C.2.1.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x854100f60a634b657910 (10 bytes)</li>
<li>info (for Recipient Key): 0x854101f60a634b657910 (10 bytes)</li>
<li>info (for Common IV): 0x8540f60a6249560d (8 bytes)</li>
</ul>
<p id="rfc.section.C.2.1.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</li>
<li>Recipient Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</li>
<li>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</li>
</ul>
<p id="rfc.section.C.2.1.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</li>
<li>recipient nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.2.2">
<a href="#rfc.appendix.C.2.2">C.2.2.</a> <a href="#server-1" id="server-1">Server</a>
</h1>
<p id="rfc.section.C.2.2.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Sender ID: 0x01 (1 byte)</li>
<li>Recipient ID: 0x00 (1 byte)</li>
</ul>
<p id="rfc.section.C.2.2.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x854101f60a634b657910 (10 bytes)</li>
<li>info (for Recipient Key): 0x854100f60a634b657910 (10 bytes)</li>
<li>info (for Common IV): 0x8540f60a6249560d (8 bytes)</li>
</ul>
<p id="rfc.section.C.2.2.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0xe57b5635815177cd679ab4bcec9d7dda (16 bytes)</li>
<li>Recipient Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</li>
<li>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</li>
</ul>
<p id="rfc.section.C.2.2.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0xbf35ae297d2dace810c52e99f9 (13 bytes)</li>
<li>recipient nonce: 0xbf35ae297d2dace910c52e99f9 (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.3">
<a href="#rfc.appendix.C.3">C.3.</a> <a href="#key-der-kc" id="key-der-kc">Test Vector 3: Key Derivation with ID Context</a>
</h1>
<p id="rfc.section.C.3.p.1">In this test vector, a Master Salt of 8 bytes and a ID Context of 8 bytes are used. The default values are used for AEAD Algorithm and HKDF.</p>
<h1 id="rfc.appendix.C.3.1">
<a href="#rfc.appendix.C.3.1">C.3.1.</a> <a href="#client-2" id="client-2">Client</a>
</h1>
<p id="rfc.section.C.3.1.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Master Salt: 0x9e7ca92223786340 (8 bytes)</li>
<li>Sender ID: 0x (0 byte)</li>
<li>Recipient ID: 0x01 (1 byte)</li>
<li>ID Context: 0x37cbf3210017a2d3 (8 bytes)</li>
</ul>
<p id="rfc.section.C.3.1.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</li>
<li>info (for Recipient Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</li>
<li>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</li>
</ul>
<p id="rfc.section.C.3.1.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</li>
<li>Recipient Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</li>
<li>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</li>
</ul>
<p id="rfc.section.C.3.1.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</li>
<li>recipient nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.3.2">
<a href="#rfc.appendix.C.3.2">C.3.2.</a> <a href="#server-2" id="server-2">Server</a>
</h1>
<p id="rfc.section.C.3.2.p.1">Inputs:</p>
<p></p>

<ul>
<li>Master Secret: 0x0102030405060708090a0b0c0d0e0f10 (16 bytes)</li>
<li>Master Salt: 0x9e7ca92223786340 (8 bytes)</li>
<li>Sender ID: 0x01 (1 byte)</li>
<li>Recipient ID: 0x (0 byte)</li>
<li>ID Context: 0x37cbf3210017a2d3 (8 bytes)</li>
</ul>
<p id="rfc.section.C.3.2.p.3">From the previous parameters,</p>
<p></p>

<ul>
<li>info (for Sender Key): 0x8541014837cbf3210017a2d30a634b657910 (18 bytes)</li>
<li>info (for Recipient Key): 0x85404837cbf3210017a2d30a634b657910 (17 bytes)</li>
<li>info (for Common IV): 0x85404837cbf3210017a2d30a6249560d (16 bytes)</li>
</ul>
<p id="rfc.section.C.3.2.p.5">Outputs:</p>
<p></p>

<ul>
<li>Sender Key: 0xe39a0c7c77b43f03b4b39ab9a268699f (16 bytes)</li>
<li>Recipient Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</li>
<li>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</li>
</ul>
<p id="rfc.section.C.3.2.p.7">From the previous parameters and a Partial IV equal to 0 (both for sender and recipient):</p>
<p></p>

<ul>
<li>sender nonce: 0x2da58fb85ff1b81d0b7181b85e (13 bytes)</li>
<li>recipient nonce: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</li>
</ul>
<h1 id="rfc.appendix.C.4">
<a href="#rfc.appendix.C.4">C.4.</a> <a href="#tv4" id="tv4">Test Vector 4: OSCORE Request, Client</a>
</h1>
<p id="rfc.section.C.4.p.1">This section contains a test vector for an OSCORE protected CoAP GET request using the security context derived in <a href="#key-der-tv-ms" class="xref">Appendix C.1</a>. The unprotected request only contains the Uri-Path and Uri-Host options.</p>
<p id="rfc.section.C.4.p.2">Unprotected CoAP request: 0x44015d1f00003974396c6f63616c686f737483747631 (22 bytes)</p>
<p id="rfc.section.C.4.p.3">Common Context:</p>
<p></p>

<ul>
<li>AEAD Algorithm: 10 (AES-CCM-16-64-128)</li>
<li>Key Derivation Function: HKDF SHA-256</li>
<li>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.4.p.5">Sender Context:</p>
<p></p>

<ul>
<li>Sender ID: 0x (0 byte)</li>
<li>Sender Key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</li>
<li>Sender Sequence Number: 20</li>
</ul>
<p id="rfc.section.C.4.p.7">The following COSE and cryptographic parameters are derived:</p>
<p></p>

<ul>
<li>Partial IV: 0x14 (1 byte)</li>
<li>kid: 0x (0 byte)</li>
<li>external_aad: 0x8501810a40411440 (8 bytes)</li>
<li>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</li>
<li>plaintext: 0x01b3747631 (5 bytes)</li>
<li>encryption key: 0xf0910ed7295e6ad4b54fc793154302ff (16 bytes)</li>
<li>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</li>
</ul>
<p id="rfc.section.C.4.p.9">From the previous parameter, the following is derived:</p>
<p></p>

<ul>
<li>OSCORE option value: 0x0914 (2 bytes)</li>
<li>ciphertext: 0x612f1092f1776f1c1668b3825e (13 bytes)</li>
</ul>
<p id="rfc.section.C.4.p.11">From there:</p>
<p></p>

<ul><li>Protected CoAP request (OSCORE message): 0x44025d1f00003974396c6f63616c686f7374620914ff612f1092f1776f1c1668b3825e (35 bytes)</li></ul>
<h1 id="rfc.appendix.C.5">
<a href="#rfc.appendix.C.5">C.5.</a> <a href="#tv5" id="tv5">Test Vector 5: OSCORE Request, Client</a>
</h1>
<p id="rfc.section.C.5.p.1">This section contains a test vector for an OSCORE protected CoAP GET request using the security context derived in <a href="#key-der-tv" class="xref">Appendix C.2</a>. The unprotected request only contains the Uri-Path and Uri-Host options.</p>
<p id="rfc.section.C.5.p.2">Unprotected CoAP request: 0x440171c30000b932396c6f63616c686f737483747631 (22 bytes)</p>
<p id="rfc.section.C.5.p.3">Common Context:</p>
<p></p>

<ul>
<li>AEAD Algorithm: 10 (AES-CCM-16-64-128)</li>
<li>Key Derivation Function: HKDF SHA-256</li>
<li>Common IV: 0xbe35ae297d2dace910c52e99f9 (13 bytes)</li>
</ul>
<p id="rfc.section.C.5.p.5">Sender Context:</p>
<p></p>

<ul>
<li>Sender ID: 0x00 (1 bytes)</li>
<li>Sender Key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</li>
<li>Sender Sequence Number: 20</li>
</ul>
<p id="rfc.section.C.5.p.7">The following COSE and cryptographic parameters are derived:</p>
<p></p>

<ul>
<li>Partial IV: 0x14 (1 byte)</li>
<li>kid: 0x00 (1 byte)</li>
<li>external_aad: 0x8501810a4100411440 (9 bytes)</li>
<li>AAD: 0x8368456e63727970743040498501810a4100411440 (21 bytes)</li>
<li>plaintext: 0x01b3747631 (5 bytes)</li>
<li>encryption key: 0x321b26943253c7ffb6003b0b64d74041 (16 bytes)</li>
<li>nonce: 0xbf35ae297d2dace910c52e99ed (13 bytes)</li>
</ul>
<p id="rfc.section.C.5.p.9">From the previous parameter, the following is derived:</p>
<p></p>

<ul>
<li>OSCORE option value: 0x091400 (3 bytes)</li>
<li>ciphertext: 0x4ed339a5a379b0b8bc731fffb0 (13 bytes)</li>
</ul>
<p id="rfc.section.C.5.p.11">From there:</p>
<p></p>

<ul><li>Protected CoAP request (OSCORE message): 0x440271c30000b932396c6f63616c686f737463091400ff4ed339a5a379b0b8bc731fffb0 (36 bytes)</li></ul>
<h1 id="rfc.appendix.C.6">
<a href="#rfc.appendix.C.6">C.6.</a> <a href="#tv6" id="tv6">Test Vector 6: OSCORE Request, Client</a>
</h1>
<p id="rfc.section.C.6.p.1">This section contains a test vector for an OSCORE protected CoAP GET request for an application that sets the ID Context and requires it to be sent in the request, so &#8216;kid context&#8217; is present in the protected message. This test vector uses the security context derived in <a href="#key-der-kc" class="xref">Appendix C.3</a>. The unprotected request only contains the Uri-Path and Uri-Host options.</p>
<p id="rfc.section.C.6.p.2">Unprotected CoAP request: 0x44012f8eef9bbf7a396c6f63616c686f737483747631 (22 bytes)</p>
<p id="rfc.section.C.6.p.3">Common Context:</p>
<p></p>

<ul>
<li>AEAD Algorithm: 10 (AES-CCM-16-64-128)</li>
<li>Key Derivation Function: HKDF SHA-256</li>
<li>Common IV: 0x2ca58fb85ff1b81c0b7181b85e (13 bytes)</li>
<li>ID Context: 0x37cbf3210017a2d3 (8 bytes)</li>
</ul>
<p id="rfc.section.C.6.p.5">Sender Context:</p>
<p></p>

<ul>
<li>Sender ID: 0x (0 bytes)</li>
<li>Sender Key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</li>
<li>Sender Sequence Number: 20</li>
</ul>
<p id="rfc.section.C.6.p.7">The following COSE and cryptographic parameters are derived:</p>
<p></p>

<ul>
<li>Partial IV: 0x14 (1 byte)</li>
<li>kid: 0x (0 byte)</li>
<li>kid context: 0x37cbf3210017a2d3 (8 bytes)</li>
<li>external_aad: 0x8501810a40411440 (8 bytes)</li>
<li>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</li>
<li>plaintext: 0x01b3747631 (5 bytes)</li>
<li>encryption key: 0xaf2a1300a5e95788b356336eeecd2b92 (16 bytes)</li>
<li>nonce: 0x2ca58fb85ff1b81c0b7181b84a (13 bytes)</li>
</ul>
<p id="rfc.section.C.6.p.9">From the previous parameter, the following is derived:</p>
<p></p>

<ul>
<li>OSCORE option value: 0x19140837cbf3210017a2d3 (11 bytes)</li>
<li>ciphertext: 0x72cd7273fd331ac45cffbe55c3 (13 bytes)</li>
</ul>
<p id="rfc.section.C.6.p.11">From there:</p>
<p></p>

<ul><li>Protected CoAP request (OSCORE message): 0x44022f8eef9bbf7a396c6f63616c686f73746b19140837cbf3210017a2d3ff 72cd7273fd331ac45cffbe55c3 (44 bytes)</li></ul>
<h1 id="rfc.appendix.C.7">
<a href="#rfc.appendix.C.7">C.7.</a> <a href="#tv7" id="tv7">Test Vector 7: OSCORE Response, Server</a>
</h1>
<p id="rfc.section.C.7.p.1">This section contains a test vector for an OSCORE protected 2.05 (Content) response to the request in <a href="#tv4" class="xref">Appendix C.4</a>. The unprotected response has payload &#8220;Hello World!&#8221; and no options. The protected response does not contain a &#8216;kid&#8217; nor a Partial IV. Note that some parameters are derived from the request.</p>
<p id="rfc.section.C.7.p.2">Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</p>
<p id="rfc.section.C.7.p.3">Common Context:</p>
<p></p>

<ul>
<li>AEAD Algorithm: 10 (AES-CCM-16-64-128)</li>
<li>Key Derivation Function: HKDF SHA-256</li>
<li>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.7.p.5">Sender Context:</p>
<p></p>

<ul>
<li>Sender ID: 0x01 (1 byte)</li>
<li>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>Sender Sequence Number: 0</li>
</ul>
<p id="rfc.section.C.7.p.7">The following COSE and cryptographic parameters are derived:</p>
<p></p>

<ul>
<li>external_aad: 0x8501810a40411440 (8 bytes)</li>
<li>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</li>
<li>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</li>
<li>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>nonce: 0x4622d4dd6d944168eefb549868 (13 bytes)</li>
</ul>
<p id="rfc.section.C.7.p.9">From the previous parameter, the following is derived:</p>
<p></p>

<ul>
<li>OSCORE option value: 0x (0 bytes)</li>
<li>ciphertext: 0xdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (22 bytes)</li>
</ul>
<p id="rfc.section.C.7.p.11">From there:</p>
<p></p>

<ul><li>Protected CoAP response (OSCORE message): 0x64445d1f0000397490ffdbaad1e9a7e7b2a813d3c31524378303cdafae119106 (32 bytes)</li></ul>
<h1 id="rfc.appendix.C.8">
<a href="#rfc.appendix.C.8">C.8.</a> <a href="#tv8" id="tv8">Test Vector 8: OSCORE Response with Partial IV, Server</a>
</h1>
<p id="rfc.section.C.8.p.1">This section contains a test vector for an OSCORE protected 2.05 (Content) response to the request in <a href="#tv4" class="xref">Appendix C.4</a>. The unprotected response has payload &#8220;Hello World!&#8221; and no options. The protected response does not contain a &#8216;kid&#8217;, but contains a  Partial IV. Note that some parameters are derived from the request.</p>
<p id="rfc.section.C.8.p.2">Unprotected CoAP response: 0x64455d1f00003974ff48656c6c6f20576f726c6421 (21 bytes)</p>
<p id="rfc.section.C.8.p.3">Common Context:</p>
<p></p>

<ul>
<li>AEAD Algorithm: 10 (AES-CCM-16-64-128)</li>
<li>Key Derivation Function: HKDF SHA-256</li>
<li>Common IV: 0x4622d4dd6d944168eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.8.p.5">Sender Context:</p>
<p></p>

<ul>
<li>Sender ID: 0x01 (1 byte)</li>
<li>Sender Key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>Sender Sequence Number: 0</li>
</ul>
<p id="rfc.section.C.8.p.7">The following COSE and cryptographic parameters are derived:</p>
<p></p>

<ul>
<li>Partial IV: 0x00 (1 byte)</li>
<li>external_aad: 0x8501810a40411440 (8 bytes)</li>
<li>AAD: 0x8368456e63727970743040488501810a40411440 (20 bytes)</li>
<li>plaintext: 0x45ff48656c6c6f20576f726c6421 (14 bytes)</li>
<li>encryption key: 0xffb14e093c94c9cac9471648b4f98710 (16 bytes)</li>
<li>nonce: 0x4722d4dd6d944169eefb54987c (13 bytes)</li>
</ul>
<p id="rfc.section.C.8.p.9">From the previous parameter, the following is derived:</p>
<p></p>

<ul>
<li>OSCORE option value: 0x0100 (2 bytes)</li>
<li>ciphertext: 0x4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (22 bytes)</li>
</ul>
<p id="rfc.section.C.8.p.11">From there:</p>
<p></p>

<ul><li>Protected CoAP response (OSCORE message): 0x64445d1f00003974920100ff4d4c13669384b67354b2b6175ff4b8658c666a6cf88e (34 bytes)</li></ul>
<h1 id="rfc.appendix.D">
<a href="#rfc.appendix.D">Appendix D.</a> <a href="#overview-sec-properties" id="overview-sec-properties">Overview of Security Properties</a>
</h1>
<h1 id="rfc.appendix.D.1">
<a href="#rfc.appendix.D.1">D.1.</a> <a href="#threat-model" id="threat-model">Threat Model</a>
</h1>
<p id="rfc.section.D.1.p.1">This section describes the threat model using the terms of <a href="#RFC3552" class="xref">[RFC3552]</a>.</p>
<p id="rfc.section.D.1.p.2">It is assumed that the endpoints running OSCORE have not themselves been compromised. The attacker is assumed to have control of the CoAP channel over which the endpoints communicate, including intermediary nodes. The attacker is capable of launching any passive or active, on-path or off-path attacks; including eavesdropping, traffic analysis, spoofing, insertion, modification, deletion, delay, replay, man-in-the-middle, and denial-of-service attacks. This means that the attacker can read any CoAP message on the network and undetectably remove, change, or inject forged messages onto the wire.</p>
<p id="rfc.section.D.1.p.3">OSCORE targets the protection of the CoAP request/response layer (Section 2 of <a href="#RFC7252" class="xref">[RFC7252]</a>) between the endpoints, including the CoAP Payload, Code, Uri-Path/Uri-Query, and the other Class E option instances (<a href="#coap-options" class="xref">Section 4.1</a>).</p>
<p id="rfc.section.D.1.p.4">OSCORE does not protect the CoAP messaging layer (Section 2 of <a href="#RFC7252" class="xref">[RFC7252]</a>) or other lower layers involved in routing and transporting the CoAP requests and responses.</p>
<p id="rfc.section.D.1.p.5">Additionally, OSCORE does not protect Class U option instances (<a href="#coap-options" class="xref">Section 4.1</a>), as these are used to support CoAP forward proxy operations (see Section 5.7.2 of <a href="#RFC7252" class="xref">[RFC7252]</a>). The supported proxies (forwarding, cross-protocol e.g. CoAP to CoAP-mappable protocols such as HTTP) must be able to change certain Class U options (by instruction from the Client), resulting in the CoAP request being redirected to the server. Changes caused by the proxy may result in the request not reaching the server or reaching the wrong server. For cross-protocol proxies, mappings are done on the Outer part of the message so these protocols are essentially used as transport. Manipulation of these options may thus impact whether the protected message reaches or does not reach the destination endpoint.</p>
<p id="rfc.section.D.1.p.6">Attacks on unprotected CoAP message fields generally causes denial-of-service attacks which are out of scope of this document, more details are given in <a href="#unprot-fields" class="xref">Appendix D.5</a>.</p>
<p id="rfc.section.D.1.p.7">Attacks against the CoAP request-response layer are in scope. OSCORE is intended to protect against eavesdropping, spoofing, insertion, modification, deletion, replay, and man-in-the middle attacks.</p>
<p id="rfc.section.D.1.p.8">OSCORE is susceptible to traffic analysis as discussed later in <a href="#overview-sec-properties" class="xref">Appendix D</a>.</p>
<h1 id="rfc.appendix.D.2">
<a href="#rfc.appendix.D.2">D.2.</a> <a href="#supp-proxy-op" id="supp-proxy-op">Supporting Proxy Operations</a>
</h1>
<p id="rfc.section.D.2.p.1">CoAP is designed to work with intermediaries reading and/or changing CoAP message fields to perform supporting operations in constrained environments, e.g. forwarding and cross-protocol translations.</p>
<p id="rfc.section.D.2.p.2">Securing CoAP on transport layer protects the entire message between the endpoints in which case CoAP proxy operations are not possible. In order to enable proxy operations, security on transport layer needs to be terminated at the proxy in which case the CoAP message in its entirety is unprotected in the proxy.</p>
<p id="rfc.section.D.2.p.3">Requirements for CoAP end-to-end security are specified in <a href="#I-D.hartke-core-e2e-security-reqs" class="xref">[I-D.hartke-core-e2e-security-reqs]</a>, in particular forwarding is detailed in Section 2.2.1. The client and server are assumed to be honest, while proxies and gateways are only trusted to perform their intended operations.</p>
<p id="rfc.section.D.2.p.4">By working at the CoAP layer, OSCORE enables different CoAP message fields to be protected differently, which allows message fields required for proxy operations to be available to the proxy while message fields intended for the other endpoint remain protected. In the remainder of this section we analyze how OSCORE protects the protected message fields and the consequences of message fields intended for proxy operation being unprotected.</p>
<h1 id="rfc.appendix.D.3">
<a href="#rfc.appendix.D.3">D.3.</a> <a href="#prot-message-fields" id="prot-message-fields">Protected Message Fields</a>
</h1>
<p id="rfc.section.D.3.p.1">Protected message fields are included in the Plaintext (<a href="#plaintext" class="xref">Section 5.3</a>) and the Additional Authenticated Data (<a href="#AAD" class="xref">Section 5.4</a>) of the COSE_Encrypt0 object and encrypted using an AEAD algorithm.</p>
<p id="rfc.section.D.3.p.2">OSCORE depends on a pre-established random Master Secret (<a href="#master-secret" class="xref">Section 12.3</a>) used to derive encryption keys, and a construction for making (key, nonce) pairs unique (<a href="#kn-uniqueness" class="xref">Appendix D.4</a>). Assuming this is true, and the keys are used for no more data than indicated in <a href="#max-seq" class="xref">Section 7.2.1</a>, OSCORE should provide the following guarantees:</p>
<p></p>

<ul>
<li>Confidentiality: An attacker should not be able to determine the plaintext contents of a given OSCORE message or determine that different plaintexts are related (<a href="#plaintext" class="xref">Section 5.3</a>).</li>
<li>Integrity: An attacker should not be able to craft a new OSCORE message with protected message fields different from an existing OSCORE message which will be accepted by the receiver.</li>
<li>Request-response binding: An attacker should not be able to make a client match a response to the wrong request.</li>
<li>Non-replayability: An attacker should not be able to cause the receiver to accept a message which it has previously received and accepted.</li>
</ul>
<p id="rfc.section.D.3.p.4">In the above, the attacker is anyone except the endpoints, e.g. a compromised intermediary. Informally, OSCORE provides these properties by AEAD-protecting the plaintext with a strong key and uniqueness of (key, nonce) pairs. AEAD encryption <a href="#RFC5116" class="xref">[RFC5116]</a> provides confidentiality and integrity for the data. Response-request binding is provided by including the &#8216;kid&#8217; and Partial IV of the request in the AAD of the response. Non-replayability of requests and notifications is provided by using unique (key, nonce) pairs and a replay protection mechanism (application dependent, see <a href="#replay-protection" class="xref">Section 7.4</a>).</p>
<p id="rfc.section.D.3.p.5">OSCORE is susceptible to a variety of traffic analysis attacks based on observing the length and timing of encrypted packets. OSCORE does not provide any specific defenses against this form of attack but the application may use a padding mechanism to prevent an attacker from directly determine the length of the padding. However, information about padding may still be revealed by side-channel attacks observing differences in timing.</p>
<h1 id="rfc.appendix.D.4">
<a href="#rfc.appendix.D.4">D.4.</a> <a href="#kn-uniqueness" id="kn-uniqueness">Uniqueness of (key, nonce)</a>
</h1>
<p id="rfc.section.D.4.p.1">In this section we show that (key, nonce) pairs are unique as long as the requirements in Sections <a href="#req-params" class="xref">3.3</a> and <a href="#max-seq" class="xref">7.2.1</a> are followed.</p>
<p id="rfc.section.D.4.p.2">Fix a Common Context (<a href="#context-definition" class="xref">Section 3.1</a>) and an endpoint, called the encrypting endpoint. An endpoint may alternate between client and server roles, but each endpoint always encrypts with the Sender Key of its Sender Context. Sender Keys are (stochastically) unique since they are derived with HKDF using unique Sender IDs, so messages encrypted by different endpoints use different keys. It remains to prove that the nonces used by the fixed endpoint are unique.</p>
<p id="rfc.section.D.4.p.3">Since the Common IV is fixed, the nonces are determined by a Partial IV (PIV) and the Sender ID of the endpoint generating that Partial IV (ID_PIV). The nonce construction (<a href="#nonce" class="xref">Section 5.2</a>) with the size of the ID_PIV (S) creates unique nonces for different (ID_PIV, PIV) pairs. There are two cases:</p>
<p id="rfc.section.D.4.p.4">A. For requests, and responses with Partial IV (e.g. Observe notifications):</p>
<p></p>

<ul>
<li>ID_PIV = Sender ID of the encrypting endpoint</li>
<li>PIV = current Partial IV of the encrypting endpoint</li>
</ul>
<p id="rfc.section.D.4.p.6">Since the encrypting endpoint steps the Partial IV for each use, the nonces used in case A are all unique as long as the number of encrypted messages is kept within the required range (<a href="#max-seq" class="xref">Section 7.2.1</a>).</p>
<p id="rfc.section.D.4.p.7">B. For responses without Partial IV (e.g. single response to a request):</p>
<p></p>

<ul>
<li>ID_PIV = Sender ID of the endpoint generating the request</li>
<li>PIV = Partial IV of the request</li>
</ul>
<p id="rfc.section.D.4.p.9">Since the Sender IDs are unique, ID_PIV is different from the Sender ID of the encrypting endpoint. Therefore, the nonces in case B are different compared to nonces in case A, where the encrypting endpoint generated the Partial IV. Since the Partial IV of the request is verified for replay (<a href="#replay-protection" class="xref">Section 7.4</a>) associated to this Recipient Context, PIV is unique for this ID_PIV, which makes all nonces in case B distinct.</p>
<h1 id="rfc.appendix.D.5">
<a href="#rfc.appendix.D.5">D.5.</a> <a href="#unprot-fields" id="unprot-fields">Unprotected Message Fields</a>
</h1>
<p id="rfc.section.D.5.p.1">This sections analyses attacks on message fields which are not protected by OSCORE according to the threat model <a href="#threat-model" class="xref">Appendix D.1</a>.</p>
<h1 id="rfc.appendix.D.5.1">
<a href="#rfc.appendix.D.5.1">D.5.1.</a> <a href="#sec-coap-headers" id="sec-coap-headers">CoAP Header Fields</a>
</h1>
<p></p>

<ul>
<li>Version. The CoAP version <a href="#RFC7252" class="xref">[RFC7252]</a> is not expected to be sensitive to disclose. Currently there is only one CoAP version defined. A change of this parameter is potentially a denial-of-service attack. Future versions of CoAP need to analyze attacks to OSCORE protected messages due to an adversary changing the CoAP version.</li>
<li>Token/Token Length. The Token field is a client-local identifier for differentiating between concurrent requests <a href="#RFC7252" class="xref">[RFC7252]</a>. CoAP proxies are allowed to read and change Token and Token Length between hops. An eavesdropper reading the Token can match requests to responses which can be used in traffic analysis. In particular this is true for notifications, where multiple responses are matched with one request. Modifications of Token and Token Length by an on-path attacker may become a denial-of-service attack, since it may prevent the client to identify to which request the response belongs or to find the correct information to verify integrity of the response.</li>
<li>Code. The Outer CoAP Code of an OSCORE message is POST or FETCH for requests with corresponding response codes. An endpoint receiving the message discards the Outer CoAP Code and uses the Inner CoAP Code instead (see <a href="#coap-header" class="xref">Section 4.2</a>). Hence, modifications from attackers to the Outer Code do not impact the receiving endpoint. However, changing the Outer Code from FETCH to a Code value for a method that does not work with Observe (such as POST) may, depending on proxy implementation since Observe is undefined for several Codes, cause the proxy to not forward notifications, which is a denial-of-service attack. The use of FETCH rather than POST reveals no more than what is revealed by the presence of the Outer Observe option.</li>
<li>Type/Message ID. The Type/Message ID fields <a href="#RFC7252" class="xref">[RFC7252]</a> reveal information about the UDP transport binding, e.g. an eavesdropper reading the Type or Message ID gain information about how UDP messages are related to each other. CoAP proxies are allowed to change Type and Message ID. These message fields are not present in CoAP over TCP <a href="#RFC8323" class="xref">[RFC8323]</a>, and does not impact the request/response message. A change of these fields in a UDP hop is a denial-of-service attack. By sending an ACK, an attacker can make the endpoint believe that it does not need to retransmit the previous message. By sending a RST, an attacker may be able to cancel an observation. By changing a NON to a CON, the attacker can cause the receiving endpoint to ACK messages for which no ACK was requested.</li>
<li>Length. This field contain the length of the message <a href="#RFC8323" class="xref">[RFC8323]</a> which may be used for traffic analysis. These message fields are not present in CoAP over UDP, and does not impact the request/response message. A change of Length is a denial-of-service attack similar to changing TCP header fields.</li>
</ul>
<h1 id="rfc.appendix.D.5.2">
<a href="#rfc.appendix.D.5.2">D.5.2.</a> <a href="#sec-coap-options" id="sec-coap-options">CoAP Options</a>
</h1>
<p></p>

<ul>
<li>Max-Age. The Outer Max-Age is set to zero to avoid unnecessary caching of OSCORE error responses. Changing this value thus may cause unnecessary caching. No additional information is carried with this option.</li>
<li>Proxy-Uri/Proxy-Scheme. These options are used in CoAP forward proxy deployments. With OSCORE, the Proxy-Uri option does not contain the Uri-Path/Uri-Query parts of the URI. The other parts of Proxy-Uri cannot be protected because forward proxies need to change them in order to perform their functions. The server can verify what scheme is used in the last hop, but not what was requested by the client or what was used in previous hops.</li>
<li>Uri-Host/Uri-Port. In forward proxy deployments, the Uri-Host/Uri-Port may be changed by an adversary, and the application needs to handle the consequences of that (see <a href="#uri-host" class="xref">Section 4.1.3.2</a>).  The Uri-Host may either be omitted, reveal information equivalent to that of the IP address or more privacy-sensitive information, which is discouraged.</li>
<li>Observe. The Outer Observe option is intended for a proxy to support forwarding of Observe messages, but is ignored by the endpoints since the Inner Observe determines the processing in the endpoints. Since the Partial IV provides absolute ordering of notifications it is not possible for an intermediary to spoof reordering (see <a href="#observe" class="xref">Section 4.1.3.5</a>). The absence of Partial IV, since only allowed for the first notification, does not prevent correct ordering of notifications. The size and distributions of notifications over time may reveal information about the content or nature of the notifications.  Cancellations (<a href="#observe-registration" class="xref">Section 4.1.3.5.1</a>) are not bound to the corresponding registrations in the same way responses are bound to requests in OSCORE (see <a href="#prot-message-fields" class="xref">Appendix D.3</a>), but that does not open up for attacks based on mismatched cancellations, since for cancellations to be accepted, all options in the decrypted message except for ETag Options MUST be the same (see <a href="#observe" class="xref">Section 4.1.3.5</a>).</li>
<li>Block1/Block2/Size1/Size2. The Outer Block options enables fragmentation of OSCORE messages in addition to segmentation performed by the Inner Block options. The presence of these options indicates a large message being sent and the message size can be estimated and used for traffic analysis. Manipulating these options is a potential denial-of-service attack, e.g. injection of alleged Block fragments. The specification of a maximum size of message, MAX_UNFRAGMENTED_SIZE (<a href="#outer-block-options" class="xref">Section 4.1.3.4.2</a>), above which messages will be dropped, is intended as one measure to mitigate this kind of attack.</li>
<li>No-Response. The Outer No-Response option is used to support proxy functionality, specifically to avoid error transmissions from proxies to clients, and to avoid bandwidth reduction to servers by proxies applying congestion control when not receiving responses. Modifying or introducing this option is a potential denial-of-service attack against the proxy operations, but since the option has an Inner value its use can be securely agreed between the endpoints. The presence of this option is not expected to reveal any sensitive information about the message exchange.</li>
<li>OSCORE. The OSCORE option contains information about the compressed COSE header. Changing this field may cause OSCORE verification to fail.</li>
</ul>
<h1 id="rfc.appendix.D.5.3">
<a href="#rfc.appendix.D.5.3">D.5.3.</a> <a href="#error-and-signaling-messages" id="error-and-signaling-messages">Error and Signaling Messages</a>
</h1>
<p id="rfc.section.D.5.3.p.1">Error messages occurring during CoAP processing are protected end-to-end. Error messages occurring during OSCORE processing are not always possible to protect, e.g. if the receiving endpoint cannot locate the right security context. For this setting, unprotected error messages are allowed as specified to prevent extensive retransmissions. Those error messages can be spoofed or manipulated, which is a potential denial-of-service attack.</p>
<p id="rfc.section.D.5.3.p.2">This document specifies OPTIONAL error codes and specific diagnostic payloads for OSCORE processing error messages. Such messages might reveal information about how many and which security contexts exist on the server. Servers MAY want to omit the diagnostic payload of error messages, use the same error code for all errors, or avoid responding altogether in case of OSCORE processing errors, if that is a security concern for the application. Moreover, clients MUST NOT rely on the error code or the diagnostic payload to trigger specific actions, as these errors are unprotected and can be spoofed or manipulated.</p>
<p id="rfc.section.D.5.3.p.3">Signaling messages used in CoAP over TCP <a href="#RFC8323" class="xref">[RFC8323]</a> are intended to be hop-by-hop; spoofing signaling messages can be used as a denial-of-service attack of a TCP connection.</p>
<h1 id="rfc.appendix.D.5.4">
<a href="#rfc.appendix.D.5.4">D.5.4.</a> <a href="#http-message-fields" id="http-message-fields">HTTP Message Fields</a>
</h1>
<p id="rfc.section.D.5.4.p.1">In contrast to CoAP, where OSCORE does not protect header fields to enable CoAP-CoAP proxy operations, the use of OSCORE with HTTP is restricted to transporting a protected CoAP message over an HTTP hop. Any unprotected HTTP message fields may reveal information about the transport of the OSCORE message and enable various denial-of-service attacks.  It is RECOMMENDED to additionally use TLS <a href="#RFC8446" class="xref">[RFC8446]</a> for HTTP hops, which enables encryption and integrity protection of headers, but still leaves some information for traffic analysis.</p>
<h1 id="rfc.appendix.E">
<a href="#rfc.appendix.E">Appendix E.</a> <a href="#cddl-sum" id="cddl-sum">CDDL Summary</a>
</h1>
<p id="rfc.section.E.p.1">Data structure definitions in the present specification employ the CDDL language for conciseness and precision.  CDDL is defined in <a href="#I-D.ietf-cbor-cddl" class="xref">[I-D.ietf-cbor-cddl]</a>, which at the time of writing this appendix is in the process of completion.  As the document is not yet available for a normative reference, the present appendix defines the small subset of CDDL that is being used in the present specification.</p>
<p id="rfc.section.E.p.2">Within the subset being used here, a CDDL rule is of the form <samp>name = type</samp>, where <samp>name</samp> is the name given to the <samp>type</samp>.  A <samp>type</samp> can be one of:</p>
<p></p>

<ul>
<li>a reference to another named type, by giving its name.  The predefined named types used in the present specification are: <samp>uint</samp>, an unsigned integer (as represented in CBOR by major type 0); <samp>int</samp>, an unsigned or negative integer (as represented in CBOR by major type 0 or 1); <samp>bstr</samp>, a byte string (as represented in CBOR by major type 2); <samp>tstr</samp>, a text string (as represented in CBOR by major type 3);</li>
<li>a choice between two types, by giving both types separated by a <samp>/</samp>;</li>
<li>an array type (as represented in CBOR by major type 4), where the sequence of elements of the array is described by giving a sequence of entries separated by commas <samp>,</samp>, and this sequence is enclosed by square brackets <samp>[</samp> and <samp>]</samp>.  Arrays described by an array description contain elements that correspond one-to-one to the sequence of entries given.  Each entry of an array description is of the form <samp>name : type</samp>, where <samp>name</samp> is the name given to the entry and <samp>type</samp> is the type of the array element corresponding to this entry.</li>
</ul>
<h1 id="rfc.acknowledgments"><a href="#rfc.acknowledgments">Acknowledgments</a></h1>
<p id="rfc.section.F.p.1">The following individuals provided input to this document: Christian Ams&#252;ss, Tobias Andersson, Carsten Bormann, Joakim Brorsson, Ben Campbell, Esko Dijk, Jaro Fietz, Thomas Fossati, Martin Gunnarsson, Klaus Hartke, Mirja K&#252;hlewind, Kathleen Moriarty, Eric Rescorla, Michael Richardson, Adam Roach, Jim Schaad, Peter van der Stok, Dave Thaler, Martin Thomson, Marco Tiloca, William Vignat, and Mali&#353;a Vucinic.</p>
<p id="rfc.section.F.p.2">Ludwig Seitz and G&#246;ran Selander worked on this document as part of the CelticPlus project CyberWI, with funding from Vinnova.</p>
<h1 id="rfc.authors"><a href="#rfc.authors">Authors' Addresses</a></h1>
<div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">G&#246;ran Selander</span> 
	  <span class="n hidden">
		<span class="family-name">Selander</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:goran.selander@ericsson.com">goran.selander@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">John Mattsson</span> 
	  <span class="n hidden">
		<span class="family-name">Mattsson</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:john.mattsson@ericsson.com">john.mattsson@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Francesca Palombini</span> 
	  <span class="n hidden">
		<span class="family-name">Palombini</span>
	  </span>
	</span>
	<span class="org vcardline">Ericsson AB</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:francesca.palombini@ericsson.com">francesca.palombini@ericsson.com</a></span>

  </address>
</div><div class="avoidbreak">
  <address class="vcard">
	<span class="vcardline">
	  <span class="fn">Ludwig Seitz</span> 
	  <span class="n hidden">
		<span class="family-name">Seitz</span>
	  </span>
	</span>
	<span class="org vcardline">RISE SICS</span>
	<span class="adr">
	  
	  <span class="vcardline">
		<span class="locality"></span> 
		<span class="region"></span>
		<span class="code"></span>
	  </span>
	  <span class="country-name vcardline"></span>
	</span>
	<span class="vcardline">EMail: <a href="mailto:ludwig.seitz@ri.se">ludwig.seitz@ri.se</a></span>

  </address>
</div>

</body>
</html>

