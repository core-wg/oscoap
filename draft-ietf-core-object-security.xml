<?xml version="1.0" encoding="us-ascii"?>
  <?xml-stylesheet type="text/xsl" href="rfc2629.xslt" ?>
  <!-- generated by https://github.com/cabo/kramdown-rfc2629 version 1.0.30 -->

<!DOCTYPE rfc SYSTEM "rfc2629.dtd" [
<!ENTITY I-D.ietf-cose-msg SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-cose-msg.xml">
<!ENTITY RFC2119 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.2119.xml">
<!ENTITY RFC6347 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.6347.xml">
<!ENTITY RFC7252 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7252.xml">
<!ENTITY RFC7641 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7641.xml">
<!ENTITY RFC7959 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7959.xml">
<!ENTITY RFC3986 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.3986.xml">
<!ENTITY RFC7049 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7049.xml">
<!ENTITY I-D.selander-ace-cose-ecdhe SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.selander-ace-cose-ecdhe.xml">
<!ENTITY I-D.hartke-core-e2e-security-reqs SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.hartke-core-e2e-security-reqs.xml">
<!ENTITY I-D.mattsson-core-coap-actuators SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.mattsson-core-coap-actuators.xml">
<!ENTITY I-D.bormann-6lo-coap-802-15-ie SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.bormann-6lo-coap-802-15-ie.xml">
<!ENTITY I-D.ietf-ace-oauth-authz SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-ace-oauth-authz.xml">
<!ENTITY I-D.seitz-ace-oscoap-profile SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.seitz-ace-oscoap-profile.xml">
<!ENTITY I-D.ietf-core-coap-tcp-tls SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.ietf-core-coap-tcp-tls.xml">
<!ENTITY I-D.greevenbosch-appsawg-cbor-cddl SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml3/reference.I-D.greevenbosch-appsawg-cbor-cddl.xml">
<!ENTITY RFC4303 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.4303.xml">
<!ENTITY RFC5869 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.5869.xml">
<!ENTITY RFC7228 SYSTEM "https://xml2rfc.tools.ietf.org/public/rfc/bibxml/reference.RFC.7228.xml">
]>

<?rfc toc="yes"?>
<?rfc softrefs="yes"?>
<?rfc symrefs="yes"?>

<rfc ipr="trust200902" docName="draft-ietf-core-object-security-latest" category="std">

  <front>
    <title>Object Security of CoAP (OSCOAP)</title>

    <author initials="G." surname="Selander" fullname="Goeran Selander">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street>Farogatan 6</street>
          <city>Kista</city>
          <code>SE-16480 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>goran.selander@ericsson.com</email>
      </address>
    </author>
    <author initials="J." surname="Mattsson" fullname="John Mattsson">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street>Farogatan 6</street>
          <city>Kista</city>
          <code>SE-16480 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>john.mattsson@ericsson.com</email>
      </address>
    </author>
    <author initials="F." surname="Palombini" fullname="Francesca Palombini">
      <organization>Ericsson AB</organization>
      <address>
        <postal>
          <street>Farogatan 6</street>
          <city>Kista</city>
          <code>SE-16480 Stockholm</code>
          <country>Sweden</country>
        </postal>
        <email>francesca.palombini@ericsson.com</email>
      </address>
    </author>
    <author initials="L." surname="Seitz" fullname="Ludwig Seitz">
      <organization>SICS Swedish ICT</organization>
      <address>
        <postal>
          <street>Scheelevagen 17</street>
          <city>Lund</city>
          <code>22370</code>
          <country>Sweden</country>
        </postal>
        <email>ludwig@sics.se</email>
      </address>
    </author>

    <date year="2017" month="January" day="09"/>

    
    <workgroup>CoRE Working Group</workgroup>
    <keyword>Internet-Draft</keyword>

    <abstract>


<t>This memo defines Object Security of CoAP (OSCOAP), a method for application layer protection of message exchanges with the Constrained Application Protocol (CoAP), using the CBOR Object Signing and Encryption (COSE) format. OSCOAP provides end-to-end encryption, integrity and replay protection to CoAP payload, options, and header fields, as well as a secure binding between CoAP request and response messages. The use of OSCOAP is signaled with the CoAP option Object-Security, also defined in this memo.</t>



    </abstract>


  </front>

  <middle>


<section anchor="intro" title="Introduction">

<t>The Constrained Application Protocol (CoAP) <xref target="RFC7252"/> is a web application protocol, designed for constrained nodes and networks <xref target="RFC7228"/>. CoAP specifies the use of proxies for scalability and efficiency. At the same time CoAP references DTLS <xref target="RFC6347"/> for security. Proxy operations on CoAP messages require DTLS to be terminated at the proxy. The proxy therefore not only has access to the data required for performing the intended proxy functionality, but is also able to eavesdrop on, or manipulate any part of the CoAP payload and metadata, in transit between client and server. The proxy can also inject, delete, or reorder packages without being protected or detected by DTLS.</t>

<t>This memo defines Object Security of CoAP (OSCOAP), a data object based security protocol, protecting CoAP message exchanges end-to-end, across intermediary nodes. An analysis of end-to-end security for CoAP messages through intermediary nodes is performed in <xref target="I-D.hartke-core-e2e-security-reqs"/>, this specification addresses the forwarding case.</t>

<t>The solution provides an in-layer security protocol for CoAP which does not depend on underlying layers and is therefore favorable for providing security for &ldquo;CoAP over foo&rdquo;, e.g. CoAP messages passing over both unreliable and reliable transport <xref target="I-D.ietf-core-coap-tcp-tls"/>, CoAP over IEEE 802.15.4 IE <xref target="I-D.bormann-6lo-coap-802-15-ie"/>.</t>

<t>OSCOAP builds on CBOR Object Signing and Encryption (COSE) <xref target="I-D.ietf-cose-msg"/>, providing end-to-end encryption, integrity, and replay protection. The use of OSCOAP is signaled with the CoAP option Object-Security, also defined in this memo. The solution transforms an unprotected CoAP message into a protected CoAP message in the following way: the unprotected CoAP message is protected by including payload (if present), certain options, and header fields in a COSE object. The message fields that have been encrypted are removed from the message whereas the Object-Security option and the COSE object are added. We call the result the &ldquo;protected&rdquo; CoAP message. Thus OSCOAP is a security protocol based on the exchange of protected CoAP messages (see <xref target="oscoap-ex"/>).</t>

<figure title="Sketch of OSCOAP" anchor="oscoap-ex"><artwork align="center"><![CDATA[
Client                                           Server
   |  request:                                     |
   |    GET example.com                            |
   |    [Header, Token, Options:{...,              |
   |     Object-Security:COSE object}]             |
   +---------------------------------------------->|
   |  response:                                    |
   |    2.05 (Content)                             |
   |    [Header, Token, Options:{...,              |
   |     Object-Security:-}, Payload:COSE object]  |
   |<----------------------------------------------+
   |                                               |
]]></artwork></figure>

<t>OSCOAP provides protection of CoAP payload, certain options, and header fields, as well as a secure binding between CoAP request and response messages. OSCOAP provides replay protection, but like DTLS, OSCOAP only provides relative freshness in the sense that the sequence numbers allows a recipient to determine the relative order of messages. For applications having stronger demands on freshness (e.g. control of actuators), OSCOAP needs to be augmented with mechanisms providing absolute freshness <xref target="I-D.mattsson-core-coap-actuators"/>.</t>

<t>OSCOAP may be used in extremely constrained settings, where DTLS cannot be supported. Alternatively, OSCOAP can be combined with DTLS, thereby enabling end-to-end security of CoAP payload, in combination with hop-by-hop protection of the entire CoAP message, during transport between end-point and intermediary node. Examples of the use of OSCOAP are given in <xref target="appendix-d"/>.</t>

<t>The message protection provided by OSCOAP can alternatively be applied only to the payload of individual messages. We call this object security of content (OSCON) and it is defined in <xref target="mode-payl"/>.</t>

<section anchor="terminology" title="Terminology">

<t>The key words &ldquo;MUST&rdquo;, &ldquo;MUST NOT&rdquo;, &ldquo;REQUIRED&rdquo;, &ldquo;SHALL&rdquo;, &ldquo;SHALL NOT&rdquo;, &ldquo;SHOULD&rdquo;, &ldquo;SHOULD NOT&rdquo;, &ldquo;RECOMMENDED&rdquo;, &ldquo;MAY&rdquo;, and &ldquo;OPTIONAL&rdquo; in this document are to be interpreted as described in <xref target="RFC2119"/>. These words may also appear in this document in lowercase, absent their normative meanings.</t>

<t>Readers are expected to be familiar with the terms and concepts described in <xref target="RFC7252"/> and <xref target="RFC7641"/>. Readers are also expected to be familiar with <xref target="RFC7049"/> and understand <xref target="I-D.greevenbosch-appsawg-cbor-cddl"/>. Terminology for constrained environments, such as &ldquo;constrained device&rdquo;, &ldquo;constrained-node network&rdquo;, is defined in <xref target="RFC7228"/>.</t>

</section>
</section>
<section anchor="obj-sec-option-section" title="The Object-Security Option">

<t>The Object-Security option indicates that OSCOAP is used to protect the CoAP message exchange. The protection is achieved by means of a COSE object included in the protected CoAP message, as detailed in <xref target="sec-obj-cose"/>.</t>

<t>The Object-Security option is critical, safe to forward, part of the cache key, and not repeatable. <xref target="obj-sec-option"/> illustrates the structure of the Object-Security option.</t>

<t>A CoAP proxy SHOULD NOT cache a response to a request with an Object-Security option, since the response is only applicable to the original client&rsquo;s request. The Object-Security option is included in the cache key for backward compatibility with proxies not recognizing the Object-Security option.  The effect of this is that messages with the Object-Security option will never generate cache hits. To further prevent caching, a Max-Age option with value zero SHOULD be added to the protected CoAP responses.</t>

<figure title="The Object-Security Option" anchor="obj-sec-option"><artwork align="center"><![CDATA[
+-----+---+---+---+---+-----------------+--------+--------+
| No. | C | U | N | R | Name            | Format | Length |
+-----+---+---+---+---+-----------------+--------+--------|
| TBD | x |   |   |   | Object-Security | opaque | 0-     |
+-----+---+---+---+---+-----------------+--------+--------+
     C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable
]]></artwork></figure>

<t>The length of the Object-Security option depends on whether the unprotected message allows payload, on the set of options that are included in the unprotected message, the length of the integrity tag, and the length of the information identifying the security context.</t>

<t><list style="symbols">
  <t>If the unprotected message allows payload, then the COSE object is the payload of the protected message (see <xref target="protected-coap-formatting-req"/> and <xref target="protected-coap-formatting-resp"/>), and the Object-Security option has length zero. An endpoint receiving a CoAP message with payload, that also contains a non-empty Object-Security option SHALL treat it as malformed and reject it.</t>
  <t>If the unprotected message does not allow payload, then the COSE object is the value of the Object-Security option and the length of the Object-Security option is equal to the size of the COSE object. An endpoint receiving a CoAP message without payload, that also contains an empty Object-Security option SHALL treat it as malformed and reject it.</t>
</list></t>

<t>Note that according to <xref target="RFC7252"/>, new Methods and Response Codes should specify if the payload is optional, required or not allowed (Section 12.1.2) in the message, and in case this is not defined the sender must not include a payload (Section 5.5). Thus, in this case, the COSE object MUST be the value of the Object-Security option.</t>

<t>More details about the message overhead caused by the Object-Security option are given in <xref target="appendix-a"/>.</t>

</section>
<section anchor="sec-context-section" title="The Security Context">

<t>OSCOAP uses COSE with an Authenticated Encryption with Additional Data (AEAD) algorithm. The specification requires that client and server establish a security context to apply to the COSE objects protecting the CoAP messages. In this section we define the security context, and also specify how to derive the initial security contexts in client and server based on common shared secret and a key derivation function (KDF).</t>

<section anchor="sec-context-def-section" title="Security Context Definition">

<t>The security context is the set of information elements necessary to carry out the cryptographic operations in OSCOAP. Each security context is identified by a Context Identifier. A Context Identifier that is no longer in use can be reassigned to a new security context.</t>

<t>For each endpoint, the security context is composed by a &ldquo;Common Part&rdquo;, a &ldquo;Sender Part&rdquo; and a &ldquo;Recipient Part&rdquo;. The endpoints protect messages to send using the Sender Part and verify messages received using the Recipient Part, both parts being derived from the Common part and other data. Each endpoint has a unique ID used to derive its Sender part, this identifier is called  &ldquo;Sender ID&rdquo;. The Recipient part is derived with the other endpoint&rsquo;s ID, which is called &ldquo;Recipient ID&rdquo;. The Recipient ID is thus the ID of the endpoint from which a CoAP message is received. In communication between two endpoints, the Sender part of one endpoint matches the Recipient part of the other endpoint, and vice versa. Thus the two security contexts identified by the same Context Identifiers in the two endpoints are not the same, but they are partly mirrored.  Retrieval and use of the security context are shown in <xref target="sec-context-ex"/>.  <xref target="context-example"/> shows an example of two such matching
contexts.</t>

<figure title="Retrieval and use of the Security Context" anchor="sec-context-ex"><artwork align="center"><![CDATA[
               .-Cid = Cid1-.           .-Cid = Cid1-.
               |  Common,   |           |  Common,   |
               |  Sender,   |           |  Recipient,|
               |  Recipient |           |  Sender    |
               '------------'           '------------'
                   Client                   Server
                      |                       |
Retrieve context for  | request:              |
 target resource      | [Token = Token1,      |
Protect request with  |  Cid = Cid1, ...]     |
  Sender Part         +---------------------->| Retrieve context with
                      |                       |  Cid = Cid1
                      |                       | Verify request with
                      |                       |  Recipient Part
                      | response:             | Protect response with
                      | [Token = Token1, ...] |  Sender Part
Retrieve context with |<----------------------+
 Token = Token1       |                       |
Verify request with   |                       |
 Recipient Part       |                       |
]]></artwork></figure>

<t>The Common Part contains the following parameters:</t>

<t><list style="symbols">
  <t>Context Identifier (Cid). Variable length byte string that identifies the security context. Its value is immutable once the security context is established.</t>
  <t>Algorithm (Alg). Value that identifies the COSE AEAD algorithm to use for encryption. Its value is immutable once the security context is established.</t>
  <t>Base Key (master_secret). Variable length, uniformly random byte string containing the key used to derive traffic keys and IVs. Its value is immutable once the security context is established.</t>
</list></t>

<t>The Sender Part contains the following parameters:</t>

<t><list style="symbols">
  <t>Sender ID. Variable length byte string identifying the endpoint itself. Its value is immutable once the security context is established.</t>
  <t>Sender Key. Byte string containing the symmetric key to protect messages to send. Length is determined by Algorithm. Its value is immutable once the security context is established.</t>
  <t>Sender IV. Byte string containing the fixed context IV <xref target="I-D.ietf-cose-msg"/>) to protect messages to send. Length is determined by Algorithm. Its value is immutable once the security context is established.</t>
  <t>Sender Sequence Number. Non-negative integer enumerating the COSE objects that the endpoint sends using the context. Used as partial IV <xref target="I-D.ietf-cose-msg"/> to generate unique nonces for the AEAD. Maximum value is determined by Algorithm.</t>
</list></t>

<t>The Recipient Part contains the following parameters:</t>

<t><list style="symbols">
  <t>Recipient ID. Variable length byte string identifying the endpoint messages are received from. Its value is immutable once the security context is established.</t>
  <t>Recipient Key. Byte string containing the symmetric key to verify messages received. Length is determined by the Algorithm. Its value is immutable once the security context is established.</t>
  <t>Recipient IV. Byte string containing the context IV to verify messages received. Length is determined by Algorithm. Its value is immutable once the security context is established.</t>
  <t>Recipient Replay Window. The replay protection window for messages received.  This consists of a counter representing the highest validated sequence number received and a list of the lesser sequence numbers within the
window that have been received. See section 3.4.3 of <xref target="RFC4303"/> for an efficient method to implment this.</t>
</list></t>

<t>The 3-tuple (Cid, Sender ID, Partial IV) is called Transaction Identifier (Tid), and SHALL be unique for each Base Key. The Tid is used as a unique challenge in the COSE object of the protected CoAP request. The Tid is part of the Additional Authenticated Data (AAD, see <xref target="sec-obj-cose"/>) of the protected CoAP response message, which is how responses are bound to requests.</t>

</section>
<section anchor="sec-context-est-section" title="Derivation of Security Context Parameters">

<t>This section describes how to derive the initial parameters in the security context, given a small set of input parameters. We also give indications on how applications should select the input parameters.</t>

<t>The following input parameters SHALL be pre-established:</t>

<t><list style="symbols">
  <t>Context Identifier (Cid)</t>
  <t>Base Key (master_secret)</t>
  <t>AEAD Algorithm (Alg)
  <list style="symbols">
      <t>Default is AES-CCM-64-64-128 (value 12)</t>
    </list></t>
</list></t>

<t>The following input parameters MAY be pre-established:</t>

<t><list style="symbols">
  <t>Sender ID
  <list style="symbols">
      <t>Defaults are 0x00 for the endpoint intially being client, and 0x01 for the endpoint initially being server</t>
    </list></t>
  <t>Recipient ID
  <list style="symbols">
      <t>Defaults are 0x01 for the endpoint intially being client, and 0x00 for the endpoint initially being server</t>
    </list></t>
  <t>Key Derivation Function (KDF)
  <list style="symbols">
      <t>Default is HKDF SHA-256</t>
    </list></t>
  <t>Replay Window Size
  <list style="symbols">
      <t>Default is 64</t>
    </list></t>
</list></t>

<t>The endpoints MAY interchange the CoAP client and server roles while maintaining the same security context. When this happens, the former server still protects the message to send using the Sender Part, and verifies the message received using its Recipient Part. The same is also true for the former client. The endpoints MUST NOT change the Sender/Recipient ID. In other words, changing the roles does not change the set of keys to be used.</t>

<t>The input parameters are included unchanged in the security context. From the input parameters, the following parameters are derived:</t>

<t><list style="symbols">
  <t>Sender Key, Sender IV, Sender Sequence Number</t>
  <t>Recipient Key, Recipient IV, Recipient Sequence Number</t>
</list></t>

<t>The EDHOC protocol <xref target="I-D.selander-ace-cose-ecdhe"></xref> enables the establishment of input parameters with the property of forward secrecy, and negotiation of KDF and AEAD, it thus provides all necessary pre-requisite steps for using OSCOAP as defined here.</t>

<section anchor="derivation-of-sender-keyiv-recipient-keyiv" title="Derivation of Sender Key/IV, Recipient Key/IV">

<t>Given the input parameters, the client and server can derive all the other parameters in the security context. The derivation procedure described here MUST NOT be executed more than once using the same master_secret and Cid. The same master_secret SHOULD NOT be used with more than one Cid.</t>

<t>The KDF MUST be one of the HKDF <xref target="RFC5869"/> algorithms defined in COSE. The KDF HKDF SHA-256 is mandatory to implement. The security context parameters Sender Key/IV, Recipient Key/IV SHALL be derived using HKDF, and consists of the composition of the HKDF-Extract and HKDF-Expand steps ({{RFC5869}):</t>

<figure><artwork><![CDATA[
  output parameter = HKDF(master_secret, salt, info, output_length), 
]]></artwork></figure>

<t>where:</t>

<t><list style="symbols">
  <t>master_secret is defined above</t>
  <t>salt is a string of zeros of the length of the hash function output in octets</t>
  <t>info is a serialized CBOR array consisting of:</t>
</list></t>

<figure><artwork><![CDATA[
   info = [
       cid : bstr,
       id : bstr,
       alg : int,
       out_type : tstr,
       out_len : uint
   ]

   - id is the Sender ID or Recipient ID

   - out_type is "Key" or "IV"

   - out_len is the key/IV size of the AEAD algorithm
]]></artwork></figure>

<t><list style="symbols">
  <t>output_length is the size of the AEAD key/IV in bytes encoded as an 8-bit unsigned integer</t>
</list></t>

<t>For example, if the algorithm AES-CCM-64-64-128 (see Section 10.2 in <xref target="I-D.ietf-cose-msg"/>) is used, output_length for the keys is 128 bits and output_length for the IVs is 56 bits.</t>

</section>
<section anchor="cid-est" title="Context Identifier">

<t>As mentioned, Cid is pre-established. How this is done is application specific, but it is RECOMMENDED that the application uses 64-bits long pseudo-random Cids, in order to have globally unique Context Identifiers. Cid SHOULD be unique in the sets of all security contexts used by all the endpoints. If it is not the case, it is the role of the application to specify how to handle collisions.</t>

<t>If the application has total control of both clients and servers, shorter unique Cids MAY be used. Note that Cids of different lengths can be used by different clients and that e.g. a Cid with the value 0x00 is different from the Cid with the value 0x0000.</t>

<t>In the same phase during which the Cid is established in the endpoint, the application informs the endpoint what resources can be accessed using the corresponding security contexts. Resources that are accessed with OSCOAP are called &ldquo;protected&rdquo; resources. The set of resources that can be accessed using a certain security context is decided by the application (resource, host, etc.). The client SHALL save the association resource-Cid, in order to be able to retrieve the correct security context to access a protected resource. The server SHALL save the association resource-Cid, in order to determine whether a particular resource may be accessed using a certain Cid.</t>

</section>
<section anchor="id-est" title="Sender ID and Recipient ID">

<t>The Sender ID and Recipient ID SHALL be unique in the set of all endpoints using the same security context. Collisions may lead to the loss of both confidentiality and integrity. If random IDs are used, they MUST be long enough so that the probability of collisions is negligible.</t>

</section>
<section anchor="sequence-numbers-and-replay-window" title="Sequence Numbers and Replay Window">

<t>The Sender Sequence Number is initialized to 0. The Recipient Replay Window is initiated as described in Section 4.1.2.6 of <xref target="RFC6347"/>.</t>

</section>
</section>
</section>
<section anchor="coap-headers-and-options" title="Protected CoAP Message Fields">

<t>OSCOAP transforms an unprotected CoAP message into a protected CoAP message, and vice versa. This section defines how the unprotected CoAP message fields are protected. OSCOAP protects as much of the unprotected CoAP message as possible, while still allowing forward proxy operations <xref target="I-D.hartke-core-e2e-security-reqs"/>.</t>

<t>This section also outlines how the message fields are processed and transferred, a detailed description is provided in <xref target="coap-protected-generate"/>. Message fields of the unprotected CoAP message are either transferred in the header/options part of the protected CoAP message, or in the plaintext of the COSE object. Depending on which, the location of the message field in the protected CoAP message is called &ldquo;outer&rdquo; or &ldquo;inner&rdquo;:</t>

<t><list style="symbols">
  <t>Inner message field = message field included in the plaintext of the COSE object of the protected CoAP message (see <xref target="plaintext"/>)</t>
  <t>Outer message field = message field included in the header or options part of the protected CoAP message</t>
</list></t>

<t>The inner message fields are encrypted and integrity protected by the COSE object. The outer message fields are sent in plain text but may be integrity protected by including the message field values in the AAD of the COSE object (see <xref target="AAD"/>).</t>

<t>Note that, even though the message formats are slightly different, OSCOAP complies with CoAP over unreliable transport <xref target="RFC7252"/> as well as CoAP over reliable transport <xref target="I-D.ietf-core-coap-tcp-tls"/>.</t>

<section anchor="coap-payload" title="CoAP Payload">

<t>The CoAP Payload SHALL be encrypted and integrity protected, and thus is an inner message field.</t>

<t>The sending endpoint writes the payload of the unprotected CoAP message into the plaintext of the COSE object (see <xref target="protected-coap-formatting-req"/> and <xref target="protected-coap-formatting-resp"/>).</t>

<t>The receiving endpoint verifies and decrypts the COSE object, and recreates the payload of the unprotected CoAP message (see <xref target="verif-coap-req"/> and <xref target="verif-coap-resp"/>).</t>

</section>
<section anchor="coap-header" title="CoAP Header">

<t>Many CoAP header fields are required to be read and changed during a normal message exchange or when traversing a proxy and thus cannot be protected between the endpoints, e.g. CoAP message layer fields such as Message ID.</t>

<t>The CoAP header field Code MUST be sent in plaintext to support RESTful processing, but MUST be integrity protected to prevent an intermediary from changing, e.g. from GET to DELETE.  The CoAP version number SHALL be integrity protected to prevent potential future version-based attacks. Note that while the version number is not sent in each CoAP message over reliable transport <xref target="I-D.ietf-core-coap-tcp-tls"/>, its value is known to client and server.</t>

<t>Other CoAP header fields SHALL neither be integrity protected nor encrypted. The CoAP header fields are thus outer message fields.</t>

<t>The sending endpoint SHALL copy the header fields from the unprotected CoAP message to the protected CoAP message. The receiving endpoint SHALL copy the header fields from the protected CoAP message to the unprotected CoAP message. Both sender and receiver inserts the CoAP version number and header field Code in the AAD of the COSE object (see section <xref target="AAD"/>).</t>

</section>
<section anchor="coap-options" title="CoAP Options">

<t>As with the message fields described in the previous sections, CoAP options may be encrypted and integrity protected, integrity protected only, or neither encrypted nor integrity protected.</t>

<t>Most options are encrypted and integrity protected (see <xref target="protected-coap-options"/>), and thus inner message fields. But to allow certain proxy operations, some options have outer values and require special processing. Indeed, certain options may or must have both an inner value and a potentially different outer value, where the inner value is intended for the destination endpoint and the outer value is intended for the proxy.</t>

<figure title="Protection of CoAP Options" anchor="protected-coap-options"><artwork align="center"><![CDATA[
+----+---+---+---+---+----------------+--------+--------+---+---+
| No.| C | U | N | R | Name           | Format | Length | E | A |
+----+---+---+---+---+----------------+--------+--------+---+---+
|  1 | x |   |   | x | If-Match       | opaque | 0-8    | x |   |
|  3 | x | x | - |   | Uri-Host       | string | 1-255  |   | x |
|  4 |   |   |   | x | ETag           | opaque | 1-8    | x |   |
|  5 | x |   |   |   | If-None-Match  | empty  | 0      | x |   |
|  6 |   | x | - |   | Observe        | uint   | 0-3    | * |   |
|  7 | x | x | - |   | Uri-Port       | uint   | 0-2    |   | x |
|  8 |   |   |   | x | Location-Path  | string | 0-255  | x |   |
| 11 | x | x | - | x | Uri-Path       | string | 0-255  | x |   |
| 12 |   |   |   |   | Content-Format | uint   | 0-2    | x |   |
| 14 |   | x | - |   | Max-Age        | uint   | 0-4    | * |   |
| 15 | x | x | - | x | Uri-Query      | string | 0-255  | x |   |
| 17 | x |   |   |   | Accept         | uint   | 0-2    | x |   |
| 20 |   |   |   | x | Location-Query | string | 0-255  | x |   |
| 23 | x | x | - | - | Block2         | uint   | 0-3    | * |   |
| 27 | x | x | - | - | Block1         | uint   | 0-3    | * |   |
| 28 |   |   | x |   | Size2          | unit   | 0-4    | * |   |
| 35 | x | x | - |   | Proxy-Uri      | string | 1-1034 |   | * |
| 39 | x | x | - |   | Proxy-Scheme   | string | 1-255  |   | x |
| 60 |   |   | x |   | Size1          | uint   | 0-4    | * |   |
+----+---+---+---+---+----------------+--------+--------+---+---+
      C=Critical, U=Unsafe, N=NoCacheKey, R=Repeatable,
  E=Encrypt and Integrity Protect, A=Integrity Protect, *=Special
]]></artwork></figure>

<t>A summary of how options are protected and processed is shown in <xref target="protected-coap-options"/>. The CoAP options are partitioned into two classes:</t>

<t><list style="symbols">
  <t>E - options which are encrypted and integrity protected, and</t>
  <t>A - options which are only integrity protected.</t>
</list></t>

<t>Options within each class are protected and processed in a similar way, but certain options which require special processing as described in the subsections and indicated by a '*' in <xref target="protected-coap-options"/>.</t>

<t>Unless specified otherwise, CoAP options not listed in <xref target="protected-coap-options"/> SHALL be encrypted and integrity protected and processed as class E options.</t>

<t>Specifications of new CoAP options SHOULD specify how they are processed with OSCOAP. New COAP options SHOULD be of class E and SHOULD NOT have outer options unless a forwarding proxy needs to read an option value. If a certain option is both inner and outer, the two values SHOULD NOT be the same, unless a proxy is required by specification to be able to read the end-to-end value.</t>

<section anchor="class-e" title="Class E Options">

<t>For options in class E (see <xref target="protected-coap-options"/>) the option value in the unprotected CoAP message, if present, SHALL be encrypted and integrity protected between the endpoints, and thus is not visible to or possible to change by intermediary nodes.  Hence the actions resulting from the use of such options is analogous to communicating in a protected manner with the endpoint. For example, a client using an ETag option will not be served by a proxy.</t>

<t>The sending endpoint SHALL write the class E option from the unprotected CoAP message into the plaintext of the COSE object (see <xref target="protected-coap-formatting-req"/> and <xref target="protected-coap-formatting-resp"/>).</t>

<t>Except for the special options described in the subsections, the sending endpoint SHALL NOT use the outer options of class E. However, note that an intermediary may, legimitimately or not, add, change or remove the value of an outer option.</t>

<t>Execept for the Block options <xref target="block-options"/>, the receiving endpoint SHALL discard any outer options of class E from the protected CoAP message and SHALL replace it with the value from the COSE object when present (see <xref target="verif-coap-req"/> and <xref target="verif-coap-resp"/>).</t>

<section anchor="max-Age" title="Max-Age">

<t>An inner Max-Age option is used as defined in <xref target="RFC7252"/> taking into account that it is not accessible to proxies.</t>

<t>Since OSCOAP binds CoAP responses to requests, a cached response would not be possible to use for any other request. Therefore, there SHOULD be an outer Max-Age option with value zero to prevent caching of responses (see Section 5.6.1 of <xref target="RFC7252"/>).</t>

<t>The outer Max-Age option SHALL NOT be encrypted and  SHALL NOT be integrity protected.</t>

</section>
<section anchor="observe" title="Observe">

<t>The Observe option as used here targets the requirements on forwarding of <xref target="I-D.hartke-core-e2e-security-reqs"/> (Section 2.2.1.2).</t>

<t>An inner Observe option is used between endpoints. In order for a proxy to support forwarding of notifications, there SHALL be an outer Observe option. To simplify the processing in the server, the outer option SHOULD have the same value as the inner Observe option. The outer Observe option MAY have different values than the inner, but the order of the different values is SHALL be the same as for the inner Observe option.</t>

<t>The outer Observe option SHALL neither be encrypted nor integrity protected.</t>

</section>
<section anchor="block-options" title="The Block Options">

<t>The Block options (Block1, Block2, Size1 and Size2) MAY be either only inner options, only outer options or both inner and outer options. The inner and outer options are processed independently.</t>

<t>The inner block options are used for endpoint-to-endpoint secure fragmentation of payload into blocks and protection of information about the fragmentation (block number, last block, etc.). Additionally, a proxy may arbitrarily do fragmentation operations on the protected CoAP message, adding outer block options that are not intended to be verified by any endpoint or proxy.</t>

<t>There SHALL be a security policy defining a maximum unfragmented message size for inner Block options such that messages exceeding this size SHALL be fragmented by the sending endpoint.</t>

<t>In addition to the processing defined for the inner Block options inherent to class E options, the AEAD Tag from each block SHALL be included in the calculation of the Tag for the next block (see <xref target="AAD"/>), so that each block in the order being sent can be verified as it arrives.</t>

<t>The protected CoAP message may be fragmented by the sending endpoint or proxy as defined in <xref target="RFC7959"/>, in which case the outer Block options are being used. The outer Block options SHALL neither be encrypted nor integrity protected.</t>

<t>An endpoint receiving a message with an outer Block option SHALL first process this option according to <xref target="RFC7959"/>, until all blocks of the protected CoAP message has been received, or the cumulated message size of the exceeds the maximum unfragmented message size. In the latter case the message SHALL be discarded. In the former case, the processing of the protected CoAP message continues as defined in this document (see <xref target="verif-coap-req"/> and <xref target="verif-coap-resp"/>).</t>

<t>If the unprotected CoAP message contains Block options, the receiving endpoint processes this according to {{RFC7959}.</t>

</section>
</section>
<section anchor="class-a" title="Class A Options">

<t>Options in this class are used to support forward proxy operations. Class A options SHALL only have outer values and SHALL NOT be encrypted. In order for the destination endpoint to verify the Uri, class A options SHALL be integrity protected.</t>

<t>Uri-Host, Uri-Port, Proxy-Scheme and Proxy-Uri are class A options. When Uri-Host, Uri-Port, Proxy-Scheme options are present, Proxy-Uri is not used <xref target="RFC7252"/>. Proxy-Uri is processed like the other class A options after a pre-processing step (see <xref target="proxy-uri"/>.</t>

<t>Except for Proxi-Uri, the sending endpoint SHALL copy the class A option from the unprotected CoAP message to the protected CoAP message. The class A options are inserted in the AAD of the COSE object (see unencrypted-Uri <xref target="AAD"/>).</t>

<section anchor="proxy-uri" title="Proxy-Uri">

<t>Proxy-Uri, when present, is split by OSCOAP into class A options and privacy sensitive class E options, which are processed accordingly. When Proxy-Uri is used in the unprotected CoAP message, Uri-* are not present <xref target="RFC7252"/>.</t>

<t>The sending endpoint SHALL first decompose the Proxy-Uri value of the unprotected CoAP message into the unencrypted-Uri (<xref target="AAD"/>) and Uri-Path/Query options according to section 6.4 of <xref target="RFC7252"/>.</t>

<t>Uri-Path and Uri-Query are class E options and SHALL be protected and processed as if obtained from the unprotected CoAP message, see <xref target="class-e"/>.</t>

<t>The value of the Proxy-Uri option of the protected CoAP message SHALL be replaced with unencrypted-Uri and SHALL be protected and processed as a class A option, see <xref target="class-a"/>.</t>

</section>
</section>
</section>
</section>
<section anchor="sec-obj-cose" title="The COSE Object">

<t>This section defines how to use the COSE format <xref target="I-D.ietf-cose-msg"/> to wrap and protect data in the unprotected CoAP message. OSCOAP uses the COSE_Encrypt0 structure with an Authenticated Encryption with Additional Data (AEAD) algorithm.</t>

<t>The AEAD algorithm AES-CCM-64-64-128 defined in Section 10.2 of <xref target="I-D.ietf-cose-msg"/> is mandatory to implement. For AES-CCM-64-64-128 the length of Sender Key and Recipient Key SHALL be 128 bits, the length of nonce, Sender IV, and Recipient IV SHALL be 7 bytes, and the maximum Sequence Number SHALL be 2^56-1. The nonce is constructed as described in Section 3.1 of <xref target="I-D.ietf-cose-msg"/>, i.e. by padding the Partial IV (Sequence Number) with zeroes and XORing it with the context IV (Sender IV or Recipient IV).</t>

<t>Since OSCOAP only makes use of a single COSE structure, there is no need to explicitly specify the structure, and OSCOAP uses the untagged version of the COSE_Encrypt0 structure (Section 2. of <xref target="I-D.ietf-cose-msg"/>). If the COSE object has a different structure, the recipient MUST reject the message, treating it as malformed.</t>

<t>OSCOAP introduces a new COSE Header Parameter, the Sender Identifier:</t>

<t><list style="hanging">
  <t hangText='sid:'>
  This parameter is used to identify the sender of the message. Applications MUST NOT assume that &lsquo;sid&rsquo; values are unique. This is not a security critical field. For this reason, it can be placed in the unprotected headers bucket.</t>
</list></t>

<texttable title="Additional COSE Header Parameter" anchor="sid-def">
      <ttcol align='left'>name</ttcol>
      <ttcol align='center'>label</ttcol>
      <ttcol align='center'>value type</ttcol>
      <ttcol align='left'>value registry</ttcol>
      <ttcol align='left'>description</ttcol>
      <c>sid</c>
      <c>TBD</c>
      <c>bstr</c>
      <c>&#160;</c>
      <c>Sender Identifier</c>
</texttable>

<t>We denote by Plaintext the data that is encrypted and integrity protected, and by Additional Authenticated Data (AAD) the data that is integrity protected only, in the COSE object.</t>

<t>The fields of COSE_Encrypt0 structure are defined as follows (see example in <xref target="sem-auth-enc"/>).</t>

<t><list style="symbols">
  <t>The &ldquo;Headers&rdquo; field is formed by:  <list style="symbols">
      <t>The &ldquo;protected&rdquo; field, which SHALL include:      <list style="symbols">
          <t>The &ldquo;Partial IV&rdquo; parameter. The value is set to the Sender Sequence Number. The Partial IV is a byte string (type: bstr), and SHOULD be of minimum length needed to encode the sequence number.</t>
          <t>The &ldquo;kid&rdquo; parameter. The value is set to the Context Identifier (see <xref target="sec-context-section"/>). This parameter is optional if the message is a CoAP response.</t>
          <t>Optionally, the parameter called &ldquo;sid&rdquo;, defined below. The value is set to the Sender ID (see <xref target="sec-context-section"/>). Note that since this parameter is sent in clear, privacy issues SHOULD be considered by the application defining the Sender ID.</t>
        </list></t>
      <t>The &ldquo;unprotected&rdquo; field, which SHALL be empty.</t>
    </list></t>
  <t>The &ldquo;ciphertext&rdquo; field is computed from the Plaintext (see <xref target="plaintext"/>) and the Additional Authenticated Data (AAD) (see <xref target="AAD"/>) and encoded as a byte string (type: bstr), following Section 5.2 of <xref target="I-D.ietf-cose-msg"/>.</t>
</list></t>

<section anchor="plaintext" title="Plaintext">

<t>The Plaintext is formatted as a CoAP message without Header (see <xref target="plaintext-figure"/>) consisting of:</t>

<t><list style="symbols">
  <t>all CoAP Options present in the unprotected message which are encrypted (see <xref target="coap-headers-and-options"/>), in the order as given by the Option number (each Option with Option Header including delta to previous included encrypted option); and</t>
  <t>the CoAP Payload, if present, and in that case prefixed by the one-byte Payload Marker (0xFF).</t>
</list></t>

<figure title="Plaintext" anchor="plaintext-figure"><artwork align="center"><![CDATA[
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|    Options to Encrypt (if any) ...                            ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...                       ~
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
 (only if there 
   is payload)
]]></artwork></figure>

</section>
<section anchor="AAD" title="Additional Authenticated Data">

<t>The Additional Authenticated Data (&ldquo;Enc_structure&rdquo;) as described is Section 5.3 of <xref target="I-D.ietf-cose-msg"/> includes:</t>

<t><list style="symbols">
  <t>the &ldquo;context&rdquo; parameter, which has value &ldquo;Encrypted&rdquo;</t>
  <t>the &ldquo;protected&rdquo; parameter, which includes the &ldquo;protected&rdquo; part of the &ldquo;Headers&rdquo; field;</t>
  <t>the &ldquo;external_aad&rdquo; is a serialized CBOR array <xref target="aad"/> where the exact content is different in requests (external_aad_req) and repsonses (external_aad_resp). It contains:  <list style="symbols">
      <t>ver: uint, contains the CoAP version number, as defined in Section 3 of <xref target="RFC7252"/></t>
      <t>code: uint, contains is the CoAP Code of the unprotected CoAP message, as defined in Section 3 of <xref target="RFC7252"/>.</t>
      <t>alg: int, contains the Algorithm from the security context used for the exchange (see <xref target="sec-context-def-section"/>);</t>
      <t>unencrypted-uri: tstr with tag URI, contains the part of the URI which is not encrypted, and is composed of the request scheme (Proxy-Scheme if present), Uri-Host and Uri-Port (if present) options according to the method described in Section 6.5 of <xref target="RFC7252"/>, if the message is a CoAP request;</t>
      <t>cid : bstr, contains the cid for the request (which is same as the cid for the response).</t>
      <t>id : bstr, is the identifier for the endpoint sending the request and verifying the response; which means that for the endpoint sending the response, the id has value Recipient ID, while for the endpoint receiving the response, id has the value Sender ID.</t>
      <t>seq : bstr, is the value of the &ldquo;Partial IV&rdquo; in the COSE object of the request (see Section 5).</t>
      <t>tag-previous-block: bstr, contains the AEAD Tag of the message containing the previous block in the sequence, as enumerated by Block1 in the case of a request and Block2 in the case of a response, if the message is fragmented using a block option <xref target="RFC7959"/>.</t>
    </list></t>
</list></t>

<figure title="External AAD (external_aad)" anchor="aad"><artwork align="center"><![CDATA[
external_aad = external_aad_req / external_aad_resp

external_aad_req = [
   ver : uint,
   code : uint,
   alg : int,
   unencrypted-uri : uri,
   ? tag-previous-block : bstr
]

external_aad_resp = [
   ver : uint,
   code : uint,
   alg : int,
   cid : bstr,
   id : bstr,
   seq : bstr,
   ? tag-previous-block : bstr
]
]]></artwork></figure>

<t>The encryption process is described in Section 5.3 of <xref target="I-D.ietf-cose-msg"/>.</t>

</section>
</section>
<section anchor="coap-protected-generate" title="Protecting CoAP Messages">

<section anchor="replay-protection-section" title="Replay and Freshness Protection">

<t>In order to protect from replay of messages and verify freshness, a CoAP endpoint SHALL maintain a Sender Sequence Number and a Recipient Replay Window in the security context. An endpoint uses the Sender Sequence Number to protect messages to send and the Recipient Replay Window to verify received messages, as described in <xref target="sec-context-section"/>.</t>

<t>A receiving endpoint SHALL verify that the Sequence Number (Partial IV) received in the COSE object has not been received before in the security context identified by the Cid. The size of the Replay Window depends on the use case and lower protocol layers. In case of reliable and ordered transport, the recipient MAY just store the last received sequence number and require that newly received Sequence Numbers equals the last received Recipient Sequence Number + 1.</t>

<t>The receiving endpoint SHALL reject messages with a sequence number greater than the maximum value of the Partial IV. This maximum value is algorithm specific, for example for AES-CCM-64-64-128 it is 2^56-1.</t>

<t>OSCOAP responses are verified to match a prior request, by including the unique transaction identifier (Tid as defined in <xref target="sec-context-section"/>) of the request in the Additional Authenticated Data of the response message. In case of CoAP observe, each notification MUST be verified using the Tid of the observe registration, so the Tid of the registration needs to be cached by the observer until the observation ends.</t>

<t>If a CoAP server receives a request with the Object-Security option, then the server SHALL include the Tid of the request in the AAD of the response, as described in <xref target="protected-coap-formatting-resp"/>.</t>

<t>If the CoAP client receives a response with the Object-Security option, then the client SHALL verify the integrity of the response, using the Tid of its own associated request in the AAD, as described in <xref target="verif-coap-resp"/>.</t>

</section>
<section anchor="protected-coap-formatting-req" title="Protecting the Request">

<t>Given an unprotected CoAP request, including header, options and payload, the client SHALL perform the following steps to create a protected CoAP request using a security context associated with the target resource (see <xref target="cid-est"/>).</t>

<t>When using Uri-Host or Proxy-Uri in the construction of the request, the &lt;host&gt; value MUST be a reg-name (<xref target="RFC3986"/>), and not an IP-literal or IPv4address, for canonicalization of the destination address.</t>

<t><list style="numbers">
  <t>Compute the COSE object as specified in <xref target="sec-obj-cose"/>  <list style="symbols">
      <t>the AEAD nonce is created by XORing the Sender IV (context IV) with the Sender Sequence Number (partial IV).</t>
      <t>If the block option is used, the AAD includes the AEAD Tag from the previous block sent (from the second block and following) <xref target="AAD"/>. This means that the endpoint MUST store the Tag of each last-sent block to compute the following.</t>
      <t>Note that the &lsquo;sid&rsquo; field containing the Sender ID is included in the COSE object (<xref target="sec-obj-cose"/>) if the application needs it.</t>
    </list></t>
  <t>Format the protected CoAP message as an ordinary CoAP message, with the following Header, Options, and Payload, based on the unprotected CoAP message:  <list style="symbols">
      <t>The CoAP header is the same as the unprotected CoAP message.</t>
      <t>If present, the CoAP option Proxy-Uri is decomposed as described in <xref target="proxy-uri"/>.</t>
      <t>The CoAP options which are of class E (<xref target="coap-headers-and-options"/>) are removed. The Object-Security option is added.</t>
      <t>If the message type of the unprotected CoAP message does not allow Payload, then the value of the Object-Security option is the COSE object. If the message type of the unprotected CoAP message allows Payload, then the Object-Security option is empty and the Payload of the protected CoAP message is the COSE object.</t>
    </list></t>
  <t>Store the association Token - Cid. The Client SHALL be able to find the correct security context used to protect the request and verify the response with use of the Token of the message exchange.</t>
  <t>Increment the Sender Sequence Number by one. If the Sender Sequence Number exceeds the maximum number for the AEAD algorithm, the client MUST NOT process any more requests with the given security context. The client SHOULD acquire a new security context (and consequently inform the server about it) before this happens. The latter is out of scope of this memo.</t>
</list></t>

</section>
<section anchor="verif-coap-req" title="Verifying the Request">

<t>A CoAP server receiving an unprotected CoAP request to access a protected resource (as defined <xref target="cid-est"/>) SHALL reject the message with error code 4.01 (Unauthorized).</t>

<t>A CoAP server receiving a message containing the Object-Security option and a outer Block option SHALL first process this option according to <xref target="RFC7959"/>, until all blocks of the protected CoAP message has been received, see <xref target="block-options"/>.</t>

<t>A CoAP server receiving a message containing the Object-Security option SHALL perform the following steps, using the security context identified by the Context Identifier in the &ldquo;kid&rdquo; parameter in the received COSE object:</t>

<t><list style="numbers">
  <t>Verify the Sequence Number in the Partial IV parameter, as described in <xref target="replay-protection-section"/>. If it cannot be verified that the Sequence Number has not been received before, the server MUST stop processing the request.</t>
  <t>Recreate the Additional Authenticated Data, as described in <xref target="sec-obj-cose"/>.
  <list style="symbols">
      <t>If the block option is used, the AAD includes the AEAD Tag from the previous block received (from the second block and following) <xref target="AAD"/>. This means that the endpoint MUST store the Tag of each last-received block to compute the following.</t>
      <t>Note that the server&rsquo;s &lt;host&gt; value MUST be a reg-name (<xref target="RFC3986"/>), and not an IP-literal or IPv4address.</t>
    </list></t>
  <t>Compose the AEAD nonce by XORing the Recipient IV (context IV) with the padded Partial IV parameter, received in the COSE Object.</t>
  <t>Retrieve the Recipient Key.</t>
  <t>Verify and decrypt the message. If the verification fails, the server MUST stop processing the request.</t>
  <t>If the message verifies, update the Recipient Replay Window, as described in <xref target="replay-protection-section"/>.</t>
  <t>Restore the unprotected request by adding any decrypted options or payload from the plaintext. Any outer E options (<xref target="coap-headers-and-options"/>) are overwritten. The Object-Security option is removed.</t>
</list></t>

</section>
<section anchor="protected-coap-formatting-resp" title="Protecting the Response">

<t>A server receiving a valid request with a protected CoAP message (i.e. containing an Object-Security option) SHALL respond with a protected CoAP message.</t>

<t>Given an unprotected CoAP response, including header, options, and payload, the server SHALL perform the following steps to create a protected CoAP response, using the security context identified by the Context Identifier of the received request:</t>

<t><list style="numbers">
  <t>Compute the COSE object as specified in Section <xref target="sec-obj-cose"/>
  <list style="symbols">
      <t>The AEAD nonce is created by XORing the Sender IV (context IV) and the padded Sender Sequence Number.</t>
      <t>If the block option <xref target="RFC7959"/> is used, the AAD includes the AEAD Tag from the previous block sent (from the second block and following) <xref target="AAD"/>. This means that the endpoint MUST store the Tag of each last-sent block to compute the following. Note that this applies even for random access of blocks, i.e. when blocks are not requested in the order of their relative number (NUM).</t>
    </list></t>
  <t>Format the protected CoAP message as an ordinary CoAP message, with the following Header, Options, and Payload based on the unprotected CoAP message:
  <list style="symbols">
      <t>The CoAP header is the same as the unprotected CoAP message.</t>
      <t>The CoAP options which are of class E are removed, except any special option (labelled &lsquo;*&rsquo;) that is present which has its outer value (<xref target="coap-headers-and-options"/>). The Object-Security option is added.</t>
      <t>If the message type of the unprotected CoAP message does not allow Payload, then the value of the Object-Security option is the COSE object. If the message type of the unprotected CoAP message allows Payload, then the Object-Security option is empty and the Payload of the protected CoAP message is the COSE object.</t>
    </list></t>
  <t>Increment the Sender Sequence Number by one. If the Sender Sequence Number exceeds the maximum number for the AEAD algorithm, the server MUST NOT process any more responses with the given security context. The server SHOULD acquire a new security context (and consequently inform the client about it) before this happens. The latter is out of scope of this memo.</t>
</list></t>

<t>Note the differences between generating a protected request, and a protected response, for example whether &ldquo;kid&rdquo; is present in the header, or whether Destination URI or Tid is present in the AAD, of the COSE object.</t>

</section>
<section anchor="verif-coap-resp" title="Verifying the Response">

<t>A CoAP client receiving a message containing the Object-Security option SHALL perform the following steps, using the security context identified by the Token of the received response:</t>

<t><list style="numbers">
  <t>If the message contain an outer Block option the client SHALL process this option according to <xref target="RFC7959"/>, until all blocks of the protected CoAP message has been received, see <xref target="block-options"/>.</t>
  <t>Verify the Sequence Number in the Partial IV parameter as described in <xref target="replay-protection-section"/>. If it cannot be verified that the Sequence Number has not been received before, the client MUST stop processing the response.</t>
  <t>Recreate the Additional Authenticated Data as described in <xref target="sec-obj-cose"/>.
  <list style="symbols">
      <t>If the block option is used, the AAD includes the AEAD Tag from the previous block received (from the second block and following) <xref target="AAD"/>. This means that the endpoint MUST store the Tag of each last-received block to compute the following.</t>
    </list></t>
  <t>Compose the AEAD nonce by XORing the Recipient IV (context IV) with the Partial IV parameter, received in the COSE Object.</t>
  <t>Retrieve the Recipient Key.</t>
  <t>Verify and decrypt the message. If the verification fails, the client MUST stop processing the response.</t>
  <t>If the message verifies, update the Recipient Replay Window, as described in <xref target="replay-protection-section"/>.</t>
  <t>Restore the unprotected response by adding any decrypted options or payload from the plaintext. Any class E options (<xref target="coap-headers-and-options"/>) are overwritten. The Object-Security option is removed.</t>
</list></t>

</section>
</section>
<section anchor="sec-considerations" title="Security Considerations">

<t>In scenarios with intermediary nodes such as proxies or brokers, transport layer security such as DTLS only protects data hop-by-hop. As a consequence the intermediary nodes can read and modify information. The trust model where all intermediate nodes are considered trustworthy is problematic, not only from a privacy perspective, but also from a security perspective, as the intermediaries are free to delete resources on sensors and falsify commands to actuators (such as &ldquo;unlock door&rdquo;, &ldquo;start fire alarm&rdquo;, &ldquo;raise bridge&rdquo;). Even in the rare cases, where all the owners of the intermediary nodes are fully trusted, attacks and data breaches make such an architecture brittle.</t>

<t>DTLS protects hop-by-hop the entire CoAP message, including header, options, and payload. OSCOAP protects end-to-end the payload, and all information in the options and header, that is not required for forwarding (see <xref target="coap-headers-and-options"/>). DTLS and OSCOAP can be combined, thereby enabling end-to-end security of CoAP payload, in combination with hop-by-hop protection of the entire CoAP message, during transport between end-point and intermediary node.</t>

<t>The CoAP message layer, however, cannot be protected end-to-end through intermediary devices since the parameters Type and Message ID, as well as Token and Token Length may be changed by a proxy. Moreover, messages that are not possible to verify should for security reasons not always be acknowledged but in some cases be silently dropped. This would not comply with CoAP message layer, but does not have an impact on the application layer security solution, since message layer is excluded from that.</t>

<t>The use of COSE to protect CoAP messages as specified in this document requires an established security context. The method to establish the security context described in <xref target="sec-context-est-section"/> is based on a common shared secret material and key derivation function in client and server. EDHOC <xref target="I-D.selander-ace-cose-ecdhe"/> describes an augmented Diffie-Hellman key exchange to produce forward secret keying material and agree on crypto algorithms necessary for OSCOAP, authenticated with pre-established credentials. These pre-established credentials may, in turn, be provisioned using a trusted third party such as described in the OAuth-based ACE framework <xref target="I-D.ietf-ace-oauth-authz"/>. An OSCOAP profile of ACE is described in <xref target="I-D.seitz-ace-oscoap-profile"/>.</t>

<t>The mandatory-to-implement AEAD algorithm AES-CCM-64-64-128 is selected for broad applicability in terms of message size (2^64 blocks) and maximum no. messages (2^56-1). Compatibility with CCM* is achieved by using the algorithm AES-CCM-16-64-128 <xref target="I-D.ietf-cose-msg"/>.</t>

<t>Most AEAD algorithms require a unique nonce for each message, for which the sequence numbers in the COSE message field &ldquo;Partial IV&rdquo; is used. If the recipient accepts any sequence number larger than the one previously received, then the problem of sequence number synchronization is avoided. With reliable transport it may be defined that only messages with sequence number which are equal to previous sequence number + 1 are accepted. The alternatives to sequence numbers have their issues: very constrained devices may not be able to support accurate time, or to generate and store large numbers of random nonces. The requirement to change key at counter wrap is a complication, but it also forces the user of this specification to think about implementing key renewal.</t>

<t>The encrypted block options enable the sender to split large messages into protected blocks such that the receiving node can verify blocks before having received the complete message. In order to protect from attacks replacing blocks from a different message with the same block number between same endpoints and same resource at roughly the same time, the AEAD Tag from the message containing one block is included in the external_aad of the message containing the next block.</t>

<t>The unencrypted block options allow for arbitrary proxy fragmentation operations that cannot be verified by the endpoints, but can by policy be restricted in size since the encrypted options allow for secure fragmentation of very large messages. A maximum message size (above which the sending endpoint fragments the message and the receiving endpoint discards the message, if complying to the policy) may be obtained as part of normal resource discovery.</t>

<t>Applications need to use a padding scheme if the content of a message can be determined solely from the length of the payload.  As an example, the strings &ldquo;YES&rdquo; and &ldquo;NO&rdquo; even if encrypted can be distinguished from each other as there is no padding supplied by the current set of encryption algorithms.  Some information can be determined even from looking at boundary conditions.  An example of this would be returning an integer between 0 and 100 where lengths of 1, 2 and 3 will provide information about where in the range things are. Three different methods to deal with this are: 1) ensure that all messages are the same length.  For example using 0 and 1 instead of &lsquo;yes&rsquo; and &lsquo;no&rsquo;.  2) Use a character which is not part of the responses to pad to a fixed length.  For example, pad with a space to three characters.  3) Use the PKCS #7 style padding scheme where m bytes are appended each having the value of m.  For example, appending a 0 to &ldquo;YES&rdquo; and two 1&rsquo;s to &ldquo;NO&rdquo;.  This style of padding means that all values need to be padded.</t>

</section>
<section anchor="privacy-considerations" title="Privacy Considerations">

<t>Privacy threats executed through intermediate nodes are considerably reduced by means of OSCOAP. End-to-end integrity protection and encryption of CoAP payload and all options that are not used for forwarding, provide mitigation against attacks on sensor and actuator communication, which may have a direct impact on the personal sphere.</t>

<t>CoAP headers sent in plaintext allow for example matching of CON and ACK (CoAP Message Identifier), matching of request and responses (Token) and traffic analysis.</t>

</section>
<section anchor="iana" title="IANA Considerations">

<t>Note to RFC Editor: Please replace all occurrences of &ldquo;[[this document]]&rdquo; with the RFC number of this specification.</t>

<section anchor="coap-option-numbers-registry" title="CoAP Option Numbers Registry">

<t>The Object-Security option is added to the CoAP Option Numbers registry:</t>

<figure><artwork align="center"><![CDATA[
+--------+-----------------+-------------------+
| Number | Name            | Reference         |
+--------+-----------------+-------------------+
|  TBD   | Object-Security | [[this document]] |
+--------+-----------------+-------------------+
]]></artwork></figure>

</section>
<section anchor="cose-header-parameters-registry" title="COSE Header Parameters Registry">

<t>The &ldquo;sid&rdquo; parameter is added to the COSE Header Parameter Registry:</t>

<figure><artwork align="center"><![CDATA[
+------+-------+------------+----------------+-------------------+
| name | label | value type | value registry | description       |
+------+-------+------------+----------------+-------------------+
|  sid |  TBD  |    bstr    |                | Sender Identifier |
+------+-------+------------+----------------+-------------------+
]]></artwork></figure>

</section>
<section anchor="media-type-registrations" title="Media Type Registrations">

<t>The &ldquo;application/oscon&rdquo; media type is added to the Media Types registry:</t>

<figure><artwork><![CDATA[
    Type name: application

    Subtype name: oscon

    Required parameters: N/A

    Optional parameters: N/A

    Encoding considerations: binary

    Security considerations: See Appendix C of [[this document]].

    Interoperability considerations: N/A

    Published specification: [[this document]]

    Applications that use this media type: To be identified

    Fragment identifier considerations: N/A

    Additional information:

    * Magic number(s): N/A

    * File extension(s): N/A

    * Macintosh file type code(s): N/A

    Person & email address to contact for further information:
    iesg@ietf.org

    Intended usage: COMMON

    Restrictions on usage: N/A

    Author: Goeran Selander, goran.selander@ericsson.com

    Change Controller: IESG

    Provisional registration? No
]]></artwork></figure>

</section>
<section anchor="coap-content-format-registration" title="CoAP Content Format Registration">

<t>The &ldquo;application/oscon&rdquo; content format is added to the CoAP Content Format registry:</t>

<figure><artwork align="center"><![CDATA[
+-------------------+----------+----+-------------------+
| Media type        | Encoding | ID | Reference         |
+-------------------+----------+----+-------------------+
| application/oscon | -        | 70 | [[this document]] |
+-------------------+----------+----+-------------------+
]]></artwork></figure>

</section>
</section>
<section anchor="acknowledgments" title="Acknowledgments">

<t>The following individuals provided input to this document: Carsten Bormann, Joakim Brorsson, Martin Gunnarsson, Klaus Hartke, Jim Schaad, Marco Tiloca, and Malisa Vucinic.</t>

<t>Ludwig Seitz and Goeran Selander worked on this document as part of the CelticPlus project CyberWI, with funding from Vinnova.</t>

</section>


  </middle>

  <back>

    <references title='Normative References'>

&I-D.ietf-cose-msg;
&RFC2119;
&RFC6347;
&RFC7252;
&RFC7641;
&RFC7959;
&RFC3986;
&RFC7049;


    </references>

    <references title='Informative References'>

&I-D.selander-ace-cose-ecdhe;
&I-D.hartke-core-e2e-security-reqs;
&I-D.mattsson-core-coap-actuators;
&I-D.bormann-6lo-coap-802-15-ie;
&I-D.ietf-ace-oauth-authz;
&I-D.seitz-ace-oscoap-profile;
&I-D.ietf-core-coap-tcp-tls;
&I-D.greevenbosch-appsawg-cbor-cddl;
&RFC4303;
&RFC5869;
&RFC7228;


    </references>


<section anchor="appendix-a" title="Overhead">

<t>OSCOAP transforms an unprotected CoAP message to a protected CoAP message, and the protected CoAP message is larger than the unprotected CoAP message. This appendix illustrates the message expansion.</t>

<section anchor="appendix-a1" title="Length of the Object-Security Option">

<t>The protected CoAP message contains the COSE object. The COSE object is included in the payload if the message type of the unprotected CoAP message allows payload or else in the Object-Security option. In the former case the Object-Security option is empty. So the length of the Object-Security option is either zero or the size of the COSE object, depending on whether the CoAP message allows payload or not.</t>

<t>Length of Object-Security option = { 0, size of COSE Object }</t>

</section>
<section anchor="appendix-a2" title="Size of the COSE Object">

<t>The size of the COSE object is the sum of the sizes of</t>

<t><list style="symbols">
  <t>the Header parameters,</t>
  <t>the Cipher Text (excluding the Tag),</t>
  <t>the Tag, and</t>
  <t>data incurred by the COSE format itself (including CBOR encoding).</t>
</list></t>

<t>Let&rsquo;s analyze the contributions one at a time:</t>

<t><list style="symbols">
  <t>The header parameters of the COSE object are the Context Identifier (Cid) and the Sequence Number (Seq) (also part of the Transaction Identifier (Tid)) if the message is a request, and Seq only if the message is a response (see <xref target="sec-obj-cose"/>).  <list style="symbols">
      <t>The size of Cid is recommended to be 64 bits, but may be shorter, as discussed in <xref target="cid-est"/></t>
      <t>The size of Seq is variable, and increases with the number of messages exchanged.</t>
      <t>As the AEAD nonce is generated from the padded Sequence Number and a previously agreed upon context IV it is not required to send the whole nonce in the message.</t>
    </list></t>
  <t>The Cipher Text, excluding the Tag, is the encryption of the payload and the encrypted options <xref target="coap-headers-and-options"/>, which are present in the unprotected CoAP message.</t>
  <t>The size of the Tag depends on the Algorithm. For example, for the algorithm AES-CCM-64-64-128, the Tag is 8 bytes.</t>
  <t>The overhead from the COSE format itself depends on the sizes of the previous fields, and is of the order of 10 bytes.</t>
</list></t>

</section>
<section anchor="appendix-a3" title="Message Expansion">

<t>The message expansion is not the size of the COSE object. The ciphertext in the COSE object is encrypted payload and options of the unprotected CoAP message - the plaintext of which is removed from the protected CoAP message. Since the size of the ciphertext is the same as the corresponding plaintext, there is no message expansion due to encryption; payload and options are just represented in a different way in the protected CoAP message:</t>

<t><list style="symbols">
  <t>The encrypted payload is in the payload of the protected CoAP message</t>
  <t>The encrypted options are in the Object-Security option or within the payload.</t>
</list></t>

<t>Therefore the OSCOAP message expansion is due to Cid (if present), Seq, Tag, and COSE overhead:</t>

<figure title="OSCOAP message expansion" anchor="mess-exp-formula"><artwork align="center"><![CDATA[
Message Overhead = Cid + Seq + Tag + COSE Overhead
]]></artwork></figure>

</section>
<section anchor="appendix-b" title="Example">

<t>This section gives an example of message expansion in a request with OSCOAP.</t>

<t>In this example we assume an 8-byte Cid.</t>

<t><list style="symbols">
  <t>Cid: 0xa1534e3c9cecad84</t>
</list></t>

<t>In the example the sequence number is 225, requiring 1 byte to encode. (The size of Seq could be larger depending on how many messages that has been sent as is discussed in <xref target="appendix-a2"/>.)</t>

<t><list style="symbols">
  <t>Seq: 225</t>
</list></t>

<t>The example is based on AES-CCM-64-64-128.</t>

<t><list style="symbols">
  <t>Tag is 8 bytes</t>
</list></t>

<t>The COSE object is represented in <xref target="mess-exp-ex"/> using CBOR&rsquo;s diagnostic notation.</t>

<figure title="Example of message expansion" anchor="mess-exp-ex"><artwork align="center"><![CDATA[
[
  h'a20448a1534e3c9cecad840641e2', / protected:
                                      {04:h'a1534e3c9cecad84',
                                       06:h'e2'} /
  {},                              / unprotected: - /
  Ciph + Tag                       / ciphertext + 8 byte 
                                      authentication tag /
]
]]></artwork></figure>

<t>Note that the encrypted CoAP options and payload are omitted since we target the message expansion (see <xref target="appendix-a3"/>). Therefore the size of the COSE Cipher Text equals the size of the Tag, which is 8 bytes.</t>

<t>The COSE object encodes to a total size of 26 bytes, which is the message expansion in this example. The COSE overhead in this example is 26 - (8 + 1 + 8) = 9 bytes, according to the formula in <xref target="mess-exp-formula"/>. Note that in this example two bytes in the COSE overhead are used to encode the length of Cid and the length of Seq.</t>

<t><xref target="table-aes-ccm"/> summarizes these results.</t>

<figure title="Message overhead for a 8-byte Cid, 1-byte Seq and 8-byte Tag." anchor="table-aes-ccm"><artwork align="center"><![CDATA[
+---------+---------+---------+----------+------------+
|   Cid   |   Seq   |   Tag   | COSE OH  | Message OH |
+---------+---------+---------+----------+------------+
| 8 bytes | 1 byte  | 8 bytes |  9 bytes |  22 bytes  |
+---------+---------+---------+----------+------------+
]]></artwork></figure>

</section>
</section>
<section anchor="appendix-d" title="Examples">

<t>This section gives examples of OSCOAP. The message exchanges are made, based on the assumption that there is a security context established between client and server. For simplicity, these examples only indicate the content of the messages without going into detail of the COSE message format.</t>

<section anchor="secure-access-to-sensor" title="Secure Access to Sensor">

<t>Here is an example targeting the scenario in the Section 2.2.1. - Forwarding of <xref target="I-D.hartke-core-e2e-security-reqs"/>. The example illustrates a client requesting the alarm status from a server. In the request, CoAP option Uri-Path is encrypted and integrity protected, and the CoAP header fields Code and Version are integrity protected (see <xref target="coap-headers-and-options"/>). In the response, the CoAP Payload is encrypted and integrity protected, and the CoAP header fields Code and Version are integrity protected.</t>

<figure title="Indication of CoAP GET protected with OSCOAP. The brackets [ ... ] indicate a COSE object. The brackets { ... } indicate encrypted data." anchor="get-protected-sig"><artwork align="center"><![CDATA[
Client  Proxy  Server
   |      |      |
   +----->|      |            Code: 0.01 (GET)
   | GET  |      |           Token: 0x8c
   |      |      | Object-Security: [cid:5fdc, seq:42,
   |      |      |                   {Uri-Path:"alarm_status"},
   |      |      |                   <Tag>]
   |      |      |         Payload: -
   |      |      |
   |      +----->|            Code: 0.01 (GET)
   |      | GET  |           Token: 0x7b
   |      |      | Object-Security: [cid:5fdc, seq:42,
   |      |      |                   {Uri-Path:"alarm_status"},
   |      |      |                   <Tag>]
   |      |      |         Payload: -
   |      |      |
   |      |<-----+            Code: 2.05 (Content)
   |      | 2.05 |           Token: 0x7b
   |      |      |         Max-Age: 0
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:56, {"OFF"}, <Tag>]
   |      |      |
   |<-----+      |            Code: 2.05 (Content)
   | 2.05 |      |           Token: 0x8c
   |      |      |         Max-Age: 0
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:56, {"OFF"}, <Tag>]
   |      |      |
]]></artwork></figure>

<t>Since the unprotected request message (GET) has no payload, the Object-Security option carries the COSE object as its value.
Since the unprotected response message (Content) has payload (&ldquo;OFF&rdquo;), the COSE object (indicated with [ &hellip; ]) is carried as the CoAP payload.</t>

<t>The COSE header of the request contains a Context Identifier (cid:5fdc), indicating which security context was used to protect the message and a Sequence Number (seq:42).</t>

<t>The option Uri-Path (alarm_status) and payload (&ldquo;OFF&rdquo;) are formatted as indicated in <xref target="sec-obj-cose"/>, and encrypted in the COSE Cipher Text (indicated with { &hellip; }).</t>

<t>The server verifies that the Sequence Number has not been received before (see <xref target="replay-protection-section"/>). The client verifies that the Sequence Number has not been received before and that the response message is generated as a response to the sent request message (see <xref target="replay-protection-section"/>).</t>

</section>
<section anchor="secure-subscribe-to-sensor" title="Secure Subscribe to Sensor">

<t>Here is an example targeting the scenario in the Forwarding with observe case  of <xref target="I-D.hartke-core-e2e-security-reqs"/>. The example illustrates a client requesting subscription to a blood sugar measurement resource (GET /glucose), and first receiving the value 220 mg/dl, and then a second reading with value 180 mg/dl. The CoAP options Observe, Uri-Path, Content-Format, and Payload are encrypted and integrity protected, and the CoAP header field Code is integrity protected (see <xref target="coap-headers-and-options"/>).</t>

<figure title="Indication of CoAP GET protected with OSCOAP. The brackets [ ... ] indicates COSE object. The bracket { ... } indicates encrypted data." anchor="get-protected-enc"><artwork align="center"><![CDATA[
Client  Proxy  Server
   |      |      |
   +----->|      |            Code: 0.01 (GET)
   | GET  |      |           Token: 0x83
   |      |      |         Observe: 0
   |      |      | Object-Security: [cid:ca, seq:15b7, {Observe:0,
   |      |      |                   Uri-Path:"glucose"}, <Tag>]
   |      |      |         Payload: -
   |      |      |
   |      +----->|            Code: 0.01 (GET)
   |      | GET  |           Token: 0xbe
   |      |      |         Observe: 0
   |      |      | Object-Security: [cid:ca, seq:15b7, {Observe:0,
   |      |      |                   Uri-Path:"glucose"}, <Tag>]
   |      |      |         Payload: -
   |      |      |
   |      |<-----+            Code: 2.05 (Content)
   |      | 2.05 |           Token: 0xbe
   |      |      |         Max-Age: 0
   |      |      |         Observe: 1
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:32c2, {Observe:1, 
   |      |      |                   Content-Format:0, "220"}, <Tag>]
   |      |      |
   |<-----+      |            Code: 2.05 (Content)
   | 2.05 |      |           Token: 0x83
   |      |      |         Max-Age: 0
   |      |      |         Observe: 1
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:32c2, {Observe:1,
   |      |      |                   Content-Format:0, "220"}, <Tag>]
  ...    ...    ...
   |      |      |
   |      |<-----+            Code: 2.05 (Content)
   |      | 2.05 |           Token: 0xbe
   |      |      |         Max-Age: 0
   |      |      |         Observe: 2
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:32c6, {Observe:2, 
   |      |      |                   Content-Format:0, "180"}, <Tag>]
   |      |      |
   |<-----+      |            Code: 2.05 (Content)
   | 2.05 |      |           Token: 0x83
   |      |      |         Max-Age: 0
   |      |      |         Observe: 2
   |      |      | Object-Security: -
   |      |      |         Payload: [seq:32c6, {Observe:2,
   |      |      |                   Content-Format:0, "180"}, <Tag>]
   |      |      |
]]></artwork></figure>

<t>Since the unprotected request message (GET) allows no payload, the COSE object (indicated with [ &hellip; ]) is carried in the Object-Security option value. Since the unprotected response message (Content) has payload, the Object-Security option is empty, and the COSE object is carried as the payload.</t>

<t>The COSE header of the request contains a Context Identifier (cid:ca), indicating which security context was used to protect the message and a Sequence Number (seq:15b7).</t>

<t>The options Observe, Content-Format and the payload are formatted as indicated in <xref target="sec-obj-cose"/>, and encrypted in the COSE ciphertext (indicated with { &hellip; }).</t>

<t>The server verifies that the Sequence Number has not been received before (see <xref target="replay-protection-section"/>). The client verifies that the Sequence Number has not been received before and that the response message is generated as a response to the subscribe request.</t>

</section>
</section>
<section anchor="mode-payl" title="Object Security of Content (OSCON)">

<t>OSCOAP protects message exchanges end-to-end between a certain client and a
certain server, targeting the security requirements for forward proxy of <xref target="I-D.hartke-core-e2e-security-reqs"/>. In contrast, many use cases require one and
the same message to be protected for, and verified by, multiple endpoints, see
caching proxy section of <xref target="I-D.hartke-core-e2e-security-reqs"/>. Those security requirements can be addressed by protecting essentially the payload/content of individual messages using the COSE format (<xref target="I-D.ietf-cose-msg"/>), rather than the entire request/response message exchange. This is referred to as Object Security of Content (OSCON).</t>

<t>OSCON transforms an unprotected CoAP message into a protected CoAP message in
the following way: the payload of the unprotected CoAP message is wrapped by
a COSE object, which replaces the payload of the unprotected CoAP message. We
call the result the &ldquo;protected&rdquo; CoAP message.</t>

<t>The unprotected payload shall be the plaintext/payload of the COSE object. 
The &lsquo;protected&rsquo; field of the COSE object &lsquo;Headers&rsquo; shall include the context identifier, both for requests and responses.
If the unprotected CoAP message includes a Content-Format option, then the COSE
object shall include a protected &lsquo;content type&rsquo; field, whose value is set to the unprotected message Content-Format value. The Content-Format option of the
protected CoAP message shall be replaced with &ldquo;application/oscon&rdquo; (<xref target="iana"/>)</t>

<t>The COSE object shall be protected (encrypted) and verified (decrypted) as
described in (<xref target="I-D.ietf-cose-msg"/>).</t>

<t>Most AEAD algorithms require a unique nonce for each message. Sequence numbers for partial IV as specified for OSCOAP may be used for replay protection as described in <xref target="replay-protection-section"/>. The use of time stamps in the COSE header parameter &lsquo;operation time&rsquo; <xref target="I-D.ietf-cose-msg"/> for freshness may be used.</t>

<t>OSCON shall not be used in cases where CoAP header fields (such as Code or
Version) or CoAP options need to be integrity protected or encrypted. OSCON shall not be used in cases which require a secure binding between request and
response.</t>

<t>The scenarios in Sections 3.3 - 3.5 of <xref target="I-D.hartke-core-e2e-security-reqs"/> assume multiple recipients for a particular content. In this case the use of symmetric keys does not provide data origin authentication. Therefore the COSE object should in general be protected with a digital signature.</t>

<section anchor="appendix-c" title="Overhead OSCON">

<t>In general there are four different kinds of modes that need to be supported: message authentication code, digital signature, authenticated encryption, and symmetric encryption + digital signature. The use of digital signature is necessary for applications with many legitimate recipients of a given message, and where data origin authentication is required.</t>

<t>To distinguish between these different cases, the tagged structures of 
COSE are used (see Section 2 of <xref target="I-D.ietf-cose-msg"/>).</t>

<t>The sizes of COSE messages for selected algorithms are detailed in this section.</t>

<t>The size of the header is shown separately from the size of the MAC/signature.
A 4-byte Context Identifier and a 1-byte Sequence Number are used throughout
all examples, with these values:</t>

<t><list style="symbols">
  <t>Cid: 0xa1534e3c</t>
  <t>Seq: 0xa3</t>
</list></t>

<t>For each scheme, we indicate the fixed length of these two parameters (&ldquo;Cid+Seq&rdquo; column) and of the Tag (&ldquo;MAC&rdquo;/&rdquo;SIG&rdquo;/&rdquo;TAG&rdquo;). The &ldquo;Message OH&rdquo; column
shows the total expansions of the CoAP message size, while the &ldquo;COSE OH&rdquo; column is calculated from the previous columns following the formula in <xref target="mess-exp-formula"/>.</t>

<t>Overhead incurring from CBOR encoding is also included in the COSE overhead count.</t>

<t>To make it easier to read, COSE objects are represented using CBOR&rsquo;s diagnostic notation rather than a binary dump.</t>

</section>
<section anchor="ssm-mac" title="MAC Only">

<t>This example is based on HMAC-SHA256, with truncation to 8 bytes (HMAC 256/64).</t>

<t>Since the key is implicitly known by the recipient, the COSE_Mac0_Tagged structure is used (Section 6.2 of <xref target="I-D.ietf-cose-msg"/>).</t>

<t>The object in COSE encoding gives:</t>

<figure><artwork align="center"><![CDATA[
996(                         # COSE_Mac0_Tagged
  [
    h'a20444a1534e3c0641a3', # protected:
                               {04:h'a1534e3c',
                                06:h'a3'}
    {},                      # unprotected
    h'',                     # payload
    MAC                      # truncated 8-byte MAC
  ]
)
]]></artwork></figure>

<t>This COSE object encodes to a total size of 26 bytes.</t>

<t><xref target="comp-hmac-sha256"/> summarizes these results.</t>

<figure title="Message overhead for a 5-byte Tid using HMAC 256/64" anchor="comp-hmac-sha256"><artwork align="center"><![CDATA[
+------------------+-----+-----+---------+------------+
|     Structure    | Tid | MAC | COSE OH | Message OH |
+------------------+-----+-----+---------+------------+
| COSE_Mac0_Tagged | 5 B | 8 B |   13 B  |    26 B    |
+------------------+-----+-----+---------+------------+
]]></artwork></figure>

</section>
<section anchor="ssm-dig-sig" title="Signature Only">

<t>This example is based on ECDSA, with a signature of 64 bytes.</t>

<t>Since only one signature is used, the COSE_Sign1_Tagged structure is used 
(Section 4.2 of <xref target="I-D.ietf-cose-msg"/>).</t>

<t>The object in COSE encoding gives:</t>

<figure><artwork align="center"><![CDATA[
997(                         # COSE_Sign1_Tagged
  [
    h'a20444a1534e3c0641a3', # protected:
                               {04:h'a1534e3c',
                                06:h'a3'}
    {},                      # unprotected
    h'',                     # payload
    SIG                      # 64-byte signature
  ]
)
]]></artwork></figure>

<t>This COSE object encodes to a total size of 83 bytes.</t>

<t><xref target="comp-ecdsa"/> summarizes these results.</t>

<figure title="Message overhead for a 5-byte Tid using 64 byte ECDSA signature." anchor="comp-ecdsa"><artwork align="center"><![CDATA[
+-------------------+-----+------+---------+------------+
|     Structure     | Tid |  SIG | COSE OH | Message OH |
+-------------------+-----+------+---------+------------+
| COSE_Sign1_Tagged | 5 B | 64 B |   14 B  |  83 bytes  |
+-------------------+-----+------+---------+------------+
]]></artwork></figure>

</section>
<section anchor="sem-auth-enc" title="Authenticated Encryption with Additional Data (AEAD)">

<t>This example is based on AES-CCM with the Tag truncated to 8 bytes.</t>

<t>Since the key is implicitly known by the recipient, the COSE_Encrypt0_Tagged structure is used (Section 5.2 of <xref target="I-D.ietf-cose-msg"/>).</t>

<t>The object in COSE encoding gives:</t>

<figure><artwork align="center"><![CDATA[
993(                         # COSE_Encrypt0_Tagged
  [
    h'a20444a1534e3c0641a3', # protected:
                               {04:h'a1534e3c',
                                06:h'a3'}
    {},                      # unprotected
    TAG                      # ciphertext + truncated 8-byte TAG
  ]
)
]]></artwork></figure>

<t>This COSE object encodes to a total size of 25 bytes.</t>

<t><xref target="comp-aes-ccm"/> summarizes these results.</t>

<figure title="Message overhead for a 5-byte Tid using AES_128_CCM_8." anchor="comp-aes-ccm"><artwork align="center"><![CDATA[
+----------------------+-----+-----+---------+------------+
|       Structure      | Tid | TAG | COSE OH | Message OH |
+----------------------+-----+-----+---------+------------+
| COSE_Encrypt0_Tagged | 5 B | 8 B |   12 B  |  25 bytes  |
+----------------------+-----+-----+---------+------------+
]]></artwork></figure>

</section>
<section anchor="sem-seds" title="Symmetric Encryption with Asymmetric Signature (SEAS)">

<t>This example is based on AES-CCM and ECDSA with 64 bytes signature. The same assumption on the security context as in <xref target="sem-auth-enc"/>.
COSE defines the field &lsquo;counter signature w/o headers&rsquo; that is used here to sign a COSE_Encrypt0_Tagged message (see Section 3 of <xref target="I-D.ietf-cose-msg"/>).</t>

<t>The object in COSE encoding gives:</t>

<figure><artwork align="center"><![CDATA[
993(                         # COSE_Encrypt0_Tagged
  [
    h'a20444a1534e3c0641a3', # protected:
                               {04:h'a1534e3c',
                                06:h'a3'}
    {9:SIG},                 # unprotected: 
                                09: 64 bytes signature
    TAG                      # ciphertext + truncated 8-byte TAG
  ]
)
]]></artwork></figure>

<t>This COSE object encodes to a total size of 92 bytes.</t>

<t><xref target="comp-aes-ccm-ecdsa"/> summarizes these results.</t>

<figure title="Message overhead for a 5-byte Tid using AES-CCM countersigned with ECDSA." anchor="comp-aes-ccm-ecdsa"><artwork align="center"><![CDATA[
+----------------------+-----+-----+------+---------+------------+
|       Structure      | Tid | TAG | SIG  | COSE OH | Message OH |
+----------------------+-----+-----+------+---------+------------+
| COSE_Encrypt0_Tagged | 5 B | 8 B | 64 B |   15 B  |    92 B    |
+----------------------+-----+-----+------+---------+------------+
]]></artwork></figure>

</section>
</section>
<section anchor="context-example" title="Example of Security Contexts">

<t>This section shows an example of a Security Context established between a 
pair of nodes.  All binary values in these examples have been replaced with
simple strings for clarity, and none of the available COSE abbreviations are
used.  The contexts are represented in a non-normative JSON format.</t>

<figure title="Security Context of original Sender node." anchor="context-ex1"><artwork align="center"><![CDATA[
{
  Node="Node1",
  CommonPart = {
    Cid = "123",
    Alg = "AES-CCM-64-64-128",
    BaseKey = "ourKey"
  }
  SenderPart = {
    SenderId = "0x00",
    SenderKey = "firstKey",
    SenderIV = "456",
    SenderSeqNo = "74"
  }
  RecipientPart = {
    RecipientId = "0x01",
    RecipientKey = "secondKey",
    RecipientIV = "789",
    RecipientReplayWindow = {
      LastSeen = "85",
      Window = "11011101...."
    }
  }
}
]]></artwork></figure>
<figure title="Security Context of original Recipient node." anchor="context-ex2"><artwork align="center"><![CDATA[
{
  Node="Node2",
  CommonPart = {
    Cid = "123",
    Alg = "AES-CCM-64-64-128",
    BaseKey = "ourKey"
  }
  SenderPart = {
    SenderId = "0x01",
    SenderKey = "secondKey",
    SenderIV = "789",
    SenderSeqNo = "85"
  }
  RecipientPart = {
    RecipientId = "0x00",
    RecipientKey = "firstKey",
    RecipientIV = "456",
    RecipientReplayWindow = {
      LastSeen = "74",
      Window = "10011111...."
    }
  }
}

]]></artwork></figure>

</section>


  </back>
</rfc>

